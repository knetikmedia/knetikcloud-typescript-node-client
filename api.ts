/**
 * Knetik Platform API Documentation latest 
 * This is the spec for the Knetik API.  Use this in conjunction with the documentation found at https://knetikcloud.com
 *
 * OpenAPI spec version: latest 
 * Contact: support@knetik.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import request = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://localhost:8080/';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

export class AchievementDefinitionResource {
    /**
    * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this resource type
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * The date/time this resource was created in seconds since unix epoch
    */
    'createdDate': number;
    /**
    * The description of the achievement. Must be at least 2 characters in length.
    */
    'description': string;
    /**
    * Whether the achievement is hidden from the user
    */
    'hidden': boolean;
    /**
    * The name of the achievement. Must be at least 6 characters in length. IMMUTABLE
    */
    'name': string;
    /**
    * The required progress for the achievement definition
    */
    'requiredProgress': number;
    /**
    * The id of the rule generated for this achievement
    */
    'ruleId': string;
    /**
    * The tags for the achievement definition
    */
    'tags': Array<string>;
    /**
    * An achievement template this achievement is validated against (private). May be null and no validation of additional_properties will be done
    */
    'template': string;
    /**
    * The name of the trigger event associated with this achievement
    */
    'triggerEventName': string;
    /**
    * The date/time this resource was last updated in seconds since unix epoch
    */
    'updatedDate': number;
}

export class AchievementProgressUpdateRequest {
    /**
    * Whether to add one to the current progress instead of setting it to progress_value. Default: false
    */
    'incrementValue': boolean;
    /**
    * The amount of progress towards earning the achievement. The max/target depends on the achievement. Required if increment_value is false/missing.
    */
    'progressValue': number;
}

export class ActionResource {
    /**
    * The category the action is in. All customer specific actions are in the 'custom' category
    */
    'category': ActionResource.CategoryEnum;
    /**
    * The description of the action
    */
    'description': string;
    /**
    * The name of the action. Used as the unique id for reference
    */
    'name': string;
    /**
    * The variables required for the action
    */
    'variables': Array<ActionVariableResource>;
}

export namespace ActionResource {
    export enum CategoryEnum {
        Achievement = <any> 'achievement',
        Behavior = <any> 'behavior',
        Comment = <any> 'comment',
        Disposition = <any> 'disposition',
        Entitlement = <any> 'entitlement',
        Friends = <any> 'friends',
        Fulfillment = <any> 'fulfillment',
        Gamification = <any> 'gamification',
        Inventory = <any> 'inventory',
        Invoice = <any> 'invoice',
        Media = <any> 'media',
        Scheduler = <any> 'scheduler',
        Store = <any> 'store',
        Subscription = <any> 'subscription',
        User = <any> 'user',
        Wallet = <any> 'wallet',
        Custom = <any> 'custom',
        Challenge = <any> 'challenge',
        Activity = <any> 'activity',
        Campaign = <any> 'campaign',
        Event = <any> 'event'
    }
}
export class ActionVariableResource {
    /**
    * The name of the variable
    */
    'name': string;
    /**
    * Whether this variable is optional and can be left out/null
    */
    'optional': boolean;
    /**
    * The type of the variable (see variable type endpoint for list)
    */
    'type': string;
}

export class ActivityEntitlementResource {
    /**
    * The ISO3 currency code the price is in, if available
    */
    'currencyCode': string;
    /**
    * The id of the entitlement item
    */
    'itemId': number;
    /**
    * The name of the entitlement item
    */
    'name': string;
    /**
    * The price of the sku, if available
    */
    'price': number;
    /**
    * The sku id, if available. If multiple are available, then first one is returned
    */
    'sku': string;
}

export class ActivityOccurrenceCreationFailure {
    /**
    * The details of each user's entry, or just the current user's if not run with ACTIVITIES_ADMIN permission
    */
    'userResults': Array<ActivityOccurrenceJoinResult>;
}

export class ActivityOccurrenceJoinResult {
    /**
    * The details on the entitlement object needed to enter the occurrence (if any)
    */
    'entitlement': ActivityEntitlementResource;
    /**
    * Zero if the user was/could be added to the occurrence. Jsapi error code indicating the reason of the failure otherwise
    */
    'errorCode': number;
    /**
    * An error message if failure
    */
    'message': string;
    /**
    * The user's id
    */
    'userId': number;
}

export class ActivityOccurrenceResource {
    /**
    * The id of the activity
    */
    'activityId': number;
    /**
    * The id of the challenge activity (as part of the event, required if eventId set)
    */
    'challengeActivityId': number;
    /**
    * The date this occurrence was created, unix timestamp in seconds
    */
    'createdDate': number;
    /**
    * The entitlement item required to enter the occurrence. Required if not part of an event. Must come from the set of entitlement items listed in the activity
    */
    'entitlement': ActivityEntitlementResource;
    /**
    * The id of the event
    */
    'eventId': number;
    /**
    * The id of the activity occurrence
    */
    'id': number;
    /**
    * Indicate if the rewards have been given out already
    */
    'rewardStatus': ActivityOccurrenceResource.RewardStatusEnum;
    /**
    * The list of settings and their options available for this activity. Should be null on create if and only if part of an event
    */
    'settings': Array<SelectedSettingResource>;
    /**
    * Whether this occurrence will be played as a simulation.
    */
    'simulated': boolean;
    /**
    * The date this occurrence was started, unix timestamp in seconds. null if not yet started
    */
    'startDate': number;
    /**
    * The current status of the occurrence (default: OPEN)
    */
    'status': ActivityOccurrenceResource.StatusEnum;
    /**
    * The date this occurrence was last updated, unix timestamp in seconds
    */
    'updatedDate': number;
    /**
    * The list of users playing in this occurrence. Can only be set directly with ACTIVITIES_ADMIN permission
    */
    'users': Array<ActivityUserResource>;
}

export namespace ActivityOccurrenceResource {
    export enum RewardStatusEnum {
        Pending = <any> 'pending',
        Failed = <any> 'failed',
        Complete = <any> 'complete',
        Partial = <any> 'partial'
    }
    export enum StatusEnum {
        SETUP = <any> 'SETUP',
        OPEN = <any> 'OPEN',
        PLAYING = <any> 'PLAYING',
        FINISHED = <any> 'FINISHED',
        ABANDONED = <any> 'ABANDONED'
    }
}
export class ActivityOccurrenceResults {
    /**
    * The game results for each user. Include all users that played (paid to get in) even if they were eliminated without a result. A null metric is allowed
    */
    'users': Array<UserActivityResultsResource>;
}

export class ActivityResource {
    /**
    * The date/time this resource was created in seconds since unix epoch
    */
    'createdDate': number;
    /**
    * The list of items that can be used for entitlement (wager amounts/etc)
    */
    'entitlements': Array<ActivityEntitlementResource>;
    /**
    * The unique ID for that resource
    */
    'id': number;
    /**
    * Details about how to launch the activity
    */
    'launch': string;
    /**
    * The user friendly name of that resource. Defaults to blank string
    */
    'longDescription': string;
    /**
    * The user friendly name of that resource
    */
    'name': string;
    /**
    * The rewards to give at the end of each occurence of the activity. When creating/updating only id is used. Reward set must be pre-existing
    */
    'rewardSet': RewardSetResource;
    /**
    * The list of settings and their options available for this activity. Not populated when getting listing
    */
    'settings': Array<AvailableSettingResource>;
    /**
    * The user friendly name of that resource. Defaults to blank string
    */
    'shortDescription': string;
    /**
    * Whether this activity is a template for other activities. Default: false
    */
    'template': boolean;
    /**
    * The type of the activity
    */
    'type': string;
    /**
    * The unique key (for static reference in code) of the activity
    */
    'uniqueKey': string;
    /**
    * The date/time this resource was last updated in seconds since unix epoch
    */
    'updatedDate': number;
}

export class ActivityUserResource {
    /**
    * Whether this user is the 'host' of the occurrence and has increased access to settings/etc (default: false)
    */
    'host': boolean;
    /**
    * The id of the activity user entry
    */
    'id': number;
    /**
    * The date this user last joined the occurrence, unix timestamp in seconds
    */
    'joinedDate': number;
    /**
    * The date this user last left the occurrence, unix timestamp in seconds. Null if still present
    */
    'leftDate': number;
    /**
    * The metric for the user's results, after the game is over
    */
    'metric': MetricResource;
    /**
    * The current status of the user in the occurrence (default: present)
    */
    'status': ActivityUserResource.StatusEnum;
    /**
    * The user
    */
    'user': SimpleUserResource;
}

export namespace ActivityUserResource {
    export enum StatusEnum {
        Present = <any> 'present',
        Ready = <any> 'ready',
        Left = <any> 'left',
        Surrendered = <any> 'surrendered',
        Disconnected = <any> 'disconnected'
    }
}
export class AddressResource {
    /**
    * The first line of the address
    */
    'address1': string;
    /**
    * A second line of the address
    */
    'address2': string;
    /**
    * The city
    */
    'city': string;
    /**
    * The iso3 code for the country
    */
    'countryCode': string;
    /**
    * The postal code
    */
    'postalCode': string;
    /**
    * The code for the state. Required if the country has states/provinces/equivalent
    */
    'stateCode': string;
}

export class Affiliate {
    'affiliateKey': string;
    'id': number;
}

export class AggregateCountResource {
    'count': number;
    'date': string;
}

export class AggregateInvoiceReportResource {
    'count': number;
    'date': string;
    'revenue': number;
    'userCount': number;
}

export class AmazonS3Activity {
    /**
    * S3 action (i.e., 'PUT') associated with the activity
    */
    'action': string;
    /**
    * Date the resource was created in S3
    */
    'createdDate': number;
    /**
    * Name of the file being processed as a resource in S3
    */
    'filename': string;
    /**
    * Unique id of the S3 activity
    */
    'id': number;
    /**
    * S3 object key for the resource
    */
    'objectKey': string;
    /**
    * URL for accessing the S3 resource
    */
    'url': string;
    /**
    * The id of the user that created this S3 activity
    */
    'userId': number;
}

export class AnswerResource {
    /**
    * The answer to the question. Different 'type' values indicate different structures as the answer may be test, image, etc. See information on additional properties for the list and their structures
    */
    'answer': Property;
    /**
    * Whether the answer is correct or not
    */
    'correct': boolean;
    /**
    * The unique ID for that resource
    */
    'id': string;
}

export class ApplyPaymentRequest {
    /**
    * The id of the local invoice being paid.
    */
    'invoiceId': number;
    /**
    * The encoded receipt string from Apple's services.
    */
    'receipt': string;
    /**
    * The id of the specific transaction from Apple's services.
    */
    'transactionId': string;
}

export class ArticleResource {
    /**
    * Whether the article is active
    */
    'active': boolean;
    /**
    * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * The body of the article
    */
    'body': string;
    /**
    * The category for the article
    */
    'category': NestedCategory;
    /**
    * The date/time this resource was created in seconds since unix epoch
    */
    'createdDate': number;
    /**
    * The id of the article
    */
    'id': string;
    /**
    * The tags for the article
    */
    'tags': Array<string>;
    /**
    * An article template this article is validated against (private). May be null and no validation of additional_properties will be done
    */
    'template': string;
    /**
    * The title of the article
    */
    'title': string;
    /**
    * The date/time this resource was last updated in seconds since unix epoch
    */
    'updatedDate': number;
}

export class Artist {
    'additionalProperties': { [key: string]: Property; };
    'born': number;
    'contributionCount': number;
    'created': number;
    'died': number;
    'id': number;
    'longDescription': string;
    'name': string;
    'priority': number;
    'propertiesString': string;
    'shortDescription': string;
    'template': string;
    'updated': number;
}

export class ArtistResource {
    /**
    * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * YYYY/MM/DD when this artist was born
    */
    'born': string;
    /**
    * The current number of contributions the artist has made
    */
    'contributionCount': number;
    /**
    * The list of media this artist has contributed to as well as role(s) during contribution.  Use media endpoint to add contributions
    */
    'contributions': Array<ContributionResource>;
    /**
    * The date/time this resource was created in seconds since unix epoch
    */
    'createdDate': number;
    /**
    * YYYY/MM/DD when this artist died
    */
    'died': string;
    /**
    * The unique ID for that resource
    */
    'id': number;
    /**
    * The user friendly name of that resource. Defaults to blank string
    */
    'longDescription': string;
    /**
    * The user friendly name of that resource
    */
    'name': string;
    /**
    * The sort order priority ofr the artist.  Default 100
    */
    'priority': number;
    /**
    * The user friendly name of that resource. Defaults to blank string
    */
    'shortDescription': string;
    /**
    * An artist template this artist is validated against (private). May be null and no validation of additional_properties will be done
    */
    'template': string;
    /**
    * The date/time this resource was last updated in seconds since unix epoch
    */
    'updatedDate': number;
}

export class AvailableSettingResource {
    /**
    * Whether the setting is advanced. Default: false
    */
    'advancedOption': boolean;
    /**
    * The value of the default option (must be in options array)
    */
    'defaultValue': string;
    /**
    * The description of the setting
    */
    'description': string;
    /**
    * The unique ID for the setting
    */
    'key': string;
    /**
    * The textual name of the setting
    */
    'name': string;
    /**
    * The set of options available for this setting
    */
    'options': Array<SettingOption>;
}

export class BareActivityResource {
    /**
    * The date/time this resource was created in seconds since unix epoch
    */
    'createdDate': number;
    /**
    * The unique ID for that resource
    */
    'id': number;
    /**
    * Details about how to launch the activity
    */
    'launch': string;
    /**
    * The user friendly name of that resource. Defaults to blank string
    */
    'longDescription': string;
    /**
    * The user friendly name of that resource
    */
    'name': string;
    /**
    * The user friendly name of that resource. Defaults to blank string
    */
    'shortDescription': string;
    /**
    * Whether this activity is a template for other activities. Default: false
    */
    'template': boolean;
    /**
    * The type of the activity
    */
    'type': string;
    /**
    * The unique key (for static reference in code) of the activity
    */
    'uniqueKey': string;
    /**
    * The date/time this resource was last updated in seconds since unix epoch
    */
    'updatedDate': number;
}

export class BareChallengeActivityResource {
    /**
    * The id of the activity
    */
    'activityId': number;
    /**
    * The id of the challenge
    */
    'challengeId': number;
    /**
    * The unique ID for this resource
    */
    'id': number;
}

export class Batch {
    'batch': Array<BatchRequest>;
}

export class BatchRequest {
    /**
    * The request body as would be passed to the URI
    */
    'body': any;
    /**
    * Content type used, Ex:(application/json)
    */
    'contentType': string;
    /**
    * The HTTP method used, Ex: (GET)
    */
    'method': string;
    /**
    * Time in seconds before process will timeout.  Default is 60.  Range is 1-300
    */
    'timeout': number;
    /**
    * The oauth token only
    */
    'token': string;
    /**
    * Full URI of REST call
    */
    'uri': string;
}

export class BatchReturn {
    /**
    * The result body
    */
    'body': Result;
    /**
    * The HTTP response code
    */
    'code': number;
    /**
    * Full URI of REST call
    */
    'uri': string;
}

export class Behavior {
    /**
    * Used for polymorphic type recognition and thus must match an expected type with additional properties
    */
    'typeHint': string;
}

export class BillingReport {
    'created': number;
    'id': string;
    'lastKnownFailures': Array<string>;
    'statistics': { [key: string]: number; };
}

export class BooleanResource {
    'value': boolean;
}

export class BreCategoryResource {
    /**
    * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * The name of the category. Serves as the unique id
    */
    'name': string;
    /**
    * A template this BRE category is validated against (private). May be null and no validation of additional_properties will be done
    */
    'template': string;
}

export class BreEvent {
    /**
    * The event name of the trigger to be fired
    */
    'eventName': string;
    /**
    * The parameters to the event. A Map (assosiative array) with a key for each trigger parameter name and a corrosponding value.
    */
    'params': any;
}

export class BreEventLog {
    /**
    * The customer of the BRE event log
    */
    'customer': string;
    /**
    * The event id of the BRE event log
    */
    'eventId': number;
    /**
    * The event name of the BRE event log
    */
    'eventName': string;
    /**
    * The event start date of the BRE event log
    */
    'eventStartDate': number;
    /**
    * The id of the BRE event log
    */
    'id': string;
    /**
    * The event paramters of the BRE event log
    */
    'parameters': any;
    /**
    * The rules of the BRE event log
    */
    'rules': Array<BreRuleLog>;
}

export class BreGlobalResource {
    /**
    * A human readable description for display in admin pages
    */
    'description': string;
    /**
    * The id of the global definition. Default is a random guid. Cannot be updated
    */
    'id': string;
    /**
    * The key for the global. Must be unique when combined with scope names. Usually a single descriptive word like 'purchases' or 'logins'
    */
    'key': string;
    /**
    * A human readable name for display in admin pages
    */
    'name': string;
    /**
    * A list of scoping parameters. Allows the global to have a different value in different context such as a count of purchases for each user (by putting a 'user' scope in this list). When using this global in a rule these scopes will need to be mapped with an expression to provide a value, similar to the parameters in an action
    */
    'scopes': Array<BreGlobalScopeDefinition>;
    /**
    * Where this global came from. System globals cannot be removed or updated
    */
    'systemGlobal': boolean;
    /**
    * The variable type the global stores. See the See Bre Variables enpoint for list
    */
    'type': string;
}

export class BreGlobalScopeDefinition {
    /**
    * The name of the scoping parameter. This is used as the unique identifier of this scope
    */
    'name': string;
    /**
    * The variable type of this scoping parameter. See Bre Variables endpoint for list
    */
    'type': string;
}

export class BreRule {
    /**
    * A list of actions to execute, and the mapping for their parameters, when the rule runs. Minimum 1
    */
    'actions': ActionResource;
    /**
    * A condition expression that must be met in a given event for the rule to run. Empty to always run
    */
    'condition': PredicateOperation;
    /**
    * The condition as a readable string. Filled in by the system from the condition
    */
    'conditionText': string;
    /**
    * The human readable description of the rule
    */
    'description': string;
    /**
    * Whether the rule is enabled to run (in conjunction with dates). Default true
    */
    'enabled': boolean;
    /**
    * The date the rule ceases to take effect, or null if never. Unix timestamp in seconds
    */
    'endDate': number;
    /**
    * The event name of the trigger this rule runs for. Affects which parameters are available
    */
    'eventName': string;
    /**
    * The id of the rule for later references. If left null a random guid will be generated. Must be unique. Cannot be changed
    */
    'id': string;
    /**
    * The human readable name of the rule
    */
    'name': string;
    /**
    * Used to sort rules to control the order they run in. Larger numbered sort values run first.  Default 500
    */
    'sort': number;
    /**
    * The date the rule begins to take effect, or null if always. Unix timestamp in seconds
    */
    'startDate': number;
    /**
    * Whether the rule is a default part of the system. System rules cannot be edited or deleted, but may be disabled
    */
    'systemRule': boolean;
}

export class BreRuleLog {
    /**
    * Whether the rule ran
    */
    'ran': boolean;
    /**
    * The reason for the rule
    */
    'reason': string;
    /**
    * The end date of the rule in seconds
    */
    'ruleEndDate': number;
    /**
    * The id of the rule
    */
    'ruleId': string;
    /**
    * The name of the rule
    */
    'ruleName': string;
    /**
    * The start date of the rule in seconds
    */
    'ruleStartDate': number;
}

export class BreTriggerParameterDefinition {
    /**
    * The name of the parameter. This is used as the unique identifier of this parameter
    */
    'name': string;
    /**
    * The variable type of this parameter. See Bre Variables endpoint for list
    */
    'type': string;
}

export class BreTriggerResource {
    /**
    * The category this trigger belongs to. See endpoints for related asset information. All new triggers are in category 'custom'
    */
    'category': BreTriggerResource.CategoryEnum;
    /**
    * The unique name for the event. This serves as the unique identifier. Cannot be changed after creation
    */
    'eventName': string;
    /**
    * A list af parameters that will be sent with the event when the trigger is fired. These must be included in the event and match the described types
    */
    'parameters': Array<BreTriggerParameterDefinition>;
    /**
    * Where this trigger came from. System triggers cannot be removed or updated
    */
    'systemTrigger': boolean;
    /**
    * A description of the trigger
    */
    'triggerDescription': string;
    /**
    * A human readable name for this trigger
    */
    'triggerName': string;
}

export namespace BreTriggerResource {
    export enum CategoryEnum {
        Achievement = <any> 'achievement',
        Behavior = <any> 'behavior',
        Comment = <any> 'comment',
        Disposition = <any> 'disposition',
        Entitlement = <any> 'entitlement',
        Friends = <any> 'friends',
        Fulfillment = <any> 'fulfillment',
        Gamification = <any> 'gamification',
        Inventory = <any> 'inventory',
        Invoice = <any> 'invoice',
        Media = <any> 'media',
        Scheduler = <any> 'scheduler',
        Store = <any> 'store',
        Subscription = <any> 'subscription',
        User = <any> 'user',
        Wallet = <any> 'wallet',
        Custom = <any> 'custom',
        Challenge = <any> 'challenge',
        Activity = <any> 'activity',
        Campaign = <any> 'campaign',
        Event = <any> 'event'
    }
}
export class BundleItem {
    /**
    * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type, or be an extra not from the template
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * The behaviors linked to the item, describing various options and interactions. May not be included in item lists
    */
    'behaviors': Array<Behavior>;
    /**
    * The skus of items to be included in this bundle, and how they influence the bundle total price.  Must have at least one SKU
    */
    'bundledSkus': Array<BundledSku>;
    /**
    * A category for filtering items
    */
    'category': string;
    /**
    * The date the item was created, unix timestamp in seconds
    */
    'createdDate': number;
    /**
    * Whether or not the item is currently displayable.  Default = true
    */
    'displayable': boolean;
    /**
    * A list of country ID to include in the blacklist/whitelist geo policy
    */
    'geoCountryList': Array<string>;
    /**
    * Whether to use the geo_country_list as a black list or white list for item geographical availability
    */
    'geoPolicyType': BundleItem.GeoPolicyTypeEnum;
    /**
    * The id of the item
    */
    'id': number;
    /**
    * A long description of the item
    */
    'longDescription': string;
    /**
    * The name of the item
    */
    'name': string;
    /**
    * Provides the abstract shipping needs if this item is physical and can be shipped.  A value of zero means no shipping needed.  Default = 0
    */
    'shippingTier': number;
    /**
    * A short description of the item, max 255 chars
    */
    'shortDescription': string;
    /**
    * The skus for the item. Each defines a unique configuration for the item to be purchased (Large-Blue, Small-Green, etc). These are what is ultimately selected in the store and added to the cart
    */
    'skus': Array<Sku>;
    /**
    * A number to use in sorting items.  Default 500
    */
    'sort': number;
    /**
    * The date the item will leave the store, unix timestamp in seconds.  If set to null, item will never leave the store
    */
    'storeEnd': number;
    /**
    * The date the item will appear in the store, unix timestamp in seconds.  If set to null, item will appear in store immediately
    */
    'storeStart': number;
    /**
    * List of tags used for filtering items
    */
    'tags': Array<string>;
    /**
    * An item template this item is validated against.  May be null and no validation of additional_properties will be done.  Default = null
    */
    'template': string;
    /**
    * The type of the item
    */
    'typeHint': string;
    /**
    * The unique key for the item
    */
    'uniqueKey': string;
    /**
    * The date the item was last updated, unix timestamp in seconds
    */
    'updatedDate': number;
    /**
    * The vendor who provides the item
    */
    'vendorId': number;
}

export namespace BundleItem {
    export enum GeoPolicyTypeEnum {
        Whitelist = <any> 'whitelist',
        Blacklist = <any> 'blacklist'
    }
}
export class BundledSku {
    /**
    * The amount this item will cost inside the bundle instead of its regular price
    */
    'priceOverride': number;
    /**
    * The quantity of this item within the bundle
    */
    'quantity': number;
    /**
    * The stock keeping unit (SKU) for an item included in the bundle
    */
    'sku': string;
}

export class CampaignResource {
    /**
    * Whether the campaign is active or not.  Defaults to false
    */
    'active': boolean;
    /**
    * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * The date/time this resource was created in seconds since unix epoch
    */
    'createdDate': number;
    /**
    * The unique ID for that resource
    */
    'id': number;
    /**
    * The strategy for calculating the leaderboard. Defaults to highest score. Value MUST come from the list of available strategies from the Leaderboard Service
    */
    'leaderboardStrategy': string;
    /**
    * The user friendly name of that resource. Defaults to blank string
    */
    'longDescription': string;
    /**
    * The user friendly name of that resource
    */
    'name': string;
    /**
    * The name of the next challenge coming up
    */
    'nextChallenge': string;
    /**
    * The date/time of the next challenge coming up
    */
    'nextChallengeDate': number;
    /**
    * The rewards to give at the end of the campaign. When creating/updating only id is used. Reward set must be pre-existing
    */
    'rewardSet': RewardSetResource;
    /**
    * Indicate if the rewards have been given out already
    */
    'rewardStatus': CampaignResource.RewardStatusEnum;
    /**
    * The user friendly name of that resource. Defaults to blank string
    */
    'shortDescription': string;
    /**
    * A campaign template this campaign is validated against (private). May be null and no validation of additional_properties will be done
    */
    'template': string;
    /**
    * The date/time this resource was last updated in seconds since unix epoch
    */
    'updatedDate': number;
}

export namespace CampaignResource {
    export enum RewardStatusEnum {
        Pending = <any> 'pending',
        Failed = <any> 'failed',
        Complete = <any> 'complete',
        Partial = <any> 'partial'
    }
}
export class Cart {
    'countryTax': number;
    'coupons': Array<CouponDefinition>;
    'created': number;
    'currencyCode': string;
    'discountTotal': number;
    'errorCode': number;
    'errorMessage': string;
    'grandTotal': number;
    'id': string;
    'invoiceId': number;
    'items': Array<CartLineItem>;
    'owner': number;
    'selectedShippingOptions': Array<CartShippingOption>;
    'shippable': boolean;
    'shippingAddress': CartShippingAddressRequest;
    'shippingCost': number;
    'shippingOptions': { [key: string]: Set; };
    'stateTax': number;
    'status': Cart.StatusEnum;
    'subtotal': number;
    'updated': number;
}

export namespace Cart {
    export enum StatusEnum {
        Active = <any> 'active',
        Processing = <any> 'processing',
        Closed = <any> 'closed',
        Onhold = <any> 'onhold'
    }
}
export class CartItemRequest {
    /**
    * The affiliate key of the item
    */
    'affiliateKey': string;
    /**
    * The catalog SKU of the item
    */
    'catalogSku': string;
    /**
    * The quantity of the item
    */
    'quantity': number;
}

export class CartLineItem {
    'currencyCode': string;
    'description': string;
    'discount': Discount;
    'lineTotal': number;
    'name': string;
    'originalLineTotal': number;
    'originalUnitPrice': number;
    'qty': number;
    'saleName': string;
    'sku': string;
    'skuDescription': string;
    'storeItemId': number;
    'tags': Array<string>;
    'thumbUrl': string;
    'unitPrice': number;
    'vendorId': number;
    'vendorName': string;
}

export class CartShippableResponse {
    /**
    * The id of the cart
    */
    'cartId': number;
    /**
    * Whether the item is shippable
    */
    'shippable': boolean;
}

export class CartShippingAddressRequest {
    /**
    * The city of the user
    */
    'city': string;
    /**
    * The country code of the user
    */
    'countryCodeIso3': string;
    /**
    * The email of the user
    */
    'email': string;
    /**
    * The first name of the user
    */
    'firstName': string;
    /**
    * The last name of the user
    */
    'lastName': string;
    'namePrefix': string;
    /**
    * The order notes the user
    */
    'orderNotes': string;
    /**
    * The phone number of the user
    */
    'phoneNumber': string;
    /**
    * The postal state code of the user
    */
    'postalStateCode': string;
    /**
    * The shipping address of the user, first line
    */
    'shippingAddressLine1': string;
    /**
    * The shipping address of the user, second line
    */
    'shippingAddressLine2': string;
    /**
    * The zipcode of the user
    */
    'zip': string;
}

export class CartShippingOption {
    'currencyCode': string;
    'description': string;
    'name': string;
    'originalPrice': number;
    'price': number;
    'shippingItemId': number;
    'sku': string;
    'taxable': boolean;
    'vendorId': number;
    'vendorName': string;
}

export class CartSummary {
    /**
    * The date/time this resource was created in seconds since unix epoch
    */
    'createdDate': number;
    /**
    * The unique id code for the currency used in the cart
    */
    'currencyCode': string;
    /**
    * The grand total for the cart
    */
    'grandTotal': number;
    /**
    * The unique ID for the cart
    */
    'id': string;
    /**
    * The ID of the invoice associated with this cart
    */
    'invoiceId': number;
    /**
    * The number of items in the cart
    */
    'itemsInCart': number;
    /**
    * The status of the cart
    */
    'status': CartSummary.StatusEnum;
    /**
    * The subtotal of all items in the cart
    */
    'subtotal': number;
}

export namespace CartSummary {
    export enum StatusEnum {
        Active = <any> 'active',
        Processing = <any> 'processing',
        Closed = <any> 'closed',
        Onhold = <any> 'onhold'
    }
}
export class CatalogSale {
    /**
    * The iso3 code for the currency for this discountValue.  The sku purchased will have to match for it this sale to apply
    */
    'currencyCode': string;
    /**
    * The way in which the price is reduced. 'value' means subtracting directly, 'percentage' means subtracting by the price times the discountValue (1.0 == 100%)
    */
    'discountType': CatalogSale.DiscountTypeEnum;
    /**
    * The amount deducted from the price, in the same currencyCode as the item
    */
    'discountValue': number;
    /**
    * The id of the sale
    */
    'id': number;
    /**
    * The id of the item this sale applies to.  Leave null to use other filters
    */
    'item': number;
    /**
    * The long description of the sale
    */
    'longDescription': string;
    /**
    * The name of the sale.  Max 40 characters
    */
    'name': string;
    /**
    * The date the sale ends, null for never.  Unix timestamp in seconds
    */
    'saleEndDate': number;
    /**
    * The date the sale begins.  Unix timestamp in seconds
    */
    'saleStartDate': number;
    /**
    * The short description of the sale.  Max 140 characters
    */
    'shortDescription': string;
    /**
    * The tag this sale applies to.  Leave null to skip this filter (applies to all tags)
    */
    'tag': string;
    /**
    * The id of the vendor this sale applies to.  Leave null to skip this filter (applies to all vendors)
    */
    'vendor': number;
}

export namespace CatalogSale {
    export enum DiscountTypeEnum {
        Value = <any> 'value',
        Percentage = <any> 'percentage'
    }
}
export class CategoryResource {
    /**
    * Whether the category is currently active. If not, it and its questions will be filtered out.
    */
    'active': boolean;
    /**
    * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * The unique ID for this category
    */
    'id': string;
    /**
    * The name of this category. Cannot be blank
    */
    'name': string;
    /**
    * A category template this category is validated against (private). May be null and no validation of additional_properties will be done
    */
    'template': string;
}

export class ChallengeActivityResource {
    /**
    * The id of the activity
    */
    'activityId': number;
    /**
    * The id of the challenge
    */
    'challengeId': number;
    /**
    * The entitlement item needed to participate in the activity as part of this event. Null indicates free entry. When creating/updating only id is used. Item must be pre-existing
    */
    'entitlement': ActivityEntitlementResource;
    /**
    * The unique ID for this resource
    */
    'id': number;
    /**
    * The rewards to give at the end of each occurence of the activity. When creating/updating only id is used. Reward set must be pre-existing
    */
    'rewardSet': RewardSetResource;
    /**
    * The list of settings and the select options
    */
    'settings': Array<SelectedSettingResource>;
}

export class ChallengeEventParticipantResource {
    'email': string;
    'fullname': string;
    'score': number;
    'userId': number;
    'username': string;
}

export class ChallengeEventResource {
    /**
    * The id of the challenge
    */
    'challengeId': number;
    /**
    * The end date in seconds
    */
    'endDate': number;
    /**
    * The id of the challenge event
    */
    'id': number;
    /**
    * Indicate if the rewards have been given out already 
    */
    'rewardStatus': ChallengeEventResource.RewardStatusEnum;
    /**
    * The start date in seconds
    */
    'startDate': number;
}

export namespace ChallengeEventResource {
    export enum RewardStatusEnum {
        Pending = <any> 'pending',
        Failed = <any> 'failed',
        Complete = <any> 'complete',
        Partial = <any> 'partial'
    }
}
export class ChallengeResource {
    /**
    * The number of activities allowed to this challenge
    */
    'activities': number;
    /**
    * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * The id of the campaign this challenge is a part of. The challenge must be tied to an active campaign before it will spawn events
    */
    'campaignId': number;
    /**
    * The ID of the original challenge it was copied from
    */
    'copyOf': number;
    /**
    * The date/time this resource was created in seconds since unix epoch
    */
    'createdDate': number;
    /**
    * The end date of this challenge in seconds since epoch. required if part of a campaign
    */
    'endDate': number;
    /**
    * The unique ID for that resource
    */
    'id': number;
    /**
    * The strategy for calculating the leaderboard. Defaults to highest score. Value MUST come from the list of available strategies from the Leaderboard Service.
    */
    'leaderboardStrategy': string;
    /**
    * The user friendly name of that resource. Defaults to blank string
    */
    'longDescription': string;
    /**
    * The user friendly name of that resource
    */
    'name': string;
    /**
    * The next date this challenge will be occur in seconds since epoch
    */
    'nextEventDate': number;
    /**
    * The number of minutes minimum to wait at the end of this challenge before running rewards, to allow activities to complete
    */
    'rewardLagMinutes': number;
    /**
    * The rewards to give at the end of the challenge. When creating/updating only id is used. Reward set must be pre-existing
    */
    'rewardSet': RewardSetResource;
    /**
    * The repeat schedule for the challenge
    */
    'schedule': Schedule;
    /**
    * The user friendly name of that resource. Defaults to blank string
    */
    'shortDescription': string;
    /**
    * The start date of this challenge in seconds since epoch. required if part of a campaign
    */
    'startDate': number;
    /**
    * A challenge template this challenge is validated against (private). May be null and no validation of additional_properties will be done
    */
    'template': string;
    /**
    * The date/time this resource was last updated in seconds since unix epoch
    */
    'updatedDate': number;
}

export class CityResource {
    /**
    * The iso3 of the country this city is in
    */
    'countryCodeIso3': string;
    /**
    * The unique ID for this city
    */
    'id': number;
    /**
    * The name of the city
    */
    'name': string;
    /**
    * The code for the state this city is in
    */
    'stateCode': string;
}

export class ClientResource {
    /**
    * The time limit of the token in seconds
    */
    'accessTokenValiditySeconds': number;
    /**
    * The client key, cannot be edited once created
    */
    'clientKey': string;
    /**
    * The grant types of the client
    */
    'grantTypes': Array<string>;
    /**
    * The id of the client
    */
    'id': number;
    /**
    * Whether the client is public or not
    */
    'isPublic': boolean;
    /**
    * Whether a client is locked from being deleted
    */
    'locked': boolean;
    /**
    * The name of the client
    */
    'name': string;
    /**
    * The redirect uris of the client
    */
    'redirectUris': Array<string>;
    /**
    * The time limit of the refresh token in seconds
    */
    'refreshTokenValiditySeconds': number;
    /**
    * The secret key of the client
    */
    'secret': string;
}

export class CollectionCountry {
}

export class CollectionVideoContribution {
}

export class Collectionstring {
}

export class CommentResource {
    /**
    * The comment content of that resource
    */
    'content': string;
    /**
    * The type of object this comment applies to (ex: video, article, etc). Required when passed to /comments
    */
    'context': string;
    /**
    * The id of the object this comment applies to.  Required when passed to /comments
    */
    'contextId': number;
    /**
    * The date/time this resource was created in seconds since epoch
    */
    'createdDate': number;
    /**
    * The unique ID for that resource
    */
    'id': number;
    /**
    * The summary of that resource
    */
    'summary': string;
    /**
    * The date/time this resource was last updated in seconds since epoch
    */
    'updatedDate': number;
    /**
    * The user who created the comment
    */
    'user': SimpleUserResource;
}

export class CommentSearch {
    'content': string;
    'context': string;
    'contextId': number;
    'id': number;
    'ownerId': number;
    'ownerUsername': string;
}

export class Config {
    /**
    * The name of the config
    */
    'name': string;
    /**
    * Whether the config is public for viewing. True means that it can be publicly viewed by all. Default: false
    */
    'publicRead': boolean;
    /**
    * The value of the config
    */
    'value': string;
}

export class ContributionResource {
    /**
    * A reference to the contributing artist
    */
    'artist': SimpleReferenceResourcelong;
    /**
    * A reference to the media being contributed to
    */
    'media': SimpleReferenceResourcelong;
    /**
    * The nature of the contribution (role of the artist as in 'producer', 'performer', etc)
    */
    'role': string;
}

export class Country {
    'id': number;
    'iso2': string;
    'iso3': string;
    'name': string;
}

export class CountryResource {
    /**
    * The iso2 of the country
    */
    'iso2': string;
    /**
    * The iso3 of the country
    */
    'iso3': string;
    /**
    * The name of the country resource
    */
    'name': string;
}

export class CountryTaxResource {
    /**
    * The iso3 code of the country, cannot be changed
    */
    'countryIso3': string;
    /**
    * The name of the tax
    */
    'name': string;
    /**
    * The tax rate as a percentage to a maximum of two decimal places (1.5 means 1.5%)
    */
    'rate': number;
    /**
    * Whether the tax applies to shipping costs
    */
    'taxShipping': boolean;
}

export class CouponDefinition {
    'code': string;
    'description': string;
    'discountType': CouponDefinition.DiscountTypeEnum;
    'exclusive': boolean;
    'maxDiscount': number;
    'maxQuantity': number;
    'minCartTotal': number;
    'name': string;
    'selfExclusive': boolean;
    'targetItemId': number;
    'type': CouponDefinition.TypeEnum;
    'validForTags': Array<string>;
    'value': number;
    'vendorId': number;
}

export namespace CouponDefinition {
    export enum DiscountTypeEnum {
        Value = <any> 'value',
        Percentage = <any> 'percentage'
    }
    export enum TypeEnum {
        Cart = <any> 'coupon_cart',
        SingleItem = <any> 'coupon_single_item',
        Voucher = <any> 'coupon_voucher',
        Vendor = <any> 'coupon_vendor',
        Tag = <any> 'coupon_tag'
    }
}
export class CouponItem {
    /**
    * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type, or be an extra not from the template
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * The behaviors linked to the item, describing various options and interactions. May not be included in item lists
    */
    'behaviors': Array<Behavior>;
    /**
    * A category for filtering items
    */
    'category': string;
    /**
    * The type of coupon
    */
    'couponTypeHint': CouponItem.CouponTypeHintEnum;
    /**
    * The date the item was created, unix timestamp in seconds
    */
    'createdDate': number;
    /**
    * The amount this coupon is maxed out at.  Applies if coupon_type_hint is coupon_cart
    */
    'discountMax': number;
    /**
    * The minimium amount needed in the cart for the coupon to apply.  Applies if coupon_type_hint is coupon_cart
    */
    'discountMinCartValue': number;
    /**
    * The type of coupon discount
    */
    'discountType': CouponItem.DiscountTypeEnum;
    /**
    * The amount the coupon will discount the item
    */
    'discountValue': number;
    /**
    * Whether or not the item is currently displayable.  Default = true
    */
    'displayable': boolean;
    /**
    * Whether this coupon is exclusive or not (true means cannot be in same cart as another).  Default = false
    */
    'exclusive': boolean;
    /**
    * A list of country ID to include in the blacklist/whitelist geo policy
    */
    'geoCountryList': Array<string>;
    /**
    * Whether to use the geo_country_list as a black list or white list for item geographical availability
    */
    'geoPolicyType': CouponItem.GeoPolicyTypeEnum;
    /**
    * The id of the item
    */
    'id': number;
    /**
    * The id of the item the coupon is applied to.  Applies if coupon_type_hint is coupon_single_item or coupon_voucher
    */
    'itemId': number;
    /**
    * A long description of the item
    */
    'longDescription': string;
    /**
    * The maximum quantity of items the coupon can apply to, null if no limit and minimum 1 otherwise.  Applies if coupon_type_hint is coupon_single_item or coupon_voucher
    */
    'maxQuantity': number;
    /**
    * The name of the item
    */
    'name': string;
    /**
    * Whether this coupon is exclusive to itself or not (true means cannot add two of this same coupon to the same cart).  Default = false
    */
    'selfExclusive': boolean;
    /**
    * Provides the abstract shipping needs if this item is physical and can be shipped.  A value of zero means no shipping needed.  Default = 0
    */
    'shippingTier': number;
    /**
    * A short description of the item, max 255 chars
    */
    'shortDescription': string;
    /**
    * The skus for the item. Each defines a unique configuration for the item to be purchased (Large-Blue, Small-Green, etc). These are what is ultimately selected in the store and added to the cart
    */
    'skus': Array<Sku>;
    /**
    * A number to use in sorting items.  Default 500
    */
    'sort': number;
    /**
    * The date the item will leave the store, unix timestamp in seconds.  If set to null, item will never leave the store
    */
    'storeEnd': number;
    /**
    * The date the item will appear in the store, unix timestamp in seconds.  If set to null, item will appear in store immediately
    */
    'storeStart': number;
    /**
    * List of tags used for filtering items
    */
    'tags': Array<string>;
    /**
    * An item template this item is validated against.  May be null and no validation of additional_properties will be done.  Default = null
    */
    'template': string;
    /**
    * The type of the item
    */
    'typeHint': string;
    /**
    * The unique key for the item
    */
    'uniqueKey': string;
    /**
    * The date the item was last updated, unix timestamp in seconds
    */
    'updatedDate': number;
    /**
    * A list of tags for a coupon.  The coupon can only apply to an item that has at least one of these tags.  Applies if coupon_type_hint is coupon_tag
    */
    'validForTags': Array<string>;
    /**
    * The vendor who provides the item
    */
    'vendorId': number;
}

export namespace CouponItem {
    export enum CouponTypeHintEnum {
        Cart = <any> 'coupon_cart',
        SingleItem = <any> 'coupon_single_item',
        Voucher = <any> 'coupon_voucher',
        Vendor = <any> 'coupon_vendor',
        Tag = <any> 'coupon_tag'
    }
    export enum DiscountTypeEnum {
        Value = <any> 'value',
        Percentage = <any> 'percentage'
    }
    export enum GeoPolicyTypeEnum {
        Whitelist = <any> 'whitelist',
        Blacklist = <any> 'blacklist'
    }
}
export class CreateBillingAgreementRequest {
    /**
    * The endpoint URL to which PayPal should forward the user if they cancel (do not accept) the agreement
    */
    'cancelUrl': string;
    /**
    * The endpoint URL to which PayPal should forward the user after they accept the agreement. This endpoint will receive information needed for the next step
    */
    'returnUrl': string;
    /**
    * The ID of the user. Defaults to the logged in user
    */
    'userId': number;
}

export class CreatePayPalPaymentRequest {
    /**
    * The endpoint URL to which PayPal should forward the user to if they cancel the checkout process
    */
    'cancelUrl': string;
    /**
    * The ID of an invoice to pay
    */
    'invoiceId': number;
    /**
    * The endpoint URL to which PayPal should forward the user after they accept. This endpoint will receive information needed for the next step
    */
    'returnUrl': string;
}

export class Currency {
    'active': boolean;
    'code': string;
    'dateCreated': number;
    'dateUpdated': number;
    'factor': number;
    'icon': string;
    'id': number;
    'name': string;
    'type': Currency.TypeEnum;
    'virtual': boolean;
}

export namespace Currency {
    export enum TypeEnum {
        Real = <any> 'real',
        Virtual = <any> 'virtual'
    }
}
export class CurrencyResource {
    /**
    * Whether the currency is active. Default true
    */
    'active': boolean;
    /**
    * The unique id code for the currency. Maximum 5 characters
    */
    'code': string;
    /**
    * The unix timestamp in seconds the currency was added to the system
    */
    'createdDate': number;
    /**
    * The decimal to multiply the system base currency (from config 'currency') to localize to this one. Should be 1 for the base currency itself.
    */
    'factor': number;
    /**
    * The url for an icon of the currency
    */
    'icon': string;
    /**
    * The name of the currency
    */
    'name': string;
    /**
    * The type of currency. Default 'real'
    */
    'type': CurrencyResource.TypeEnum;
    /**
    * The unix timestamp in seconds the currency was last updated in the system.
    */
    'updatedDate': number;
}

export namespace CurrencyResource {
    export enum TypeEnum {
        Real = <any> 'real',
        Virtual = <any> 'virtual'
    }
}
export class DeltaResource {
    /**
    * The id of the category for question
    */
    'categoryId': string;
    /**
    * The media type of the question
    */
    'mediaType': string;
    /**
    * The id of the question
    */
    'questionId': string;
    /**
    * Whether the question was updated or removed
    */
    'state': DeltaResource.StateEnum;
    /**
    * The tags for the question
    */
    'tags': Array<string>;
    /**
    * The date this question was last updated in seconds since unix epoch
    */
    'updatedDate': number;
}

export namespace DeltaResource {
    export enum StateEnum {
        UPDATED = <any> 'UPDATED',
        REMOVED = <any> 'REMOVED'
    }
}
export class DeviceResource {
    /**
    * The authorization code for the device
    */
    'authorization': string;
    /**
    * The current condition of the device (New, Defective, Reconditioned)
    */
    'condition': DeviceResource.ConditionEnum;
    /**
    * The date the device log was created
    */
    'createdDate': number;
    /**
    * The key/value pairs for extended data
    */
    'data': { [key: string]: string; };
    /**
    * The description of the device
    */
    'description': string;
    /**
    * The type of the device
    */
    'deviceType': string;
    /**
    * The unique ID for this device. Cannot be changed once created
    */
    'id': number;
    /**
    * The location of the device
    */
    'location': string;
    /**
    * The MAC (media access control) address of the device
    */
    'macAddress': string;
    /**
    * The make of the device
    */
    'make': string;
    /**
    * The model of the device
    */
    'model': string;
    /**
    * The name of the device
    */
    'name': string;
    /**
    * The OS (operating system) on the device
    */
    'os': string;
    /**
    * The serial number of the device
    */
    'serial': string;
    /**
    * The current status the device (Active, Pending Active, Inactive, Repair
    */
    'status': DeviceResource.StatusEnum;
    /**
    * The date the device log was updated
    */
    'updatedDate': number;
    /**
    * The user that owns the device
    */
    'user': SimpleUserResource;
}

export namespace DeviceResource {
    export enum ConditionEnum {
        New = <any> 'New',
        Defective = <any> 'Defective',
        Reconditioned = <any> 'Reconditioned'
    }
    export enum StatusEnum {
        Active = <any> 'Active',
        PendingActive = <any> 'PendingActive',
        Inactive = <any> 'Inactive',
        Repair = <any> 'Repair'
    }
}
export class Discount {
    'description': string;
    'name': string;
    'sku': string;
    'value': number;
}

export class DispositionCount {
    /**
    * The number of users that have expressed this disposition
    */
    'count': number;
    /**
    * The name of the disposition this count is for
    */
    'name': string;
}

export class DispositionResource {
    /**
    * The context of that resource. Required when passed to /dispositions rather than context specific endpoint
    */
    'context': string;
    /**
    * The context_id of that resource. Required when passed to /dispositions rather than context specific endpoint
    */
    'contextId': string;
    /**
    * The date/time this resource was created in seconds since unix epoch
    */
    'createdDate': number;
    /**
    * The unique ID for that resource
    */
    'id': number;
    /**
    * The name of the disposition, 1-20 characters. (ex: like/dislike/favorite, etc)
    */
    'name': string;
    /**
    * The user
    */
    'user': SimpleUserResource;
}

export class EntitlementGrantRequest {
    /**
    * The ID of the entitlement item to grant
    */
    'entitlementId': number;
}

export class EntitlementItem {
    /**
    * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type, or be an extra not from the template
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * The behaviors linked to the item, describing various options and interactions. May not be included in item lists
    */
    'behaviors': Array<Behavior>;
    /**
    * A category for filtering items
    */
    'category': string;
    /**
    * The date the item was created, unix timestamp in seconds
    */
    'createdDate': number;
    /**
    * The id of the item
    */
    'id': number;
    /**
    * A long description of the item
    */
    'longDescription': string;
    /**
    * The name of the item
    */
    'name': string;
    /**
    * A short description of the item, max 255 chars
    */
    'shortDescription': string;
    /**
    * A number to use in sorting items.  Default 500
    */
    'sort': number;
    /**
    * List of tags used for filtering items
    */
    'tags': Array<string>;
    /**
    * An item template this item is validated against.  May be null and no validation of additional_properties will be done.  Default = null
    */
    'template': string;
    /**
    * The type of the item
    */
    'typeHint': string;
    /**
    * The unique key for the item
    */
    'uniqueKey': string;
    /**
    * The date the item was last updated, unix timestamp in seconds
    */
    'updatedDate': number;
}

export class Expressionobject {
}

export class FinalizeBillingAgreementRequest {
    /**
    * The ID of the invoice being paid along with the creation of this agreement
    */
    'invoiceId': number;
    /**
    * Whether the new payment method created should be the user's default
    */
    'newDefault': boolean;
    /**
    * The payer ID from PayPal (passed as a parameter in the return URL). Only required if an invoice ID was included
    */
    'payerId': string;
    /**
    * The token from PayPal (passed as a parameter in the return URL)
    */
    'token': string;
    /**
    * The ID of the user. Defaults to the logged in user
    */
    'userId': number;
}

export class FinalizePayPalPaymentRequest {
    /**
    * The ID of the invoice that is being paid. Must match the invoice sent in originally
    */
    'invoiceId': number;
    /**
    * The ID of the payer that PayPal returned with the user at the return URL
    */
    'payerId': string;
    /**
    * The token that PayPal returned with the user in the return URL
    */
    'token': string;
}

export class FlagReportResource {
    /**
    * The context of that resource 
    */
    'context': string;
    /**
    * The context ID of that resource
    */
    'contextId': string;
    /**
    * The date/time this resource was created in seconds since epoch
    */
    'createdDate': number;
    /**
    * The unique ID for that resource
    */
    'id': number;
    /**
    * The reason of that resource required only in case of active resolution
    */
    'reason': string;
    /**
    * The resolution of that resource
    */
    'resolution': FlagReportResource.ResolutionEnum;
    /**
    * The date/time this report was resolved in seconds since epoch. Null if not resolved yet
    */
    'resolved': number;
    /**
    * The date/time this resource was last updated in seconds since epoch
    */
    'updatedDate': number;
}

export namespace FlagReportResource {
    export enum ResolutionEnum {
        Banned = <any> 'banned',
        Ignored = <any> 'ignored'
    }
}
export class FlagResource {
    /**
    * The context of that resource
    */
    'context': string;
    /**
    * The context_id of that resource
    */
    'contextId': string;
    /**
    * The date/time this resource was created in seconds since epoch
    */
    'createdDate': number;
    /**
    * The unique ID for that resource
    */
    'id': number;
    /**
    * The flag reason of that resource
    */
    'reason': string;
    /**
    * The date/time this resource was last updated in seconds since epoch
    */
    'updatedDate': number;
    /**
    * The basic user resource
    */
    'user': SimpleUserResource;
}

export class ForwardLog {
    /**
    * The end date of the forward log entry
    */
    'endDate': number;
    'errorMsg': string;
    /**
    * The http status code the forward log entry
    */
    'httpStatusCode': number;
    /**
    * The id of the forward log entry
    */
    'id': string;
    /**
    * The payload of the forward log entry
    */
    'payload': any;
    /**
    * The response string of the forward log entry
    */
    'response': string;
    /**
    * The retry count of the forward log entry
    */
    'retryCount': number;
    /**
    * The start date of the forward log entry
    */
    'startDate': number;
    /**
    * The endpoint url of the forward log entry
    */
    'url': string;
}

export class FulfillmentType {
    /**
    * Whether the type is core and cannot be altered/deleted, read-only
    */
    'core': boolean;
    /**
    * A description of the type
    */
    'description': string;
    /**
    * The unique id of the type, read-only
    */
    'id': number;
    /**
    * The name of the type
    */
    'name': string;
}

export class GooglePaymentRequest {
    /**
    * The json payload exactly as sent from Google
    */
    'jsonPayload': string;
    /**
    * The signature from Google to verify the payload
    */
    'signature': string;
}

export class GrantTypeResource {
    /**
    * The description of the grant type
    */
    'description': string;
    /**
    * The name of the grant type
    */
    'name': string;
}

export class Group {
    'additionalProperties': { [key: string]: Property; };
    'description': string;
    'id': number;
    'memberCount': number;
    'messageOfTheDay': string;
    'name': string;
    'parent': Group;
    'propertiesString': string;
    'status': Group.StatusEnum;
    'subMemberCount': number;
    'template': string;
    'uniqueName': string;
}

export namespace Group {
    export enum StatusEnum {
        Open = <any> 'open',
        Closed = <any> 'closed'
    }
}
export class GroupMember {
    'group': Group;
    'secondary': boolean;
    'status': GroupMember.StatusEnum;
    'user': User;
}

export namespace GroupMember {
    export enum StatusEnum {
        Moderator = <any> 'moderator',
        Member = <any> 'member'
    }
}
export class GroupMemberResource {
    /**
    * The url of the user's avatar image
    */
    'avatarUrl': string;
    /**
    * The public username of the user
    */
    'displayName': string;
    /**
    * The id of the user
    */
    'id': number;
    /**
    * The member's access level. Default: member
    */
    'status': GroupMemberResource.StatusEnum;
    /**
    * The username of the user
    */
    'username': string;
}

export namespace GroupMemberResource {
    export enum StatusEnum {
        Moderator = <any> 'moderator',
        Member = <any> 'member'
    }
}
export class GroupResource {
    /**
    * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * A description of the group. Max 250 characters
    */
    'description': string;
    /**
    * The number of users in the group
    */
    'memberCount': number;
    /**
    * A message of the day for members of the group
    */
    'messageOfTheDay': string;
    /**
    * The name of the group. Max 50 characters
    */
    'name': string;
    /**
    * The unique name of another group that this group is a subset of
    */
    'parent': string;
    /**
    * The status which describes whether other users can freely join the group or not
    */
    'status': GroupResource.StatusEnum;
    /**
    * The number of users in child groups
    */
    'subMemberCount': number;
    /**
    * A group template this group is validated against. May be null and no validation of additional_properties will be done
    */
    'template': string;
    /**
    * Unique name used in url and references. Uppercase, lowercase, numbers and hyphens only. Max 50 characters. Cannot be altered once created
    */
    'uniqueName': string;
}

export namespace GroupResource {
    export enum StatusEnum {
        Open = <any> 'open',
        Closed = <any> 'closed'
    }
}
export class ImportJobOutputResource {
    /**
    * The description of the import job
    */
    'description': string;
    /**
    * The line number of the import job
    */
    'lineNumber': number;
}

export class ImportJobResource {
    /**
    * The id of the category to assign all questions in the import to
    */
    'categoryId': string;
    /**
    * The date the job was created in seconds since unix epoc
    */
    'createdDate': number;
    /**
    * The id of the job
    */
    'id': number;
    /**
    * A name for this import for later reference
    */
    'name': string;
    /**
    * Error information from validation
    */
    'output': Array<ImportJobOutputResource>;
    /**
    * The number of questions form the CSV file. Filled in after validation
    */
    'recordCount': number;
    /**
    * The status of the job
    */
    'status': ImportJobResource.StatusEnum;
    /**
    * The date the job was last updated in seconds since unix epoc
    */
    'updatedDate': number;
    /**
    * The url of a CSV file to pull trivia questions from. Cannot be changed after initial POST
    */
    'url': string;
    /**
    * The vendor who supplied this set of questions
    */
    'vendor': string;
}

export namespace ImportJobResource {
    export enum StatusEnum {
        PENDINGVALIDATION = <any> 'PENDING_VALIDATION',
        VALIDATING = <any> 'VALIDATING',
        VALID = <any> 'VALID',
        INVALID = <any> 'INVALID',
        PENDINGPROCESS = <any> 'PENDING_PROCESS',
        PROCESSING = <any> 'PROCESSING',
        PROCESSED = <any> 'PROCESSED',
        FAILED = <any> 'FAILED'
    }
}
export class InventorySubscriptionResource {
    /**
    * The date the subscription will be billed
    */
    'billDate': number;
    /**
    * A credit of money already applied to a subscription for the next bill, or a debt if negative
    */
    'credit': number;
    /**
    * A record of past and present credit/debt changes
    */
    'creditLog': Array<SubscriptionCreditResource>;
    /**
    * The date the grace period ends
    */
    'graceEnd': number;
    /**
    * The id of the inventory
    */
    'inventoryId': number;
    /**
    * The inventory status object
    */
    'inventoryStatus': InventorySubscriptionResource.InventoryStatusEnum;
    /**
    * The id of the item
    */
    'itemId': number;
    /**
    * The payment method object
    */
    'paymentMethod': PaymentMethodResource;
    /**
    * The recurring price
    */
    'recurringPrice': number;
    /**
    * The sku of the subscription
    */
    'sku': string;
    /**
    * The date the subscription will start
    */
    'startDate': number;
    /**
    * The status of the subscription
    */
    'subscriptionStatus': number;
    /**
    * The user
    */
    'user': SimpleUserResource;
}

export namespace InventorySubscriptionResource {
    export enum InventoryStatusEnum {
        Pending = <any> 'pending',
        Active = <any> 'active',
        Inactive = <any> 'inactive'
    }
}
export class InvoiceCreateRequest {
    /**
    * The guid of a cart to create a new invoice for
    */
    'cartGuid': string;
}

export class InvoiceItemResource {
    'affiliateId': number;
    'bundleSku': string;
    'currentFulfillmentStatus': string;
    'id': number;
    'invoiceId': number;
    'itemId': number;
    'itemName': string;
    'originalTotalPrice': number;
    'originalUnitPrice': number;
    'qty': number;
    'saleName': string;
    'sku': string;
    'skuDescription': string;
    'systemPrice': number;
    'totalPrice': number;
    'typeHint': string;
    'unitPrice': number;
}

export class InvoiceLogEntry {
    /**
    * The date this event occured as a unix timestamp in seconds
    */
    'date': number;
    /**
    * The ID of the invoice
    */
    'invoiceId': number;
    /**
    * A message describing the event
    */
    'message': string;
    /**
    * The type of event
    */
    'type': string;
}

export class InvoicePaymentStatusRequest {
    /**
    * If included, will set the payment method used on the invoice
    */
    'paymentMethodId': number;
    /**
    * The new status for the invoice. Additional options may be available based on configuration.  Allowable values: 'new', 'paid', 'hold', 'canceled', 'payment failed', 'partial refund', 'refund'
    */
    'status': string;
}

export class InvoiceResource {
    /**
    * Line one of the customer's billing address
    */
    'billingAddress1': string;
    /**
    * Line two of the customer's billing address
    */
    'billingAddress2': string;
    /**
    * The city for the customer's billing address
    */
    'billingCityName': string;
    /**
    * The country for the customer's billing address
    */
    'billingCountryName': string;
    /**
    * The customer's name for the billing address
    */
    'billingFullName': string;
    /**
    * The postal code for the customer's billing address
    */
    'billingPostalCode': string;
    /**
    * The state for the customer's billing address
    */
    'billingStateName': string;
    /**
    * The guid of the cart this invoice came from
    */
    'cartId': string;
    /**
    * The date the invoice was created, unix timestamp in seconds
    */
    'createdDate': number;
    /**
    * The code for the currency invoice prices are in
    */
    'currency': string;
    /**
    * The fulfillment status of the invoice
    */
    'currentFulfillmentStatus': string;
    /**
    * The payment status of the invoice
    */
    'currentPaymentStatus': string;
    /**
    * The amount of money saved through coupons
    */
    'discount': number;
    /**
    * The customer's email address
    */
    'email': string;
    /**
    * The amount of federal tax added
    */
    'fedTax': number;
    /**
    * The final price of the invoice
    */
    'grandTotal': number;
    /**
    * The id of the invoice
    */
    'id': number;
    /**
    * A reference number for the invoice
    */
    'invoiceNumber': string;
    /**
    * A list of items within the invoice
    */
    'items': Array<InvoiceItemResource>;
    /**
    * The customer's name prefix
    */
    'namePrefix': string;
    /**
    * Notes about the order
    */
    'orderNotes': string;
    /**
    * The id of an invoice this is a child of
    */
    'parentInvoiceId': number;
    /**
    * The id of a saved payment method used to pay for the invoice
    */
    'paymentMethodId': number;
    /**
    * The customer's phone number
    */
    'phone': string;
    /**
    * The customer's phone number
    */
    'phoneNumber': string;
    /**
    * The shipping cost
    */
    'shipping': number;
    /**
    * Line one of the customer's shipping address
    */
    'shippingAddress1': string;
    /**
    * Line two of the customer's shipping address
    */
    'shippingAddress2': string;
    /**
    * The city for the customer's shipping address
    */
    'shippingCityName': string;
    /**
    * The country for the customer's shipping address
    */
    'shippingCountryName': string;
    /**
    * The customer's name for the shipping address
    */
    'shippingFullName': string;
    /**
    * The postal code for the customer's shipping address
    */
    'shippingPostalCode': string;
    /**
    * The state for the customer's shipping address
    */
    'shippingStateName': string;
    /**
    * A number to use in sorting items. default 500.
    */
    'sort': number;
    /**
    * The amount of state tax added
    */
    'stateTax': number;
    /**
    * The sum price of all items before shipping, coupons and tax
    */
    'subtotal': number;
    /**
    * The date the invoice was last updated, unix timestamp in seconds
    */
    'updatedDate': number;
    /**
    * The owner of the invoice
    */
    'user': SimpleUserResource;
    /**
    * The id of the vendor
    */
    'vendorId': number;
    /**
    * The name of the invoice
    */
    'vendorName': string;
}

export class ItemBehaviorDefinitionResource {
    /**
    * The default version of the behavior
    */
    'behavior': Behavior;
    /**
    * Whether the behavior's values can be modified
    */
    'modifiable': boolean;
    /**
    * Whether the behavior can be removed
    */
    'required': boolean;
}

export class ItemTemplateResource {
    /**
    * The customized behaviors that are required or default for this type of item
    */
    'behaviors': Array<ItemBehaviorDefinitionResource>;
    /**
    * The date/time this resource was created in seconds since unix epoch
    */
    'createdDate': number;
    /**
    * The id of the template
    */
    'id': string;
    /**
    * The name of the template
    */
    'name': string;
    /**
    * The customized properties that are present
    */
    'properties': Array<PropertyDefinitionResource>;
    /**
    * The date/time this resource was last updated in seconds since unix epoch
    */
    'updatedDate': number;
}

export class KeyValuePairstringstring {
    'key': string;
    'value': string;
}

export class Language {
    'code': string;
    'dateCreated': number;
    'dateUpdated': number;
    'description': string;
    'direction': string;
    'id': number;
    'isPrimary': boolean;
    'name': string;
}

export class LeaderboardEntryResource {
    /**
    * The position of the user in the leaderboard. Null means non-compete or disqualification
    */
    'rank': number;
    /**
    * The raw score in this leaderboard. Null means non-compete or disqualification
    */
    'score': number;
    /**
    * The player for this entry
    */
    'user': SimpleUserResource;
}

export class LeaderboardResource {
    /**
    * The paginated list of user results, in order from best to worst
    */
    'entries': Array<LeaderboardEntryResource>;
    /**
    * The id of the leaderboard
    */
    'id': number;
    /**
    * The name of the strategy that defines how entries are stored and compared
    */
    'strategy': string;
}

export class LevelingResource {
    /**
    * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * The date the leveling schema was created
    */
    'createdDate': number;
    /**
    * The description of the leveling schema
    */
    'description': string;
    /**
    * The name of the leveling schema.  IMMUTABLE
    */
    'name': string;
    /**
    * A set of tiers that contain experience boundaries
    */
    'tiers': Array<TierResource>;
    /**
    * The date the leveling schema was updated
    */
    'updatedDate': number;
}

export class Localizer {
}

export class LocationLogResource {
    'country': string;
    'ip': string;
    'time': number;
}

export class LookupTypeResource {
    /**
    * The description of the expression type
    */
    'description': string;
    /**
    * The variable type the key expression must be, or null if it's dependent (see description for explanation in this case)
    */
    'keyType': string;
    /**
    * The name of the expression type
    */
    'name': string;
    /**
    * The variable type of the value this expression returns, or null if it's dependent (see description for explanation in this case)
    */
    'valueType': string;
}

export class Maintenance {
    /**
    * Whether access to the system has been locked
    */
    'accessLocked': boolean;
    /**
    * A simple object of any schema for client side use and processing
    */
    'details': any;
    /**
    * User displayable message about the maintenance
    */
    'message': string;
}

export class Mapstringobject extends null<String, any> {
}

export class MetricResource {
    /**
    * The id of the activity occurence where this score/metric occured
    */
    'activityOccurenceId': number;
    /**
    * Any tags for the metric. Each unique tag will translate into a unique leaderboard. Maximum 5 tags and 50 characters each
    */
    'tags': Array<string>;
    /**
    * The value/score of the metric
    */
    'value': number;
}

export class NestedCategory {
    /**
    * Whether the category is active
    */
    'active': boolean;
    /**
    * The id of the category
    */
    'id': string;
    /**
    * The name of the category
    */
    'name': string;
}

export class NewPasswordRequest {
    /**
    * The new password in plain text
    */
    'password': string;
    /**
    * The secret provided after the password reset
    */
    'secret': string;
}

export class OauthAccessTokenResource {
    /**
    * The key of the client assosciated with the token
    */
    'clientId': string;
    /**
    * The token.  Not shown in list view
    */
    'token': string;
    /**
    * The username of the user associated with the token
    */
    'username': string;
}

export class Operator {
}

export class OptimalPaymentRequest {
    /**
    * The email address of the user
    */
    'email': string;
    /**
    * The first name of the user
    */
    'firstName': string;
    /**
    * The id of the invoice to pay
    */
    'invoiceId': number;
    /**
    * The last name of the user
    */
    'lastName': string;
    /**
    * The url to redirect the user to after declining payment
    */
    'onDecline': string;
    /**
    * The url to redirect the user to after an error in payment
    */
    'onError': string;
    /**
    * The url to redirect the user to after successful payment
    */
    'onSuccess': string;
}

export class Order {
    'ascending': boolean;
    'direction': Order.DirectionEnum;
    'ignoreCase': boolean;
    'nullHandling': Order.NullHandlingEnum;
    'property': string;
}

export namespace Order {
    export enum DirectionEnum {
        ASC = <any> 'ASC',
        DESC = <any> 'DESC'
    }
    export enum NullHandlingEnum {
        NATIVE = <any> 'NATIVE',
        NULLSFIRST = <any> 'NULLS_FIRST',
        NULLSLAST = <any> 'NULLS_LAST'
    }
}
export class PageResourceAchievementDefinitionResource {
    'content': Array<AchievementDefinitionResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceAggregateCountResource {
    'content': Array<AggregateCountResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceAggregateInvoiceReportResource {
    'content': Array<AggregateInvoiceReportResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceArticleResource {
    'content': Array<ArticleResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceArtistResource {
    'content': Array<ArtistResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceBareActivityResource {
    'content': Array<BareActivityResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceBareChallengeActivityResource {
    'content': Array<BareChallengeActivityResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceBillingReport {
    'content': Array<BillingReport>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceBreCategoryResource {
    'content': Array<BreCategoryResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceBreEventLog {
    'content': Array<BreEventLog>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceBreGlobalResource {
    'content': Array<BreGlobalResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceBreRule {
    'content': Array<BreRule>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceBreTriggerResource {
    'content': Array<BreTriggerResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceCampaignResource {
    'content': Array<CampaignResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceCartSummary {
    'content': Array<CartSummary>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceCatalogSale {
    'content': Array<CatalogSale>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceCategoryResource {
    'content': Array<CategoryResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceChallengeEventParticipantResource {
    'content': Array<ChallengeEventParticipantResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceChallengeEventResource {
    'content': Array<ChallengeEventResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceChallengeResource {
    'content': Array<ChallengeResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceClientResource {
    'content': Array<ClientResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceCommentResource {
    'content': Array<CommentResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceConfig {
    'content': Array<Config>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceCountryTaxResource {
    'content': Array<CountryTaxResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceCurrencyResource {
    'content': Array<CurrencyResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceDeviceResource {
    'content': Array<DeviceResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceDispositionResource {
    'content': Array<DispositionResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceEntitlementItem {
    'content': Array<EntitlementItem>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceFlagReportResource {
    'content': Array<FlagReportResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceForwardLog {
    'content': Array<ForwardLog>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceFulfillmentType {
    'content': Array<FulfillmentType>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceGroupMemberResource {
    'content': Array<GroupMemberResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceGroupResource {
    'content': Array<GroupResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceImportJobResource {
    'content': Array<ImportJobResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceInvoiceLogEntry {
    'content': Array<InvoiceLogEntry>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceInvoiceResource {
    'content': Array<InvoiceResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceItemTemplateResource {
    'content': Array<ItemTemplateResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceLevelingResource {
    'content': Array<LevelingResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceLocationLogResource {
    'content': Array<LocationLogResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceMapstringobject {
    'content': Array<Mapstringobject>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceOauthAccessTokenResource {
    'content': Array<OauthAccessTokenResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourcePermissionResource {
    'content': Array<PermissionResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourcePollResource {
    'content': Array<PollResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceQuestionResource {
    'content': Array<QuestionResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceQuestionTemplateResource {
    'content': Array<QuestionTemplateResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceRevenueCountryReportResource {
    'content': Array<RevenueCountryReportResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceRevenueProductReportResource {
    'content': Array<RevenueProductReportResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceRewardSetResource {
    'content': Array<RewardSetResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceRoleResource {
    'content': Array<RoleResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceSavedAddressResource {
    'content': Array<SavedAddressResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceSimpleUserResource {
    'content': Array<SimpleUserResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceSimpleWallet {
    'content': Array<SimpleWallet>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceStateTaxResource {
    'content': Array<StateTaxResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceStoreItem {
    'content': Array<StoreItem>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceStoreItemTemplateResource {
    'content': Array<StoreItemTemplateResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceSubscriptionResource {
    'content': Array<SubscriptionResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceSubscriptionTemplateResource {
    'content': Array<SubscriptionTemplateResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceTemplateResource {
    'content': Array<TemplateResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceTransactionResource {
    'content': Array<TransactionResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceUsageInfo {
    'content': Array<UsageInfo>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceUserAchievementGroupResource {
    'content': Array<UserAchievementGroupResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceUserActionLog {
    'content': Array<UserActionLog>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceUserBaseResource {
    'content': Array<UserBaseResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceUserInventoryResource {
    'content': Array<UserInventoryResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceUserItemLogResource {
    'content': Array<UserItemLogResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceUserLevelingResource {
    'content': Array<UserLevelingResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceUserRelationshipResource {
    'content': Array<UserRelationshipResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceVendorResource {
    'content': Array<VendorResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceVideoRelationshipResource {
    'content': Array<VideoRelationshipResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceVideoResource {
    'content': Array<VideoResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceWalletTotalResponse {
    'content': Array<WalletTotalResponse>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourceWalletTransactionResource {
    'content': Array<WalletTransactionResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PageResourcestring {
    'content': Array<string>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;
}

export class PayBySavedMethodRequest {
    /**
    * The id of the payment method to use. Must belong to the caller, be public or have PAYMENTS_ADMIN permission
    */
    'paymentMethod': number;
}

export class PaymentAuthorizationResource {
    /**
    * Whether this authorization has been captured
    */
    'captured': boolean;
    /**
    * The date this authorization was received, unix timestamp in seconds
    */
    'created': number;
    /**
    * The details for this authorization. Format dependent on payment provider
    */
    'details': any;
    /**
    * The id of the authorization
    */
    'id': number;
    /**
    * The invoice this authorization is intended to pay
    */
    'invoice': number;
    /**
    * The payment type (which provider) this payment is through
    */
    'paymentType': SimpleReferenceResourceint;
}

export class PaymentMethodResource {
    /**
    * The date/time this resource was created in seconds since unix epoch
    */
    'createdDate': number;
    'default': boolean;
    /**
    * Whether this payment method is disabled or not
    */
    'disabled': boolean;
    /**
    * The expiration date for the payment method, expressed as seconds since epoch. Typically used for credit card payment methods
    */
    'expirationDate': number;
    /**
    * The expiration month (1 - 12) for the payment method. Typically used for credit card payment methods
    */
    'expirationMonth': number;
    /**
    * The expiration year for the payment method. Typically used for credit card payment methods
    */
    'expirationYear': number;
    /**
    * The unique ID for that resource
    */
    'id': number;
    /**
    * The last 4 digits of the account number for the payment method. Typically used for credit card payment methods
    */
    'last4': string;
    /**
    * The user friendly name of that resource. Defaults to blank string
    */
    'longDescription': string;
    /**
    * The user friendly name of that resource
    */
    'name': string;
    /**
    * The type of payment method. Must be a pre-existing value
    */
    'paymentMethodType': PaymentMethodTypeResource;
    /**
    * The generic payment type. Default is card
    */
    'paymentType': PaymentMethodResource.PaymentTypeEnum;
    /**
    * The user friendly name of that resource. Defaults to blank string
    */
    'shortDescription': string;
    /**
    * The sort value for the payment method
    */
    'sort': number;
    /**
    * The unique token for the payment method
    */
    'token': string;
    /**
    * An optional unique identifier
    */
    'uniqueKey': string;
    /**
    * The date/time this resource was last updated in seconds since unix epoch
    */
    'updatedDate': number;
    /**
    * The user's id. If null, indicates a shared payment method that any user can use (i.e., 'wallet')
    */
    'userId': number;
    'verified': boolean;
}

export namespace PaymentMethodResource {
    export enum PaymentTypeEnum {
        Card = <any> 'card',
        BankAccount = <any> 'bank_account'
    }
}
export class PaymentMethodTypeResource {
    /**
    * The id of the payment method type
    */
    'id': number;
    /**
    * The name of the payment method type
    */
    'name': string;
}

export class Permission {
    'createdDate': number;
    'description': string;
    'id': number;
    'locked': boolean;
    'name': string;
    'parent': string;
    'permission': string;
    'permissionRole': Array<Role>;
    'updatedDate': number;
}

export class PermissionResource {
    /**
    * The date the permission was added. Unix timestamp in seconds
    */
    'createdDate': number;
    /**
    * The description of the permission
    */
    'description': string;
    /**
    * Whether a permission is locked from being deleted
    */
    'locked': boolean;
    /**
    * The name of the permission used for display purposes
    */
    'name': string;
    /**
    * The name of the parent of the permission
    */
    'parent': string;
    /**
    * The keyword that defines the permission
    */
    'permission': string;
    /**
    * The date the permission was updated. Unix timestamp in seconds
    */
    'updatedDate': number;
}

export class PollAnswerResource {
    /**
    * The number of uesrs that selected this answer
    */
    'count': number;
    /**
    * The key to the answer (for code reference)
    */
    'key': string;
    /**
    * The text of the answer (for user display)
    */
    'text': string;
}

export class PollResource {
    /**
    * Whether the poll is active
    */
    'active': boolean;
    /**
    * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * The answers to the poll
    */
    'answers': Array<PollAnswerResource>;
    /**
    * The category for the poll
    */
    'category': NestedCategory;
    /**
    * The date/time this resource was created in seconds since unix epoch
    */
    'createdDate': number;
    /**
    * The id of the poll
    */
    'id': string;
    /**
    * The tags for the poll
    */
    'tags': Array<string>;
    /**
    * A poll template this poll is validated against (private). May be null and no validation of additional_properties will be done
    */
    'template': string;
    /**
    * The text of the poll
    */
    'text': string;
    /**
    * The media type of the poll
    */
    'type': PollResource.TypeEnum;
    /**
    * The date/time this resource was last updated in seconds since unix epoch
    */
    'updatedDate': number;
}

export namespace PollResource {
    export enum TypeEnum {
        TEXT = <any> 'TEXT',
        IMAGE = <any> 'IMAGE',
        VIDEO = <any> 'VIDEO',
        AUDIO = <any> 'AUDIO'
    }
}
export class PollResponseResource {
    /**
    * The answer to the poll
    */
    'answer': string;
    /**
    * The date the poll was answered, in seconds since unix epoc
    */
    'answeredDate': number;
    /**
    * The id of the poll response
    */
    'id': string;
    /**
    * The id of the poll
    */
    'pollId': string;
    /**
    * The user
    */
    'user': SimpleUserResource;
}

export class PredicateOperation {
    'args': Array<Expressionobject>;
    'operator': Operator;
}

export class Property {
    /**
    * The type of the property. Used for polymorphic type recognition and thus must match an expected type with additional properties.
    */
    'type': string;
}

export class PropertyDefinitionResource {
    /**
    * The name of the property
    */
    'name': string;
    /**
    * Whether the property is required
    */
    'required': boolean;
    /**
    * The type of the property. Used for polymorphic type recognition and thus must match an expected type with additional properties.
    */
    'type': string;
}

export class QuestionResource {
    /**
    * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * The list of available answers
    */
    'answers': Array<AnswerResource>;
    /**
    * The category for the question
    */
    'category': NestedCategory;
    /**
    * The date/time this resource was created in seconds since unix epoch
    */
    'createdDate': number;
    /**
    * The difficulty of the question
    */
    'difficulty': number;
    /**
    * The unique ID for that resource
    */
    'id': string;
    /**
    * The id of the import job that created the question, or null if not from an import
    */
    'importId': number;
    /**
    * When the question becomes available, null for never, in seconds since epoch
    */
    'publishedDate': number;
    /**
    * The question. Different 'type' values indicate different structures as the question may be test, image, etc. See information on additional properties for the list and their structures
    */
    'question': Property;
    /**
    * The first source of the question
    */
    'source1': string;
    /**
    * The second source of the question
    */
    'source2': string;
    /**
    * The list of tags
    */
    'tags': Array<string>;
    /**
    * A question template this question is validated against (private). May be null and no validation of additional_properties will be done
    */
    'template': string;
    /**
    * The date/time this resource was last updated in seconds since unix epoch
    */
    'updatedDate': number;
    /**
    * The supplier of the question
    */
    'vendor': string;
}

export class QuestionTemplateResource {
    /**
    * A property definition for all answers. If included each answer must match this definition's type and be valid
    */
    'answerProperty': PropertyDefinitionResource;
    /**
    * The date/time this resource was created in seconds since unix epoch
    */
    'createdDate': number;
    /**
    * The id of the template
    */
    'id': string;
    /**
    * The name of the template
    */
    'name': string;
    /**
    * The customized properties that are present
    */
    'properties': Array<PropertyDefinitionResource>;
    /**
    * A property definition for the question itself. If included the answer must match this definition's type and be valid
    */
    'questionProperty': PropertyDefinitionResource;
    /**
    * The date/time this resource was last updated in seconds since unix epoch
    */
    'updatedDate': number;
}

export class RawEmailResource {
    /**
    * The body of the outgoing message.
    */
    'body': string;
    /**
    * Address to attribute the outgoing message to. Optional if the config email.out_address is set.
    */
    'from': string;
    /**
    * Whether the body is to be treated as html. Default false.
    */
    'html': boolean;
    /**
    * A list of user ids to send the message to.
    */
    'recipients': Array<number>;
    /**
    * The subject of the outgoing message.
    */
    'subject': string;
}

export class RawSMSResource {
    /**
    * The phone number to attribute the outgoing message to. Optional if the config text.out_number is set.
    */
    'from': string;
    /**
    * A list of user ids to send the message to.
    */
    'recipients': Array<number>;
    /**
    * The body of the outgoing text message.
    */
    'text': string;
}

export class ReactivateSubscriptionRequest {
    /**
    * The inventory to reactivate. Only required if using the deprecated subscriptions service
    */
    'inventoryId': number;
    /**
    * Whether to add the additional reactivation fee in addition to the recurring fee
    */
    'reactivationFee': boolean;
}

export class RefundRequest {
    /**
    * The amount to refund. If left off, will refund the remaining balance of the transaction or specific item balance (if SKU provided), whichever is less.
    */
    'amount': number;
    /**
    * Notes about or reason for the refund
    */
    'notes': string;
    /**
    * The SKU of a specific item from the invoice to refund. Affects the maximum refund amount (not to exceed the price of this item times quantity on invoice). Transaction must be tied to an invoice if used.
    */
    'sku': string;
}

export class RefundResource {
    /**
    * The amount refunded
    */
    'amount': number;
    /**
    * The id of the refund transaction
    */
    'refundTransactionId': number;
    /**
    * The id of the original transaction
    */
    'transactionId': number;
}

export class Result {
    'code': number;
    'requestId': string;
    'result': any;
}

export class RevenueCountryReportResource {
    'country': string;
    'revenue': number;
    'volume': number;
}

export class RevenueProductReportResource {
    'itemId': number;
    'itemName': string;
    'revenue': number;
    'volume': number;
}

export class RevenueReportResource {
    'customerCount': number;
    'saleCount': number;
    'salesAverage': number;
    'salesTotal': number;
}

export class RewardCurrencyResource {
    /**
    * The code of the currency type to give
    */
    'currencyCode': string;
    /**
    * The name of the currency reward to give.  Set by currency_code)
    */
    'currencyName': string;
    /**
    * The highest number (worst) rank to give the reward to. Must be greater than or equal to minRank
    */
    'maxRank': number;
    /**
    * The lowest number (best) rank to give the reward to. Must be greater than zero
    */
    'minRank': number;
    /**
    * True if the value is actually a percentage of the intake
    */
    'percent': boolean;
    /**
    * The amount of currency to give. For percentage values, 0.5 is 50%
    */
    'value': number;
}

export class RewardItemResource {
    /**
    * The id of the item to reward
    */
    'itemId': number;
    /**
    * The name of the item to reward (read only, set by id)
    */
    'itemName': string;
    /**
    * The highest number (worst) rank to give the reward to. Must be greater than or equal to minRank
    */
    'maxRank': number;
    /**
    * The lowest number (best) rank to give the reward to. Must be greater than zero
    */
    'minRank': number;
    /**
    * How many copies to give
    */
    'quantity': number;
}

export class RewardSetResource {
    /**
    * The date/time this resource was created in seconds since unix epoch
    */
    'createdDate': number;
    /**
    * The currency to give as rewards
    */
    'currencyRewards': Array<RewardCurrencyResource>;
    /**
    * The assigned unique ID for this reward set
    */
    'id': number;
    /**
    * The items to give as rewards
    */
    'itemRewards': Array<RewardItemResource>;
    /**
    * A longer describe the reward set, usually included in details
    */
    'longDescription': string;
    /**
    * The maximum placing that will receive a reward
    */
    'maxPlacing': number;
    /**
    * The user friendly name for this reward set
    */
    'name': string;
    /**
    * A short paragraph to describe the reward set, usually included in listings.  Max 255 characters
    */
    'shortDescription': string;
    /**
    * A provided unique key for this reward set
    */
    'uniqueKey': string;
    /**
    * The date/time this resource was last updated in seconds since unix epoch
    */
    'updatedDate': number;
}

export class Role {
    'clientCount': number;
    'createdDate': number;
    'id': number;
    'locked': boolean;
    'name': string;
    'role': string;
    'rolePermission': Array<Permission>;
    'userCount': number;
}

export class RoleResource {
    /**
    * The number of clients this role is assigned to
    */
    'clientCount': number;
    /**
    * The date the role was added. Unix timestamp in seconds
    */
    'createdDate': number;
    /**
    * Whether a role is locked from being deleted
    */
    'locked': boolean;
    /**
    * The name of the role used for display purposes
    */
    'name': string;
    /**
    * The keyword that defines the role
    */
    'role': string;
    /**
    * The list of permissions this role has
    */
    'rolePermission': Array<PermissionResource>;
    /**
    * The number of users this role is assigned to
    */
    'userCount': number;
}

export class SampleCountriesResponse {
    'vendorId1': Array<Country>;
    'vendorId2': Array<Country>;
}

export class SavedAddressResource {
    /**
    * The first line of the address
    */
    'address1': string;
    /**
    * A second line of the address
    */
    'address2': string;
    /**
    * The city
    */
    'city': string;
    /**
    * The iso3 code for the country
    */
    'countryCode': string;
    'default': boolean;
    /**
    * The first name of the user
    */
    'firstName': string;
    /**
    * The id of the address
    */
    'id': number;
    /**
    * The last name of the user
    */
    'lastName': string;
    /**
    * The name of the address
    */
    'name': string;
    /**
    * The first phone number of the user
    */
    'phone1': string;
    /**
    * The second phone number of the user
    */
    'phone2': string;
    /**
    * The postal code
    */
    'postalCode': string;
    /**
    * The code for the state. Required if the country has states/provinces/equivalent
    */
    'stateCode': string;
}

export class Schedule {
    /**
    * The duration of the repeatable events
    */
    'duration': number;
    /**
    * The unit of time for the duration field
    */
    'durationUnit': Schedule.DurationUnitEnum;
    /**
    * How often the event is scheduled
    */
    'repeat': Schedule.RepeatEnum;
}

export namespace Schedule {
    export enum DurationUnitEnum {
        Millisecond = <any> 'millisecond',
        Second = <any> 'second',
        Minute = <any> 'minute',
        Hour = <any> 'hour',
        Day = <any> 'day',
        Week = <any> 'week',
        Month = <any> 'month',
        Year = <any> 'year'
    }
    export enum RepeatEnum {
        DAILY = <any> 'DAILY',
        WEEKLY = <any> 'WEEKLY'
    }
}
export class SearchReferenceMapping {
    /**
    * Unique identifier for the mapping to protect against duplicates
    */
    'id': string;
    /**
    * The field within the type that contains the id from the refType
    */
    'refIdField': string;
    /**
    * The index type that the mapping pulls data from
    */
    'refType': string;
    /**
    * A map whose keys are the field names in the refType and values are the field name in the type
    */
    'sourceFieldToDestinationField': { [key: string]: string; };
    /**
    * The index type that the mapping is for
    */
    'type': string;
}

export class SelectedSettingResource {
    /**
    * The unique ID for the setting
    */
    'key': string;
    /**
    * The textual name of the setting
    */
    'keyName': string;
    /**
    * The unique ID for the option
    */
    'value': string;
    /**
    * The textual name of the option
    */
    'valueName': string;
}

export class SettingOption {
    /**
    * The textual name of the option
    */
    'name': string;
    /**
    * The unique ID for the option
    */
    'value': string;
}

export class ShippingItem {
    /**
    * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type, or be an extra not from the template
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * The behaviors linked to the item, describing various options and interactions. May not be included in item lists
    */
    'behaviors': Array<Behavior>;
    /**
    * A category for filtering items
    */
    'category': string;
    /**
    * A unique list of country iso3 codes that allow the shipping option
    */
    'countries': Array<string>;
    /**
    * The date the item was created, unix timestamp in seconds
    */
    'createdDate': number;
    /**
    * Whether or not the item is currently displayable.  Default = true
    */
    'displayable': boolean;
    /**
    * A list of country ID to include in the blacklist/whitelist geo policy
    */
    'geoCountryList': Array<string>;
    /**
    * Whether to use the geo_country_list as a black list or white list for item geographical availability
    */
    'geoPolicyType': ShippingItem.GeoPolicyTypeEnum;
    /**
    * The id of the item
    */
    'id': number;
    /**
    * A long description of the item
    */
    'longDescription': string;
    /**
    * An abstract max value that the values of item's shipping_tier work against to decide whether an order can be fulfilled
    */
    'maxTierTotal': number;
    /**
    * The name of the item
    */
    'name': string;
    /**
    * Provides the abstract shipping needs if this item is physical and can be shipped.  A value of zero means no shipping needed.  Default = 0
    */
    'shippingTier': number;
    /**
    * A short description of the item, max 255 chars
    */
    'shortDescription': string;
    /**
    * The skus for the item. Each defines a unique configuration for the item to be purchased (Large-Blue, Small-Green, etc). These are what is ultimately selected in the store and added to the cart
    */
    'skus': Array<Sku>;
    /**
    * A number to use in sorting items.  Default 500
    */
    'sort': number;
    /**
    * The date the item will leave the store, unix timestamp in seconds.  If set to null, item will never leave the store
    */
    'storeEnd': number;
    /**
    * The date the item will appear in the store, unix timestamp in seconds.  If set to null, item will appear in store immediately
    */
    'storeStart': number;
    /**
    * List of tags used for filtering items
    */
    'tags': Array<string>;
    /**
    * Whether tax should be applied to the shipping price.  Default = false
    */
    'taxable': boolean;
    /**
    * An item template this item is validated against.  May be null and no validation of additional_properties will be done.  Default = null
    */
    'template': string;
    /**
    * The type of the item
    */
    'typeHint': string;
    /**
    * The unique key for the item
    */
    'uniqueKey': string;
    /**
    * The date the item was last updated, unix timestamp in seconds
    */
    'updatedDate': number;
    /**
    * The vendor who provides the item
    */
    'vendorId': number;
}

export namespace ShippingItem {
    export enum GeoPolicyTypeEnum {
        Whitelist = <any> 'whitelist',
        Blacklist = <any> 'blacklist'
    }
}
export class SimpleReferenceResourceint {
    /**
    * The id of the referenced object
    */
    'id': number;
    /**
    * The name of the referenced object
    */
    'name': string;
}

export class SimpleReferenceResourcelong {
    /**
    * The id of the referenced object
    */
    'id': number;
    /**
    * The name of the referenced object
    */
    'name': string;
}

export class SimpleReferenceResourcestring {
    /**
    * The id of the referenced object
    */
    'id': string;
    /**
    * The name of the referenced object
    */
    'name': string;
}

export class SimpleUserResource {
    /**
    * The url of the user's avatar image
    */
    'avatarUrl': string;
    /**
    * The public username of the user
    */
    'displayName': string;
    /**
    * The id of the user
    */
    'id': number;
    /**
    * The username of the user
    */
    'username': string;
}

export class SimpleWallet {
    /**
    * The current balance of the wallet
    */
    'balance': number;
    /**
    * The ISO currency code for the wallet
    */
    'code': string;
    /**
    * The name of the currency stored in the wallet
    */
    'currencyName': string;
    /**
    * The unique ID of the wallet
    */
    'id': number;
    /**
    * The ID of the user to whom the wallet belongs
    */
    'userId': number;
}

export class Sku {
    /**
    * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type, or be an extra not from the template
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * The currency code for the SKU, a three letter string (ISO3)
    */
    'currencyCode': string;
    /**
    * The description of the SKU (Ex: An item comes in multiple sizes/colors, each needing its own unique description)
    */
    'description': string;
    /**
    * The number of SKUs currently in stock
    */
    'inventory': number;
    /**
    * Alerts vendor when SKU inventory drops below this value
    */
    'minInventoryThreshold': number;
    /**
    * The base price before any sale
    */
    'originalPrice': number;
    /**
    * The current price of the SKU with sales, if any. Set original_price for the base
    */
    'price': number;
    /**
    * Whether or not the SKU is currently published
    */
    'published': boolean;
    /**
    * The id of a sale affecting the price, if any
    */
    'saleId': number;
    /**
    * The name of a sale affecting the price, if any
    */
    'saleName': string;
    /**
    * The stock keeping unit (SKU), a unique identifier for a given product.  Max 40 characters
    */
    'sku': string;
    /**
    * The date the sku becomes available, unix timestamp in seconds.  If set to null, sku will become available immediately
    */
    'startDate': number;
    /**
    * The date the sku becomes unavailable, unix timestamp in seconds.  If set to null, sku is always available
    */
    'stopDate': number;
}

export class SkuRequest {
    /**
    * SKU code of the item
    */
    'sku': string;
}

export class StateResource {
    /**
    * The code of the state
    */
    'code': string;
    /**
    * The iso3 of the country this state is in
    */
    'countryCodeIso3': string;
    /**
    * The unique ID for the state
    */
    'id': number;
    /**
    * The name of the state
    */
    'name': string;
}

export class StateTaxResource {
    /**
    * The iso3 code of the country, cannot be changed
    */
    'countryIso3': string;
    /**
    * Whether the state is exempt from paying the country tax
    */
    'federallyExempt': boolean;
    /**
    * The name of the tax
    */
    'name': string;
    /**
    * The tax rate as a percentage to a maximum of two decimal places (1.5 means 1.5%)
    */
    'rate': number;
    /**
    * The code of the state, cannot be changed
    */
    'stateCode': string;
    /**
    * Whether the tax applies to shipping costs
    */
    'taxShipping': boolean;
}

export class StoreItem {
    /**
    * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type, or be an extra not from the template
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * The behaviors linked to the item, describing various options and interactions. May not be included in item lists
    */
    'behaviors': Array<Behavior>;
    /**
    * A category for filtering items
    */
    'category': string;
    /**
    * The date the item was created, unix timestamp in seconds
    */
    'createdDate': number;
    /**
    * Whether or not the item is currently displayable.  Default = true
    */
    'displayable': boolean;
    /**
    * A list of country ID to include in the blacklist/whitelist geo policy
    */
    'geoCountryList': Array<string>;
    /**
    * Whether to use the geo_country_list as a black list or white list for item geographical availability
    */
    'geoPolicyType': StoreItem.GeoPolicyTypeEnum;
    /**
    * The id of the item
    */
    'id': number;
    /**
    * A long description of the item
    */
    'longDescription': string;
    /**
    * The name of the item
    */
    'name': string;
    /**
    * Provides the abstract shipping needs if this item is physical and can be shipped.  A value of zero means no shipping needed.  Default = 0
    */
    'shippingTier': number;
    /**
    * A short description of the item, max 255 chars
    */
    'shortDescription': string;
    /**
    * The skus for the item. Each defines a unique configuration for the item to be purchased (Large-Blue, Small-Green, etc). These are what is ultimately selected in the store and added to the cart
    */
    'skus': Array<Sku>;
    /**
    * A number to use in sorting items.  Default 500
    */
    'sort': number;
    /**
    * The date the item will leave the store, unix timestamp in seconds.  If set to null, item will never leave the store
    */
    'storeEnd': number;
    /**
    * The date the item will appear in the store, unix timestamp in seconds.  If set to null, item will appear in store immediately
    */
    'storeStart': number;
    /**
    * List of tags used for filtering items
    */
    'tags': Array<string>;
    /**
    * An item template this item is validated against.  May be null and no validation of additional_properties will be done.  Default = null
    */
    'template': string;
    /**
    * The type of the item
    */
    'typeHint': string;
    /**
    * The unique key for the item
    */
    'uniqueKey': string;
    /**
    * The date the item was last updated, unix timestamp in seconds
    */
    'updatedDate': number;
    /**
    * The vendor who provides the item
    */
    'vendorId': number;
}

export namespace StoreItem {
    export enum GeoPolicyTypeEnum {
        Whitelist = <any> 'whitelist',
        Blacklist = <any> 'blacklist'
    }
}
export class StoreItemTemplateResource {
    /**
    * The customized behaviors that are required or default for this type of item
    */
    'behaviors': Array<ItemBehaviorDefinitionResource>;
    /**
    * The date/time this resource was created in seconds since unix epoch
    */
    'createdDate': number;
    /**
    * The id of the template
    */
    'id': string;
    /**
    * The name of the template
    */
    'name': string;
    /**
    * The customized properties that are present
    */
    'properties': Array<PropertyDefinitionResource>;
    /**
    * A template to apply to all skus on an item using this template
    */
    'skuTemplate': TemplateResource;
    /**
    * The date/time this resource was last updated in seconds since unix epoch
    */
    'updatedDate': number;
}

export class StripeCreatePaymentMethod {
    /**
    * A token from Stripe to identify payment info to be tied to the customer
    */
    'token': string;
    /**
    * The id of the user, if null the logged in user is used. Admin privilege need to specify other users
    */
    'userId': number;
}

export class StripePaymentRequest {
    /**
    * The id of the invoice to pay
    */
    'invoiceId': number;
    /**
    * A token from Stripe to identify payment info to be tied to the customer
    */
    'token': string;
}

export class SubscriptionCreditResource {
    /**
    * The amount of the credit, negative for debt
    */
    'amount': number;
    /**
    * The date this credit was added, unix timestamp in seconds
    */
    'createdDate': number;
    /**
    * The id of the credit record
    */
    'id': number;
    /**
    * The id of the subscription inventory entry
    */
    'inventoryId': number;
    /**
    * The reason for the subscription credit
    */
    'reason': string;
}

export class SubscriptionPlanResource {
    /**
    * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this subscription
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * The length of the billing cycle in number of billing cycle unit
    */
    'billingCycleLength': number;
    /**
    * The time period unit to apply to the length of billing cycles
    */
    'billingCycleUnit': SubscriptionPlanResource.BillingCycleUnitEnum;
    /**
    * Whether this plan will be renewed on the consolidated billing cycle
    */
    'consolidated': boolean;
    /**
    * The ISO3 currency code to use for the fees
    */
    'currencyCode': string;
    /**
    * Used to schedule plan availability end date
    */
    'endDate': number;
    /**
    * Optional override for the length of the first billing cycle before the first recurring billing
    */
    'firstBillingCycleLength': number;
    /**
    * The time period unit to apply to the length of the first billing cycle. Required when first_billing_cycle_length is specified
    */
    'firstBillingCycleUnit': SubscriptionPlanResource.FirstBillingCycleUnitEnum;
    /**
    * The number of late payment days before a subscription is canceled
    */
    'gracePeriod': number;
    /**
    * The id of the plan used to generate the SKUs
    */
    'id': string;
    /**
    * The fee charged when the subscription is purchased
    */
    'initialFee': number;
    /**
    * The SKU to be used when purchasing the subscription through the cart
    */
    'initialSku': string;
    /**
    * The fee to add to the bill when an invoice has gone unpaid passed the grace period
    */
    'latePaymentFee': number;
    /**
    * The SKU that will show on the invoice when the subscription is delinquent
    */
    'latePaymentSku': string;
    /**
    * Whether this plan is locked because it has been purchased by at least one user.  When locked, a number of properties can no longer be changed
    */
    'locked': boolean;
    /**
    * The number of charge attempts before the subscription becomes delinquent
    */
    'maxBillAttempts': number;
    /**
    * Maximum number of renewals. If a migration plan is provided, the subscription will automatically switch to it when this limit is reached
    */
    'maxCycles': number;
    /**
    * Automatically migrate to the specified plan when the subscription is first renewed
    */
    'migrateToPlan': string;
    /**
    * The minimum number of renewals to charge for
    */
    'minCycles': number;
    /**
    * The name of the plan used to generate the SKUs
    */
    'name': string;
    /**
    * Whether this plan is currently available
    */
    'published': boolean;
    /**
    * The fee to charge when a suspended subscription is to be re-activated
    */
    'reactivationFee': number;
    /**
    * The SKU that will show on the invoice when the subscription is re-activated after a suspension
    */
    'reactivationSku': string;
    /**
    * The recurring fee to charge for each renewal
    */
    'recurringFee': number;
    /**
    * The SKU that will show on the invoice when the subscription is activated
    */
    'recurringSku': string;
    /**
    * Used to schedule plan availability start date
    */
    'startDate': number;
}

export namespace SubscriptionPlanResource {
    export enum BillingCycleUnitEnum {
        Millisecond = <any> 'millisecond',
        Second = <any> 'second',
        Minute = <any> 'minute',
        Hour = <any> 'hour',
        Day = <any> 'day',
        Week = <any> 'week',
        Month = <any> 'month',
        Year = <any> 'year'
    }
    export enum FirstBillingCycleUnitEnum {
        Millisecond = <any> 'millisecond',
        Second = <any> 'second',
        Minute = <any> 'minute',
        Hour = <any> 'hour',
        Day = <any> 'day',
        Week = <any> 'week',
        Month = <any> 'month',
        Year = <any> 'year'
    }
}
export class SubscriptionResource {
    /**
    * A map of item additional properties, keyed on the property name. Must match the names and types defined in the template for this item type.
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * Who can purchase this subscription
    */
    'availability': SubscriptionResource.AvailabilityEnum;
    /**
    * A category for filtering items
    */
    'category': string;
    /**
    * The day of the month 1..31 this subscription will renew
    */
    'consolidationDayOfMonth': number;
    /**
    * The date the item was created, unix timestamp in seconds
    */
    'createdDate': number;
    /**
    * A list of country iso3 codes to include in the blacklist/whitelist geo policy
    */
    'geoCountryList': Array<string>;
    /**
    * Whether to use the geo_country_list as a black list or white list for item geographical availability
    */
    'geoPolicyType': SubscriptionResource.GeoPolicyTypeEnum;
    /**
    * The id of the item
    */
    'id': number;
    /**
    * A long description of the subscription
    */
    'longDescription': string;
    /**
    * The name of the item
    */
    'name': string;
    /**
    * The billing options for this subscription
    */
    'plans': Array<SubscriptionPlanResource>;
    /**
    * A short description of the subscription.  Max 255 characters
    */
    'shortDescription': string;
    /**
    * A number to use in sorting items.  Default 500
    */
    'sort': number;
    /**
    * Used to schedule removal from store.  Null means the subscription will never be removed
    */
    'storeEnd': number;
    /**
    * Used to schedule appearance in store.  Null means the subscription will appear now
    */
    'storeStart': number;
    /**
    * List of tags used for filtering items
    */
    'tags': Array<string>;
    /**
    * An item template this item is validated against. May be null and no validation of additional properties will be done.
    */
    'template': string;
    /**
    * The unique key for the item
    */
    'uniqueKey': string;
    /**
    * The date the item was last updated
    */
    'updatedDate': number;
    /**
    * The vendor who provides the item
    */
    'vendorId': number;
}

export namespace SubscriptionResource {
    export enum AvailabilityEnum {
        All = <any> 'all',
        NewSubscribers = <any> 'new_subscribers'
    }
    export enum GeoPolicyTypeEnum {
        Whitelist = <any> 'whitelist',
        Blacklist = <any> 'blacklist'
    }
}
export class SubscriptionTemplateResource {
    /**
    * The date/time this resource was created in seconds since unix epoch
    */
    'createdDate': number;
    /**
    * The id of the template
    */
    'id': string;
    /**
    * The name of the template
    */
    'name': string;
    /**
    * A template to apply to all plans on a subscription using this template
    */
    'planTemplate': TemplateResource;
    /**
    * The customized properties that are present
    */
    'properties': Array<PropertyDefinitionResource>;
    /**
    * The date/time this resource was last updated in seconds since unix epoch
    */
    'updatedDate': number;
}

export class TemplateEmailResource {
    /**
    * Address to attribute the outgoing message to. Optional if the config email.out_address is set.
    */
    'from': string;
    /**
    * A list of user ids to send the message to.
    */
    'recipients': Array<number>;
    /**
    * The key for the template
    */
    'templateKey': string;
    /**
    * A list of variables to fill in the template
    */
    'templateVars': Array<KeyValuePairstringstring>;
}

export class TemplateResource {
    /**
    * The date/time this resource was created in seconds since unix epoch
    */
    'createdDate': number;
    /**
    * The id of the template
    */
    'id': string;
    /**
    * The name of the template
    */
    'name': string;
    /**
    * The customized properties that are present
    */
    'properties': Array<PropertyDefinitionResource>;
    /**
    * The date/time this resource was last updated in seconds since unix epoch
    */
    'updatedDate': number;
}

export class TemplateSMSResource {
    /**
    * The phone number to attribute the outgoing message to. Optional if the config text.out_number is set.
    */
    'from': string;
    'localizer': Localizer;
    /**
    * A list of user ids to send the message to.
    */
    'recipients': Array<number>;
    /**
    * The key for the template.
    */
    'templateKey': string;
    /**
    * A list of values to fill in the template. Order matters.
    */
    'templateVars': Array<string>;
}

export class TierResource {
    /**
    * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * The name of the tier
    */
    'name': string;
    /**
    * The required progress for the tier
    */
    'requiredProgress': number;
    /**
    * The name of the triggered event
    */
    'triggerEventName': string;
}

export class Timezone {
    'code': string;
    'id': number;
    'name': string;
    'offset': number;
}

export class TokenDetailsResource {
    'roles': Array<string>;
    'userId': number;
}

export class TransactionResource {
    /**
    * The unix timestamp in seconds of the transaction
    */
    'createDate': number;
    /**
    * The code of the currency for the transaction
    */
    'currencyCode': string;
    /**
    * The specific details of the transaction, such as a message from the admin that created it
    */
    'details': string;
    /**
    * The id of the transaction
    */
    'id': number;
    /**
    * The id of the invoice that spawned the transaction, if any
    */
    'invoiceId': number;
    /**
    * Whether the transaction has been refunded
    */
    'isRefunded': boolean;
    /**
    * The response
    */
    'response': string;
    /**
    * The root source of the transaction
    */
    'source': TransactionResource.SourceEnum;
    /**
    * If the transaction was successful
    */
    'successful': boolean;
    /**
    * The payment gateway (external) transaction ID
    */
    'transactionId': string;
    /**
    * The general type of the transaction
    */
    'type': string;
    /**
    * The table name of the subclass
    */
    'typeHint': string;
    /**
    * The amount of the transaction, positive if a gain, negative if an expenditure
    */
    'value': number;
}

export namespace TransactionResource {
    export enum SourceEnum {
        Digital = <any> 'digital',
        Physical = <any> 'physical'
    }
}
export class UsageInfo {
    /**
    * The number of requests within the range
    */
    'count': number;
    /**
    * The date at the start of the range (see granularity)
    */
    'date': number;
    /**
    * The http method
    */
    'method': string;
    /**
    * The url path
    */
    'url': string;
}

export class User {
    'additionalProperties': { [key: string]: Property; };
    'address': string;
    'address2': string;
    'affiliate': Affiliate;
    'avatarUrl': string;
    'children': Array<UserRelationship>;
    'city': string;
    'country': Country;
    'currency': Currency;
    'dateCreated': number;
    'dateOfBirth': number;
    'dateUpdated': number;
    'description': string;
    'displayName': string;
    'email': string;
    'firstName': string;
    'fullname': string;
    'gender': string;
    'groups': Array<GroupMember>;
    'guest': boolean;
    'id': number;
    'inviteToken': string;
    'lang': Language;
    'lastActivity': number;
    'lastLogin': number;
    'lastName': string;
    'lockoutAttempts': number;
    'lockoutDate': number;
    'mobileNumber': string;
    'oldId': number;
    'parents': Array<UserRelationship>;
    'password': string;
    'postalCode': string;
    'propertiesString': string;
    'roles': Array<Role>;
    'state': string;
    'status': string;
    'tagStrings': Array<string>;
    'tags': Array<UserTag>;
    'template': string;
    'timezone': Timezone;
    'token': string;
    'typeHint': string;
    'username': string;
}

export class UserAchievementGroupResource {
    /**
    * The list of achievements associated with the group
    */
    'achievements': Array<UserAchievementResource>;
    /**
    * The name of the group.  If used by Leveling, this will represent the level name
    */
    'groupName': string;
    /**
    * The id of the achievement progress
    */
    'id': string;
    /**
    * The current progress of the user on the group
    */
    'progress': number;
    /**
    * The id of the user whose progress is being tracked
    */
    'userId': number;
}

export class UserAchievementResource {
    /**
    * Flag indicating whether the user has earned the achievement
    */
    'achieved': boolean;
    /**
    * The achievement being tracked.  If used for Leveling, this represents the tier name
    */
    'achievementName': string;
    /**
    * The date/time this resource was created in seconds since unix epoch
    */
    'createdDate': number;
    /**
    * The date/time the achievement was earned as a unix timestamp in seconds
    */
    'earnedDate': number;
    /**
    * The date/time this resource was last updated in seconds since unix epoch
    */
    'updatedDate': number;
}

export class UserActionLog {
    /**
    * A description of the action taken
    */
    'actionDescription': string;
    /**
    * The name of the action taken
    */
    'actionName': string;
    /**
    * The date of the action, unix timestamp in seconds
    */
    'createdDate': number;
    /**
    * A map of additional details such as the target of the action
    */
    'details': { [key: string]: string; };
    /**
    * The id of the log entry
    */
    'id': string;
    /**
    * The id of the api request that spawned the action, if generated internally
    */
    'requestId': string;
    /**
    * The id of the user that took the action, if any. Read-only if not posting with LOGS_ADMIN
    */
    'userId': number;
}

export class UserActivityResultsResource {
    /**
    * Any currency rewarded to this user
    */
    'currencyRewards': Array<RewardCurrencyResource>;
    /**
    * Any items rewarded to this user
    */
    'itemRewards': Array<RewardItemResource>;
    /**
    * The position of the user in the leaderboard. Null means non-compete or disqualification
    */
    'rank': number;
    /**
    * The raw score in this leaderboard. Null means non-compete or disqualification
    */
    'score': number;
    /**
    * Any tags for the metric. Each unique tag will translate into a unique leaderboard. Maximum 5 tags and 50 characters each
    */
    'tags': Array<string>;
    /**
    * The number of users tied at this rank, including this user. 1 means no tie
    */
    'ties': number;
    /**
    * The player for this entry
    */
    'user': SimpleUserResource;
}

export class UserBaseResource {
    /**
    * The url of the user's avatar image
    */
    'avatarUrl': string;
    /**
    * The chosen display name of the user, defaults to username if not present
    */
    'displayName': string;
    /**
    * The user's email address (private). May be required and/or unique depending on system configuration (both on by default). Must match standard email requirements if provided (RFC 2822)
    */
    'email': string;
    /**
    * The user's full name (private)
    */
    'fullname': string;
    /**
    * The id of the user
    */
    'id': number;
    /**
    * The login username for the user (private). May be set to match email if system does not require usernames separately.
    */
    'username': string;
}

export class UserInventoryAddRequest {
    /**
    * A note to be passed to the invoice or transaction
    */
    'note': string;
    /**
    * A list of behaviors to ignore explicitely.  Ex: 'limited_gettable'
    */
    'overrides': Array<string>;
    /**
    * If set to true will cause the endpoint to skip creation of cart and invoice to track the inventory change
    */
    'skipInvoice': boolean;
    /**
    * The specific SKU of the item to be added to the inventory
    */
    'sku': string;
}

export class UserInventoryResource {
    /**
    * A map of data for behaviors
    */
    'behaviorData': any;
    /**
    * The date/time this resource was created in seconds since epoch
    */
    'createdDate': number;
    /**
    * The date/time this resource exires in seconds since epoch. Null for no expiration. For subscriptions, this is the end of the 'grace period' if left unpaid
    */
    'expires': number;
    /**
    * The id of the inventory
    */
    'id': number;
    /**
    * The id of the invoice that resulted in this inventory, if any
    */
    'invoiceId': number;
    /**
    * The id of the item
    */
    'itemId': number;
    /**
    * The name of the item
    */
    'itemName': string;
    /**
    * The type hint of the item
    */
    'itemTypeHint': string;
    /**
    * The status of the inventory. Pending inventory is not yet ready for use. Inactive inventory has expired or been used up
    */
    'status': UserInventoryResource.StatusEnum;
    /**
    * The date/time this resource was last updated in seconds since epoch
    */
    'updatedDate': number;
    /**
    * The id of the user this inventory belongs to
    */
    'user': SimpleUserResource;
}

export namespace UserInventoryResource {
    export enum StatusEnum {
        Pending = <any> 'pending',
        Active = <any> 'active',
        Inactive = <any> 'inactive'
    }
}
export class UserItemLogResource {
    /**
    * The log entry id
    */
    'id': number;
    /**
    * Additional information defined by the type
    */
    'info': string;
    /**
    * The item interacted with
    */
    'item': SimpleReferenceResourceint;
    /**
    * The date/time this event occurred in seconds since epoch
    */
    'logDate': number;
    /**
    * The type of event
    */
    'type': string;
    /**
    * The user making the interaction
    */
    'user': SimpleUserResource;
    /**
    * The id of the inventory entry this event is related to, if any
    */
    'userInventory': number;
}

export class UserLevelingResource {
    /**
    * The name of the last tier the user has qualified for
    */
    'lastTierName': string;
    /**
    * The progress level of the last tier the user has qualified for
    */
    'lastTierProgress': number;
    /**
    * The name of the level schema
    */
    'levelName': string;
    /**
    * The name of the next tier the user can qualify for
    */
    'nextTierName': string;
    /**
    * The progress needed to qualify for the next tier
    */
    'nextTierProgress': number;
    /**
    * The amount of progress the user has
    */
    'progress': number;
    /**
    * The names of the tiers the user has qualified for
    */
    'tierNames': Array<string>;
    /**
    * The ID of the user
    */
    'userId': number;
}

export class UserRelationship {
    'child': User;
    'context': string;
    'id': number;
    'parent': User;
}

export class UserRelationshipReferenceResource {
    /**
    * The url of the user's avatar image
    */
    'avatarUrl': string;
    /**
    * The context of the relationship
    */
    'context': string;
    /**
    * The public username of the user
    */
    'displayName': string;
    /**
    * The id of the user
    */
    'id': number;
    /**
    * The id of the relationship
    */
    'relationshipId': number;
    /**
    * The username of the user
    */
    'username': string;
}

export class UserRelationshipResource {
    /**
    * The child in the relationship
    */
    'child': SimpleUserResource;
    /**
    * Context about the relationship or its type
    */
    'context': string;
    /**
    * A generated unique id. Read-Only
    */
    'id': number;
    /**
    * The parent in the relationship
    */
    'parent': SimpleUserResource;
}

export class UserResource {
    /**
    * A map of additional properties, keyed on the property name (private). Must match the names and types defined in the template for this user type, or be an extra not from the template
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * The first line of the user's address (private)
    */
    'address': string;
    /**
    * The second line of user's address (private)
    */
    'address2': string;
    /**
    * The url of the user's avatar image
    */
    'avatarUrl': string;
    /**
    * Relationships where this user is the parent. Read-Only, manage through separate endpoints
    */
    'children': Array<UserRelationshipReferenceResource>;
    /**
    * The user's city (private)
    */
    'city': string;
    /**
    * The ISO3 code for the country from the user's address (private). Will be filled in based on GeoIP country at registration if not provided.
    */
    'countryCode': string;
    /**
    * The code for the user's real money currency (private)
    */
    'currencyCode': string;
    /**
    * The user's date of birth (private) as a unix timestamp
    */
    'dateOfBirth': number;
    /**
    * The user's self description (private)
    */
    'description': string;
    /**
    * The chosen display name of the user, defaults to username if not present
    */
    'displayName': string;
    /**
    * The user's email address (private). May be required and/or unique depending on system configuration (both on by default). Must match standard email requirements if provided (RFC 2822)
    */
    'email': string;
    /**
    * The user's first name (private)
    */
    'firstName': string;
    /**
    * The user's full name (private)
    */
    'fullname': string;
    /**
    * The user's gender (private)
    */
    'gender': string;
    /**
    * The id of the user
    */
    'id': number;
    /**
    * The ISO3 code for the user's currency (private)
    */
    'languageCode': string;
    /**
    * The user's last name (private)
    */
    'lastName': string;
    /**
    * The user's mobile phone number (private)
    */
    'mobileNumber': string;
    /**
    * Relationships where this user is the child. Read-Only, manage through separate endpoints
    */
    'parents': Array<UserRelationshipReferenceResource>;
    /**
    * The plain text password for the new user account. Required for registration; ignored on profile update.  Use password specific endpoints for editing
    */
    'password': string;
    /**
    * The user's postal code (private)
    */
    'postalCode': string;
    /**
    * The user's state (private)
    */
    'state': string;
    /**
    * Tags on the user. Can only be set by admin. Max length per tag is 64 characters
    */
    'tags': Array<string>;
    /**
    * A user template this user is validated against (private). May be null and no validation of properties will be done
    */
    'template': string;
    /**
    * The code for the user's timezone (private)
    */
    'timezoneCode': string;
    /**
    * The login username for the user (private). May be set to match email if system does not require usernames separately.
    */
    'username': string;
}

export class UserTag {
    'id': number;
    'tag': string;
    'user': User;
}

export class VariableTypeResource {
    /**
    * The base class of the type
    */
    'base': VariableTypeResource.BaseEnum;
    /**
    * The name of the variable type. Used as the unique id
    */
    'name': string;
}

export namespace VariableTypeResource {
    export enum BaseEnum {
        NUMBER = <any> 'NUMBER',
        INTEGER = <any> 'INTEGER',
        STRING = <any> 'STRING',
        DATE = <any> 'DATE',
        BOOLEAN = <any> 'BOOLEAN'
    }
}
export class VendorResource {
    /**
    * Whether the vendor is active.  Default = true
    */
    'active': boolean;
    /**
    * The date the vendor was added. Unix timestamp in seconds
    */
    'createDate': number;
    /**
    * A description of the vendor
    */
    'description': string;
    /**
    * The id of the vendor
    */
    'id': number;
    /**
    * The url of an image for the vendor
    */
    'imageUrl': string;
    /**
    * Whether the vendor needs to manually approve invoices before they are paid.  A separate checkout flow is required in this case.  Default: false
    */
    'manualApproval': boolean;
    /**
    * The name of the vendor
    */
    'name': string;
    /**
    * The primary email address for the vendor
    */
    'primaryContactEmail': string;
    /**
    * The name of the primary contact for the vendor
    */
    'primaryContactName': string;
    /**
    * The primary phone number for the vendor
    */
    'primaryContactPhone': string;
    /**
    * The email address for sale inquiries for the vendor
    */
    'salesEmail': string;
    /**
    * The email address for support inquiries for the vendor
    */
    'supportEmail': string;
    /**
    * The date the vendor was last updated. Unix timestamp in seconds
    */
    'updateDate': number;
    /**
    * The url for the vendor's site
    */
    'url': string;
}

export class Version {
    'version': string;
}

export class Video {
    'active': boolean;
    'author': Artist;
    'authored': number;
    'banned': boolean;
    'categoryId': string;
    'categoryName': string;
    'contributors': CollectionVideoContribution;
    'created': number;
    'embed': string;
    'extension': string;
    'height': number;
    'id': number;
    'length': number;
    'location': string;
    'longDescription': string;
    'mimeType': string;
    'name': string;
    'priority': number;
    'privacy': Video.PrivacyEnum;
    'published': boolean;
    'shortDescription': string;
    'size': number;
    'tags': Array<VideoTag>;
    'thumbnail': string;
    'updated': number;
    'uploader': User;
    'views': number;
    'whitelist': Array<User>;
    'width': number;
}

export namespace Video {
    export enum PrivacyEnum {
        Private = <any> 'private',
        Friends = <any> 'friends',
        Public = <any> 'public'
    }
}
export class VideoContribution {
    'artist': Artist;
    'id': number;
    'media': Video;
    'role': string;
}

export class VideoRelationshipResource {
    /**
    * The owner of the relationship
    */
    'from': SimpleReferenceResourcelong;
    /**
    * The id of the relationship
    */
    'id': number;
    /**
    * Details about the relationship such as type or other information. Max length 10 characters
    */
    'relationshipDetails': string;
    /**
    * The target of the relationship.
    */
    'to': SimpleReferenceResourcelong;
}

export class VideoResource {
    /**
    * Whether the video is available, based on various factors
    */
    'active': boolean;
    /**
    * The original artist of the media
    */
    'author': SimpleReferenceResourcelong;
    /**
    * The date the media was created as a unix timestamp in seconds
    */
    'authored': number;
    /**
    * Whether the video has been banned or not
    */
    'banned': boolean;
    /**
    * The category of the video
    */
    'category': SimpleReferenceResourcestring;
    /**
    * The comments of the video
    */
    'comments': Array<CommentResource>;
    /**
    * Artists that contributed to the creation. See separate endpoint to add to list
    */
    'contributors': Array<ContributionResource>;
    /**
    * The date/time this resource was created in seconds since unix epoch
    */
    'createdDate': number;
    /**
    * The country of an embedable version
    */
    'embed': string;
    /**
    * The file extension of the media file. 1-5 characters
    */
    'extension': string;
    /**
    * The height of the video in px
    */
    'height': number;
    /**
    * The unique ID for that resource
    */
    'id': number;
    /**
    * The length of the video in seconds
    */
    'length': number;
    /**
    * The country of the media. Typically a url. Cannot be blank
    */
    'location': string;
    /**
    * The user friendly name of that resource. Defaults to blank string
    */
    'longDescription': string;
    /**
    * The mime-type of the media
    */
    'mimeType': string;
    /**
    * The user friendly name of that resource
    */
    'name': string;
    /**
    * The sort order of the video. default: 100
    */
    'priority': number;
    /**
    * The privacy setting. default: private
    */
    'privacy': VideoResource.PrivacyEnum;
    /**
    * Whether the video has been made public. Default true
    */
    'published': boolean;
    /**
    * The user friendly name of that resource. Defaults to blank string
    */
    'shortDescription': string;
    /**
    * The size of the media. Minimum 0 if supplied
    */
    'size': number;
    /**
    * The tags for the video
    */
    'tags': Array<string>;
    /**
    * The country of a thumbnail version. Typically a url
    */
    'thumbnail': string;
    /**
    * The date/time this resource was last updated in seconds since unix epoch
    */
    'updatedDate': number;
    /**
    * The user the media was uploaded by. May be null for system uploaded media. May only be set to a user other than the current caller if VIDEOS_ADMIN permission. Null will mean the caller is the uploader unless the caller has VIDEOS_ADMIN permission, in which case it will be set to null
    */
    'uploader': SimpleUserResource;
    /**
    * The view count of the video
    */
    'views': number;
    /**
    * The width of the video in px
    */
    'width': number;
}

export namespace VideoResource {
    export enum PrivacyEnum {
        Private = <any> 'private',
        Friends = <any> 'friends',
        Public = <any> 'public'
    }
}
export class VideoTag {
    'id': number;
    'tag': string;
    'video': Video;
}

export class WalletAlterRequest {
    /**
    * The amount of currency to add/remove. positive to add, negative to remove
    */
    'delta': number;
    /**
    * The id of an invoice to attribute the transaction to
    */
    'invoiceId': number;
    /**
    * The admin entered or system generated reason
    */
    'reason': string;
    /**
    * The transaction type to allow for search/etc
    */
    'type': string;
}

export class WalletTotalResponse {
    /**
    * The currency code
    */
    'currencyCode': string;
    /**
    * The sum of all wallets in the system for this currency
    */
    'total': number;
}

export class WalletTransactionResource {
    /**
    * The new balance of the wallet after the transaction
    */
    'balance': number;
    /**
    * The unix timestamp in seconds of the transaction
    */
    'createDate': number;
    /**
    * The code of the currency for the transaction
    */
    'currencyCode': string;
    /**
    * The specific details of the transaction, such as a message from the admin that created it
    */
    'details': string;
    /**
    * The id of the transaction
    */
    'id': number;
    /**
    * The id of the invoice that spawned the transaction, if any
    */
    'invoiceId': number;
    /**
    * Whether the transaction has been refunded
    */
    'isRefunded': boolean;
    /**
    * The response
    */
    'response': string;
    /**
    * The root source of the transaction
    */
    'source': WalletTransactionResource.SourceEnum;
    /**
    * If the transaction was successful
    */
    'successful': boolean;
    /**
    * The payment gateway (external) transaction ID
    */
    'transactionId': string;
    /**
    * The general type of the transaction
    */
    'type': string;
    /**
    * The table name of the subclass
    */
    'typeHint': string;
    /**
    * The owner of the wallet
    */
    'user': SimpleUserResource;
    /**
    * The amount of the transaction, positive if a gain, negative if an expenditure
    */
    'value': number;
    /**
    * The id of the wallet this transaction affected
    */
    'walletId': number;
}

export namespace WalletTransactionResource {
    export enum SourceEnum {
        Digital = <any> 'digital',
        Physical = <any> 'physical'
    }
}
export class XsollaPaymentRequest {
    /**
    * The id of an invoice to pay
    */
    'invoiceId': number;
    /**
    * The endpoint URL xsolla should forward the user to after they pay
    */
    'returnUrl': string;
}


export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: request.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: request.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: request.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(_: request.Options): void {
        // Do nothing
    }
}

export enum AWSS3ApiApiKeys {
}

export class AWSS3Api {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: AWSS3ApiApiKeys, value: string) {
        this.authentications[AWSS3ApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Get a signed S3 URL
     * Requires the file name and file content type (i.e., &#39;video/mpeg&#39;)
     * @param filename The file name
     * @param contentType The content type
     */
    public getSignedS3URL (filename?: string, contentType?: string) : Promise<{ response: http.ClientResponse; body: AmazonS3Activity;  }> {
        const localVarPath = this.basePath + '/amazon/s3/signedposturl';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filename !== undefined) {
            queryParameters['filename'] = filename;
        }

        if (contentType !== undefined) {
            queryParameters['content_type'] = contentType;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AmazonS3Activity;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ActivitiesApiApiKeys {
}

export class ActivitiesApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: ActivitiesApiApiKeys, value: string) {
        this.authentications[ActivitiesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Create an activity
     * 
     * @param activityResource The activity resource object
     */
    public createActivity (activityResource?: ActivityResource) : Promise<{ response: http.ClientResponse; body: ActivityResource;  }> {
        const localVarPath = this.basePath + '/activities';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: activityResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ActivityResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a new activity occurrence
     * Has to enforce extra rules if not used as an admin
     * @param test if true, indicates that the occurrence should NOT be created. This can be used to test for eligibility and valid settings
     * @param activityOccurrenceResource The activity occurrence object
     */
    public createActivityOccurrence (test?: boolean, activityOccurrenceResource?: ActivityOccurrenceResource) : Promise<{ response: http.ClientResponse; body: ActivityOccurrenceResource;  }> {
        const localVarPath = this.basePath + '/activity-occurrences';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (test !== undefined) {
            queryParameters['test'] = test;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: activityOccurrenceResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ActivityOccurrenceResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an activity
     * 
     * @param id The id of the activity
     */
    public deleteActivity (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/activities/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteActivity.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List activity definitions
     * 
     * @param filterTemplate Filter for activities that are templates, or specifically not if false
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getActivities (filterTemplate?: boolean, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceBareActivityResource;  }> {
        const localVarPath = this.basePath + '/activities';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterTemplate !== undefined) {
            queryParameters['filter_template'] = filterTemplate;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceBareActivityResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single activity
     * 
     * @param id The id of the activity
     */
    public getActivity (id: number) : Promise<{ response: http.ClientResponse; body: ActivityResource;  }> {
        const localVarPath = this.basePath + '/activities/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getActivity.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ActivityResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Sets the status of an activity occurrence to FINISHED and logs metrics
     * 
     * @param activityOccurrenceId The id of the activity occurrence
     * @param activityOccurrenceResults The activity occurrence object
     */
    public setActivityOccurrenceResults (activityOccurrenceId: number, activityOccurrenceResults?: ActivityOccurrenceResults) : Promise<{ response: http.ClientResponse; body: ActivityOccurrenceResults;  }> {
        const localVarPath = this.basePath + '/activity-occurrences/{activity_occurrence_id}/results'
            .replace('{' + 'activity_occurrence_id' + '}', String(activityOccurrenceId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'activityOccurrenceId' is not null or undefined
        if (activityOccurrenceId === null || activityOccurrenceId === undefined) {
            throw new Error('Required parameter activityOccurrenceId was null or undefined when calling setActivityOccurrenceResults.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: activityOccurrenceResults,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ActivityOccurrenceResults;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an activity
     * 
     * @param id The id of the activity
     * @param activityResource The activity resource object
     */
    public updateActivity (id: number, activityResource?: ActivityResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/activities/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateActivity.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: activityResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updated the status of an activity occurrence
     * If setting to &#39;FINISHED&#39; you must POST to /results instead to record the metrics and get synchronous reward results
     * @param activityOccurrenceId The id of the activity occurrence
     * @param activityCccurrenceStatus The activity occurrence status object
     */
    public updateActivityOccurrence (activityOccurrenceId: number, activityCccurrenceStatus?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/activity-occurrences/{activity_occurrence_id}/status'
            .replace('{' + 'activity_occurrence_id' + '}', String(activityOccurrenceId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'activityOccurrenceId' is not null or undefined
        if (activityOccurrenceId === null || activityOccurrenceId === undefined) {
            throw new Error('Required parameter activityOccurrenceId was null or undefined when calling updateActivityOccurrence.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: activityCccurrenceStatus,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AuthClientsApiApiKeys {
}

export class AuthClientsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: AuthClientsApiApiKeys, value: string) {
        this.authentications[AuthClientsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Create a new client
     * 
     * @param clientResource The client resource object
     */
    public createClient (clientResource?: ClientResource) : Promise<{ response: http.ClientResponse; body: ClientResource;  }> {
        const localVarPath = this.basePath + '/auth/clients';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: clientResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ClientResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a client
     * 
     * @param clientKey The key of the client
     */
    public deleteClient (clientKey: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/auth/clients/{client_key}'
            .replace('{' + 'client_key' + '}', String(clientKey));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'clientKey' is not null or undefined
        if (clientKey === null || clientKey === undefined) {
            throw new Error('Required parameter clientKey was null or undefined when calling deleteClient.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single client
     * 
     * @param clientKey The key of the client
     */
    public getClient (clientKey: string) : Promise<{ response: http.ClientResponse; body: ClientResource;  }> {
        const localVarPath = this.basePath + '/auth/clients/{client_key}'
            .replace('{' + 'client_key' + '}', String(clientKey));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'clientKey' is not null or undefined
        if (clientKey === null || clientKey === undefined) {
            throw new Error('Required parameter clientKey was null or undefined when calling getClient.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ClientResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List available client grant types
     * 
     */
    public getClientGrantTypes () : Promise<{ response: http.ClientResponse; body: Array<GrantTypeResource>;  }> {
        const localVarPath = this.basePath + '/auth/clients/grant-types';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GrantTypeResource>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search clients
     * 
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getClients (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceClientResource;  }> {
        const localVarPath = this.basePath + '/auth/clients';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceClientResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set grant types for a client
     * 
     * @param clientKey The key of the client
     * @param grantList A list of unique grant types
     */
    public setClientGrantTypes (clientKey: string, grantList?: Array<string>) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/auth/clients/{client_key}/grant-types'
            .replace('{' + 'client_key' + '}', String(clientKey));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'clientKey' is not null or undefined
        if (clientKey === null || clientKey === undefined) {
            throw new Error('Required parameter clientKey was null or undefined when calling setClientGrantTypes.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: grantList,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set redirect uris for a client
     * 
     * @param clientKey The key of the client
     * @param redirectList A list of unique redirect uris
     */
    public setClientRedirectUris (clientKey: string, redirectList?: Array<string>) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/auth/clients/{client_key}/redirect-uris'
            .replace('{' + 'client_key' + '}', String(clientKey));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'clientKey' is not null or undefined
        if (clientKey === null || clientKey === undefined) {
            throw new Error('Required parameter clientKey was null or undefined when calling setClientRedirectUris.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: redirectList,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a client
     * 
     * @param clientKey The key of the client
     * @param clientResource The client resource object
     */
    public updateClient (clientKey: string, clientResource?: ClientResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/auth/clients/{client_key}'
            .replace('{' + 'client_key' + '}', String(clientKey));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'clientKey' is not null or undefined
        if (clientKey === null || clientKey === undefined) {
            throw new Error('Required parameter clientKey was null or undefined when calling updateClient.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: clientResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AuthPermissionsApiApiKeys {
}

export class AuthPermissionsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: AuthPermissionsApiApiKeys, value: string) {
        this.authentications[AuthPermissionsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Create a new permission
     * 
     * @param permissionResource The permission resource object
     */
    public createPermission (permissionResource?: PermissionResource) : Promise<{ response: http.ClientResponse; body: PermissionResource;  }> {
        const localVarPath = this.basePath + '/auth/permissions';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: permissionResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PermissionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a permission
     * 
     * @param permission The permission value
     * @param force If true, removes permission assigned to roles
     */
    public deletePermission (permission: string, force?: boolean) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/auth/permissions/{permission}'
            .replace('{' + 'permission' + '}', String(permission));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'permission' is not null or undefined
        if (permission === null || permission === undefined) {
            throw new Error('Required parameter permission was null or undefined when calling deletePermission.');
        }

        if (force !== undefined) {
            queryParameters['force'] = force;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single permission
     * 
     * @param permission The permission value
     */
    public getPermission (permission: string) : Promise<{ response: http.ClientResponse; body: PermissionResource;  }> {
        const localVarPath = this.basePath + '/auth/permissions/{permission}'
            .replace('{' + 'permission' + '}', String(permission));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'permission' is not null or undefined
        if (permission === null || permission === undefined) {
            throw new Error('Required parameter permission was null or undefined when calling getPermission.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PermissionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search permissions
     * 
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getPermissions (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourcePermissionResource;  }> {
        const localVarPath = this.basePath + '/auth/permissions';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourcePermissionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a permission
     * 
     * @param permission The permission value
     * @param permissionResource The permission resource object
     */
    public updatePermission (permission: string, permissionResource?: PermissionResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/auth/permissions/{permission}'
            .replace('{' + 'permission' + '}', String(permission));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'permission' is not null or undefined
        if (permission === null || permission === undefined) {
            throw new Error('Required parameter permission was null or undefined when calling updatePermission.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: permissionResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AuthRolesApiApiKeys {
}

export class AuthRolesApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: AuthRolesApiApiKeys, value: string) {
        this.authentications[AuthRolesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Create a new role
     * 
     * @param roleResource The role resource object
     */
    public createRole (roleResource?: RoleResource) : Promise<{ response: http.ClientResponse; body: RoleResource;  }> {
        const localVarPath = this.basePath + '/auth/roles';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: roleResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RoleResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a role
     * 
     * @param role The role value
     * @param force If true, removes role from users/clients
     */
    public deleteRole (role: string, force?: boolean) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/auth/roles/{role}'
            .replace('{' + 'role' + '}', String(role));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'role' is not null or undefined
        if (role === null || role === undefined) {
            throw new Error('Required parameter role was null or undefined when calling deleteRole.');
        }

        if (force !== undefined) {
            queryParameters['force'] = force;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get roles for a client
     * 
     * @param clientKey The client key
     */
    public getClientRoles (clientKey: string) : Promise<{ response: http.ClientResponse; body: Array<RoleResource>;  }> {
        const localVarPath = this.basePath + '/auth/clients/{client_key}/roles'
            .replace('{' + 'client_key' + '}', String(clientKey));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'clientKey' is not null or undefined
        if (clientKey === null || clientKey === undefined) {
            throw new Error('Required parameter clientKey was null or undefined when calling getClientRoles.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<RoleResource>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single role
     * 
     * @param role The role value
     */
    public getRole (role: string) : Promise<{ response: http.ClientResponse; body: RoleResource;  }> {
        const localVarPath = this.basePath + '/auth/roles/{role}'
            .replace('{' + 'role' + '}', String(role));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'role' is not null or undefined
        if (role === null || role === undefined) {
            throw new Error('Required parameter role was null or undefined when calling getRole.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RoleResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search roles
     * 
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getRoles (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceRoleResource;  }> {
        const localVarPath = this.basePath + '/auth/roles';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceRoleResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get roles for a user
     * 
     * @param userId The user&#39;s id
     */
    public getUserRoles (userId: number) : Promise<{ response: http.ClientResponse; body: Array<RoleResource>;  }> {
        const localVarPath = this.basePath + '/auth/users/{user_id}/roles'
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserRoles.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<RoleResource>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set roles for a client
     * 
     * @param clientKey The client key
     * @param rolesList The list of unique roles
     */
    public setClientRoles (clientKey: string, rolesList?: Array<string>) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/auth/clients/{client_key}/roles'
            .replace('{' + 'client_key' + '}', String(clientKey));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'clientKey' is not null or undefined
        if (clientKey === null || clientKey === undefined) {
            throw new Error('Required parameter clientKey was null or undefined when calling setClientRoles.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: rolesList,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set permissions for a role
     * 
     * @param role The role value
     * @param permissionsList The list of unique permissions
     */
    public setPermissionsForRole (role: string, permissionsList?: Array<string>) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/auth/roles/{role}/permissions'
            .replace('{' + 'role' + '}', String(role));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'role' is not null or undefined
        if (role === null || role === undefined) {
            throw new Error('Required parameter role was null or undefined when calling setPermissionsForRole.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: permissionsList,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set roles for a user
     * 
     * @param userId The user&#39;s id
     * @param rolesList The list of unique roles
     */
    public setUserRoles (userId: number, rolesList?: Array<string>) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/auth/users/{user_id}/roles'
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling setUserRoles.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: rolesList,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a role
     * 
     * @param role The role value
     * @param roleResource The role resource object
     */
    public updateRole (role: string, roleResource?: RoleResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/auth/roles/{role}'
            .replace('{' + 'role' + '}', String(role));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'role' is not null or undefined
        if (role === null || role === undefined) {
            throw new Error('Required parameter role was null or undefined when calling updateRole.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: roleResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AuthTokensApiApiKeys {
}

export class AuthTokensApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: AuthTokensApiApiKeys, value: string) {
        this.authentications[AuthTokensApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Delete a token by username and client id
     * 
     * @param username The username of the user
     * @param clientId The id of the client
     */
    public deleteToken (username: string, clientId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/auth/tokens/{username}/{client_id}'
            .replace('{' + 'username' + '}', String(username))
            .replace('{' + 'client_id' + '}', String(clientId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling deleteToken.');
        }

        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling deleteToken.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete all tokens by username
     * 
     * @param username The username of the user
     */
    public deleteTokens (username: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/auth/tokens/{username}'
            .replace('{' + 'username' + '}', String(username));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling deleteTokens.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single token by username and client id
     * 
     * @param username The username of the user
     * @param clientId The id of the client
     */
    public getToken (username: string, clientId: string) : Promise<{ response: http.ClientResponse; body: OauthAccessTokenResource;  }> {
        const localVarPath = this.basePath + '/auth/tokens/{username}/{client_id}'
            .replace('{' + 'username' + '}', String(username))
            .replace('{' + 'client_id' + '}', String(clientId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling getToken.');
        }

        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling getToken.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OauthAccessTokenResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List usernames and client ids
     * Token value not shown
     * @param filterClientId Filters for token whose client id matches provided string
     * @param filterUsername Filters for token whose username matches provided string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getTokens (filterClientId?: string, filterUsername?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceOauthAccessTokenResource;  }> {
        const localVarPath = this.basePath + '/auth/tokens';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterClientId !== undefined) {
            queryParameters['filter_client_id'] = filterClientId;
        }

        if (filterUsername !== undefined) {
            queryParameters['filter_username'] = filterUsername;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceOauthAccessTokenResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BRERuleEngineActionsApiApiKeys {
}

export class BRERuleEngineActionsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: BRERuleEngineActionsApiApiKeys, value: string) {
        this.authentications[BRERuleEngineActionsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Get a list of available actions
     * 
     * @param filterCategory Filter for actions that are within a specific category
     * @param filterName Filter for actions that have names containing the given string
     */
    public getBREActions (filterCategory?: string, filterName?: string) : Promise<{ response: http.ClientResponse; body: Array<ActionResource>;  }> {
        const localVarPath = this.basePath + '/bre/actions';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterCategory !== undefined) {
            queryParameters['filter_category'] = filterCategory;
        }

        if (filterName !== undefined) {
            queryParameters['filter_name'] = filterName;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<ActionResource>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BRERuleEngineCategoriesApiApiKeys {
}

export class BRERuleEngineCategoriesApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: BRERuleEngineCategoriesApiApiKeys, value: string) {
        this.authentications[BRERuleEngineCategoriesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Create a BRE category template
     * Templates define a type of BRE category and the properties they have
     * @param template The category template to create
     */
    public createBRECategoryTemplate (template?: TemplateResource) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/bre/categories/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: template,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a BRE category template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    public deleteBRECategoryTemplate (id: string, cascade?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/bre/categories/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteBRECategoryTemplate.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = cascade;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List categories
     * 
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getBRECategories (size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceBreCategoryResource;  }> {
        const localVarPath = this.basePath + '/bre/categories';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceBreCategoryResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single category
     * 
     * @param name The category name
     */
    public getBRECategory (name: string) : Promise<{ response: http.ClientResponse; body: BreCategoryResource;  }> {
        const localVarPath = this.basePath + '/bre/categories/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getBRECategory.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BreCategoryResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single BRE category template
     * 
     * @param id The id of the template
     */
    public getBRECategoryTemplate (id: string) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/bre/categories/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getBRECategoryTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search BRE category templates
     * 
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getBRECategoryTemplates (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }> {
        const localVarPath = this.basePath + '/bre/categories/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a category
     * 
     * @param name The category name
     * @param category The updated BRE category information
     */
    public updateBRECategory (name: string, category?: BreCategoryResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/bre/categories/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling updateBRECategory.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: category,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a BRE category template
     * 
     * @param id The id of the template
     * @param template The updated category template definition
     */
    public updateBRECategoryTemplate (id: string, template?: TemplateResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/bre/categories/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateBRECategoryTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: template,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BRERuleEngineEventsApiApiKeys {
}

export class BRERuleEngineEventsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: BRERuleEngineEventsApiApiKeys, value: string) {
        this.authentications[BRERuleEngineEventsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Fire a new event, based on an existing trigger
     * Parameters within the event must match names and types from the trigger. Actual rule execution is asynchornous.
     * @param breEvent The BRE event object
     */
    public sendBREEvent (breEvent?: BreEvent) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/bre/events';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: breEvent,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BRERuleEngineExpressionsApiApiKeys {
}

export class BRERuleEngineExpressionsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: BRERuleEngineExpressionsApiApiKeys, value: string) {
        this.authentications[BRERuleEngineExpressionsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Get a list of &#39;lookup&#39; type expressions
     * These are expression types that take a second expression as input and produce a value. These can be used in addition to the standard types, like parameter, global and constant (see BRE documentation for details).
     */
    public getBREExpressions () : Promise<{ response: http.ClientResponse; body: Array<LookupTypeResource>;  }> {
        const localVarPath = this.basePath + '/bre/expressions/lookup';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<LookupTypeResource>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BRERuleEngineGlobalsApiApiKeys {
}

export class BRERuleEngineGlobalsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: BRERuleEngineGlobalsApiApiKeys, value: string) {
        this.authentications[BRERuleEngineGlobalsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Create a global definition
     * Once created you can then use in a custom rule. Note that global definitions cannot be modified or deleted if in use.
     * @param breGlobalResource The BRE global resource object
     */
    public createBREGlobal (breGlobalResource?: BreGlobalResource) : Promise<{ response: http.ClientResponse; body: BreGlobalResource;  }> {
        const localVarPath = this.basePath + '/bre/globals/definitions';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: breGlobalResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BreGlobalResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a global
     * May fail if there are existing rules against it. Cannot delete core globals
     * @param id The id of the global definition
     */
    public deleteBREGlobal (id: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/bre/globals/definitions/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteBREGlobal.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single global definition
     * 
     * @param id The id of the global definition
     */
    public getBREGlobal (id: string) : Promise<{ response: http.ClientResponse; body: BreGlobalResource;  }> {
        const localVarPath = this.basePath + '/bre/globals/definitions/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getBREGlobal.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BreGlobalResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List global definitions
     * 
     * @param filterSystem Filter for globals that are system globals when true, or not when false. Leave off for both mixed
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getBREGlobals (filterSystem?: boolean, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceBreGlobalResource;  }> {
        const localVarPath = this.basePath + '/bre/globals/definitions';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterSystem !== undefined) {
            queryParameters['filter_system'] = filterSystem;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceBreGlobalResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a global definition
     * May fail if new parameters mismatch requirements of existing rules. Cannot update core globals
     * @param id The id of the global definition
     * @param breGlobalResource The BRE global resource object
     */
    public updateBREGlobal (id: string, breGlobalResource?: BreGlobalResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/bre/globals/definitions/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateBREGlobal.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: breGlobalResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BRERuleEngineRulesApiApiKeys {
}

export class BRERuleEngineRulesApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: BRERuleEngineRulesApiApiKeys, value: string) {
        this.authentications[BRERuleEngineRulesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Create a rule
     * Rules define which actions to run when a given event verifies the specified conditions. Conditions and actions are defined by binding event or context parameters to arguments. Conditions also known as Predicates are logical expressions that result in a boolean. Operators are used to describe rules between arguments to form that condition. There are 3 families of operators: Boolean, Math and String. Math and String operators are functions that transform arguments into numbers or strings...&lt;h1&gt;Boolean Operators&lt;/h1&gt;&lt;br /&gt;&lt;br /&gt;1 arg:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;IS_NULL&lt;/li&gt; &lt;li&gt;IS_NOT_NULL&lt;/li&gt; &lt;li&gt;STRING_IS_EMPTY&lt;/li&gt; &lt;li&gt;NOT &lt;/li&gt; &lt;li&gt;MAP_IS_EMPTY&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;2 args:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;EQ&lt;/li&gt; &lt;li&gt;NE (Not Equals)&lt;/li&gt; &lt;li&gt;GT (Greater Than)&lt;/li&gt; &lt;li&gt;GOE (Greater Or Equals)&lt;/li&gt; &lt;li&gt;LT (Lesser Than)&lt;/li&gt; &lt;li&gt;LOE (Lesser Or Equals)&lt;/li&gt; &lt;li&gt;OR&lt;/li&gt; &lt;li&gt;AND&lt;/li&gt; &lt;li&gt;XNOR&lt;/li&gt; &lt;li&gt;XOR&lt;/li&gt; &lt;li&gt;CONTAINS_KEY (for maps only)&lt;/li&gt; &lt;li&gt;CONTAINS_VALUE (for maps only)&lt;/li&gt; &lt;li&gt;MATCHES (regex)&lt;/li&gt; &lt;li&gt;MATCHES_IC (regex ignore case)&lt;/li&gt; &lt;li&gt;STARTS_WITH&lt;/li&gt; &lt;li&gt;STARTS_WITH_IC&lt;/li&gt; &lt;li&gt;EQ_IGNORE_CASE&lt;/li&gt; &lt;li&gt;ENDS_WITH&lt;/li&gt; &lt;li&gt;ENDS_WITH_IC&lt;/li&gt; &lt;li&gt;STRING_CONTAINS&lt;/li&gt; &lt;li&gt;STRING_CONTAINS_IC&lt;/li&gt; &lt;li&gt;LIKE (SQL like)&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;3 args exceptions:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;BETWEEN&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;n args:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;IN&lt;/li&gt; &lt;li&gt;NOT_INT&lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;Math Operators&lt;/h1&gt;1 arg:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;NEGATE&lt;/li&gt; &lt;li&gt;MAP_SIZE&lt;/li&gt; &lt;li&gt;STRING_LENGTH&lt;/li&gt; &lt;li&gt;CEIL&lt;/li&gt; &lt;li&gt;ABS&lt;/li&gt; &lt;li&gt;FLOOR&lt;/li&gt; &lt;li&gt;ROUND&lt;/li&gt; &lt;li&gt;RANDOM (no arg)&lt;/li&gt; &lt;li&gt;RANDOM2 (seed arg)&lt;/li&gt; &lt;li&gt;NUMCAST&lt;/li&gt; &lt;li&gt;HOUR&lt;/li&gt; &lt;li&gt;MINUTE&lt;/li&gt; &lt;li&gt;SECOND&lt;/li&gt; &lt;li&gt;MILLISECOND&lt;/li&gt; &lt;li&gt;YEAR&lt;/li&gt; &lt;li&gt;WEEK&lt;/li&gt; &lt;li&gt;YEAR_MONTH&lt;/li&gt; &lt;li&gt;YEAR_WEEK&lt;/li&gt; &lt;li&gt;DAY_OF_WEEK&lt;/li&gt; &lt;li&gt;DAY_OF_MONTH&lt;/li&gt; &lt;li&gt;DAY_OF_YEAR&lt;/li&gt; &lt;li&gt;WEEK&lt;/li&gt; &lt;li&gt;WEEK&lt;/li&gt; &lt;li&gt;WEEK&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;br /&gt;2 args:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;ADD&lt;/li&gt; &lt;li&gt;DIV&lt;/li&gt; &lt;li&gt;MULT&lt;/li&gt; &lt;li&gt;SUB&lt;/li&gt; &lt;li&gt;POWER&lt;/li&gt; &lt;li&gt;MOD&lt;/li&gt; &lt;li&gt;LOCATE (index of (string, char))&lt;/li&gt; &lt;li&gt;DIFF_YEARS&lt;/li&gt; &lt;li&gt;DIFF_MONTHS&lt;/li&gt; &lt;li&gt;DIFF_WEEKS&lt;/li&gt; &lt;li&gt;DIFF_DAYS&lt;/li&gt; &lt;li&gt;DIFF_HOURS&lt;/li&gt; &lt;li&gt;DIFF_MINUTES&lt;/li&gt; &lt;li&gt;DIFF_SECONDS&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;br /&gt;2 args:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;MIN&lt;/li&gt; &lt;li&gt;MAX&lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;String Operators&lt;/h1&gt;0 arg:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;CURRENT_TIME&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;br /&gt;1 arg:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;CURRENT_TIME&lt;/li&gt; &lt;li&gt;LOWER&lt;/li&gt; &lt;li&gt;UPPER&lt;/li&gt; &lt;li&gt;TRIM&lt;/li&gt; &lt;li&gt;STRING_CAST&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;br /&gt;2 args:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;CHAR_AT&lt;/li&gt; &lt;li&gt;SUBSTR_1ARG (substr(string, start))&lt;/li&gt; &lt;li&gt;CONCAT&lt;/li&gt; &lt;li&gt;TRIM&lt;/li&gt; &lt;li&gt;STRING_CAST&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;br /&gt;3 args:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;SUBSTR_2ARGS (substr(string, start, length))&lt;/li&gt;&lt;/ul&gt;
     * @param breRule The BRE rule object
     */
    public createBRERule (breRule?: BreRule) : Promise<{ response: http.ClientResponse; body: BreRule;  }> {
        const localVarPath = this.basePath + '/bre/rules';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: breRule,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BreRule;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a rule
     * May fail if there are existing rules against it. Cannot delete core rules
     * @param id The id of the rule
     */
    public deleteBRERule (id: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/bre/rules/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteBRERule.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a string representation of the provided expression
     * 
     * @param expression The expression
     */
    public getBREExpressionAsString (expression?: Expressionobject) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/bre/rules/expression-as-string';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: expression,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single rule
     * 
     * @param id The id of the rule
     */
    public getBRERule (id: string) : Promise<{ response: http.ClientResponse; body: BreRule;  }> {
        const localVarPath = this.basePath + '/bre/rules/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getBRERule.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BreRule;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List rules
     * 
     * @param filterName Filter for rules containing the given name
     * @param filterEnabled Filter for rules by active status, null for both
     * @param filterSystem Filter for rules that are system rules when true, or not when false. Leave off for both mixed
     * @param filterTrigger Filter for rules that are for the trigger with the given name
     * @param filterAction Filter for rules that use the action with the given name
     * @param filterCondition Filter for rules that have a condition containing the given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getBRERules (filterName?: string, filterEnabled?: boolean, filterSystem?: boolean, filterTrigger?: string, filterAction?: string, filterCondition?: string, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceBreRule;  }> {
        const localVarPath = this.basePath + '/bre/rules';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterName !== undefined) {
            queryParameters['filter_name'] = filterName;
        }

        if (filterEnabled !== undefined) {
            queryParameters['filter_enabled'] = filterEnabled;
        }

        if (filterSystem !== undefined) {
            queryParameters['filter_system'] = filterSystem;
        }

        if (filterTrigger !== undefined) {
            queryParameters['filter_trigger'] = filterTrigger;
        }

        if (filterAction !== undefined) {
            queryParameters['filter_action'] = filterAction;
        }

        if (filterCondition !== undefined) {
            queryParameters['filter_condition'] = filterCondition;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceBreRule;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Enable or disable a rule
     * This is helpful for turning off systems rules which cannot be deleted or modified otherwise
     * @param id The id of the rule
     * @param enabled The boolean value
     */
    public setBRERule (id: string, enabled?: BooleanResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/bre/rules/{id}/enabled'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling setBRERule.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: enabled,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a rule
     * Cannot update system rules
     * @param id The id of the rule
     * @param breRule The BRE rule object
     */
    public updateBRERule (id: string, breRule?: BreRule) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/bre/rules/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateBRERule.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: breRule,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BRERuleEngineTriggersApiApiKeys {
}

export class BRERuleEngineTriggersApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: BRERuleEngineTriggersApiApiKeys, value: string) {
        this.authentications[BRERuleEngineTriggersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Create a trigger
     * Customer added triggers will not be fired automatically or have rules associated with them by default. Custom rules must be added to get use from the trigger and it must then be fired from the outside. See the Bre Event services
     * @param breTriggerResource The BRE trigger resource object
     */
    public createBRETrigger (breTriggerResource?: BreTriggerResource) : Promise<{ response: http.ClientResponse; body: BreTriggerResource;  }> {
        const localVarPath = this.basePath + '/bre/triggers';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: breTriggerResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BreTriggerResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a trigger
     * May fail if there are existing rules against it. Cannot delete core triggers
     * @param eventName The trigger event name
     */
    public deleteBRETrigger (eventName: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/bre/triggers/{event_name}'
            .replace('{' + 'event_name' + '}', String(eventName));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'eventName' is not null or undefined
        if (eventName === null || eventName === undefined) {
            throw new Error('Required parameter eventName was null or undefined when calling deleteBRETrigger.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single trigger
     * 
     * @param eventName The trigger event name
     */
    public getBRETrigger (eventName: string) : Promise<{ response: http.ClientResponse; body: BreTriggerResource;  }> {
        const localVarPath = this.basePath + '/bre/triggers/{event_name}'
            .replace('{' + 'event_name' + '}', String(eventName));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'eventName' is not null or undefined
        if (eventName === null || eventName === undefined) {
            throw new Error('Required parameter eventName was null or undefined when calling getBRETrigger.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BreTriggerResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List triggers
     * 
     * @param filterSystem Filter for triggers that are system triggers when true, or not when false. Leave off for both mixed
     * @param filterCategory Filter for triggers that are within a specific category
     * @param filterName Filter for triggers that have names containing the given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getBRETriggers (filterSystem?: boolean, filterCategory?: string, filterName?: string, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceBreTriggerResource;  }> {
        const localVarPath = this.basePath + '/bre/triggers';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterSystem !== undefined) {
            queryParameters['filter_system'] = filterSystem;
        }

        if (filterCategory !== undefined) {
            queryParameters['filter_category'] = filterCategory;
        }

        if (filterName !== undefined) {
            queryParameters['filter_name'] = filterName;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceBreTriggerResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a trigger
     * May fail if new parameters mismatch requirements of existing rules. Cannot update core triggers
     * @param eventName The trigger event name
     * @param breTriggerResource The BRE trigger resource object
     */
    public updateBRETrigger (eventName: string, breTriggerResource?: BreTriggerResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/bre/triggers/{event_name}'
            .replace('{' + 'event_name' + '}', String(eventName));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'eventName' is not null or undefined
        if (eventName === null || eventName === undefined) {
            throw new Error('Required parameter eventName was null or undefined when calling updateBRETrigger.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: breTriggerResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BRERuleEngineVariablesApiApiKeys {
}

export class BRERuleEngineVariablesApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: BRERuleEngineVariablesApiApiKeys, value: string) {
        this.authentications[BRERuleEngineVariablesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Get a list of variable types available
     * Types include integer, string, user and invoice. These are used to qualify trigger parameters and action variables with strong typing.
     */
    public getBREVariableTypes () : Promise<{ response: http.ClientResponse; body: Array<VariableTypeResource>;  }> {
        const localVarPath = this.basePath + '/bre/variable-types';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<VariableTypeResource>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CampaignsApiApiKeys {
}

export class CampaignsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CampaignsApiApiKeys, value: string) {
        this.authentications[CampaignsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Add a challenge to a campaign
     * 
     * @param id The id of the campaign
     * @param challengeId The id of the challenge
     */
    public addChallengeToCampaign (id: number, challengeId?: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/campaigns/{id}/challenges'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling addChallengeToCampaign.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: challengeId,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a campaign
     * 
     * @param campaignResource The campaign resource object
     */
    public createCampaign (campaignResource?: CampaignResource) : Promise<{ response: http.ClientResponse; body: CampaignResource;  }> {
        const localVarPath = this.basePath + '/campaigns';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: campaignResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CampaignResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a campaign template
     * Campaign Templates define a type of campaign and the properties they have
     * @param campaignTemplateResource The campaign template resource object
     */
    public createCampaignTemplate (campaignTemplateResource?: TemplateResource) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/campaigns/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: campaignTemplateResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a campaign
     * 
     * @param id The campaign id
     */
    public deleteCampaign (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/campaigns/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteCampaign.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a campaign template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    public deleteCampaignTemplate (id: string, cascade?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/campaigns/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteCampaignTemplate.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = cascade;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List the challenges associated with a campaign
     * 
     * @param id The campaign id
     */
    public getCampaignChallenges (id: number) : Promise<{ response: http.ClientResponse; body: PageResourceChallengeResource;  }> {
        const localVarPath = this.basePath + '/campaigns/{id}/challenges'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getCampaignChallenges.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceChallengeResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single campaign template
     * 
     * @param id The id of the template
     */
    public getCampaignTemplate (id: string) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/campaigns/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getCampaignTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search campaign templates
     * 
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getCampaignTemplates (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }> {
        const localVarPath = this.basePath + '/campaigns/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a single campaign
     * 
     * @param id The campaign id
     */
    public getCampaignUsingGET (id: number) : Promise<{ response: http.ClientResponse; body: CampaignResource;  }> {
        const localVarPath = this.basePath + '/campaigns/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getCampaignUsingGET.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CampaignResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search campaigns
     * 
     * @param filterActive Filter for campaigns that are active
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getCampaigns (filterActive?: boolean, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceCampaignResource;  }> {
        const localVarPath = this.basePath + '/campaigns';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterActive !== undefined) {
            queryParameters['filter_active'] = filterActive;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceCampaignResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Remove a challenge from a campaign
     * 
     * @param campaignId The campaign id
     * @param id The challenge id
     */
    public removeChallengeFromCampaign (campaignId: number, id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/campaigns/{campaign_id}/challenges/{id}'
            .replace('{' + 'campaign_id' + '}', String(campaignId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling removeChallengeFromCampaign.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling removeChallengeFromCampaign.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a campaign
     * 
     * @param id The campaign id
     * @param campaignResource The campaign resource object
     */
    public updateCampaign (id: number, campaignResource?: CampaignResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/campaigns/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateCampaign.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: campaignResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an campaign template
     * 
     * @param id The id of the template
     * @param campaignTemplateResource The campaign template resource object
     */
    public updateCampaignTemplate (id: string, campaignTemplateResource?: TemplateResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/campaigns/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateCampaignTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: campaignTemplateResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CampaignsChallengesApiApiKeys {
}

export class CampaignsChallengesApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CampaignsChallengesApiApiKeys, value: string) {
        this.authentications[CampaignsChallengesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Create a challenge
     * Challenges do not run on their own.  They must be added to a campaign before events will spawn.
     * @param challengeResource The challenge resource object
     */
    public createChallenge (challengeResource?: ChallengeResource) : Promise<{ response: http.ClientResponse; body: ChallengeResource;  }> {
        const localVarPath = this.basePath + '/challenges';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: challengeResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ChallengeResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a challenge activity
     * 
     * @param challengeId The challenge id
     * @param challengeActivityResource The challenge activity resource object
     * @param validateSettings Whether to validate the settings being sent against the available settings on the base activity.
     */
    public createChallengeActivity (challengeId: number, challengeActivityResource?: ChallengeActivityResource, validateSettings?: boolean) : Promise<{ response: http.ClientResponse; body: ChallengeActivityResource;  }> {
        const localVarPath = this.basePath + '/challenges/{challenge_id}/activities'
            .replace('{' + 'challenge_id' + '}', String(challengeId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'challengeId' is not null or undefined
        if (challengeId === null || challengeId === undefined) {
            throw new Error('Required parameter challengeId was null or undefined when calling createChallengeActivity.');
        }

        if (validateSettings !== undefined) {
            queryParameters['validateSettings'] = validateSettings;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: challengeActivityResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ChallengeActivityResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a challenge template
     * Challenge Templates define a type of challenge and the properties they have
     * @param challengeTemplateResource The challenge template resource object
     */
    public createChallengeTemplate (challengeTemplateResource?: TemplateResource) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/challenges/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: challengeTemplateResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a challenge
     * 
     * @param id The challenge id
     */
    public deleteChallenge (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/challenges/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteChallenge.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a challenge activity
     * 
     * @param activityId The activity id
     * @param challengeId The challenge id
     */
    public deleteChallengeActivity (activityId: number, challengeId: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/challenges/{challenge_id}/activities/{activity_id}'
            .replace('{' + 'activity_id' + '}', String(activityId))
            .replace('{' + 'challenge_id' + '}', String(challengeId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'activityId' is not null or undefined
        if (activityId === null || activityId === undefined) {
            throw new Error('Required parameter activityId was null or undefined when calling deleteChallengeActivity.');
        }

        // verify required parameter 'challengeId' is not null or undefined
        if (challengeId === null || challengeId === undefined) {
            throw new Error('Required parameter challengeId was null or undefined when calling deleteChallengeActivity.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a challenge event
     * 
     * @param id The challenge event id
     */
    public deleteChallengeEvent (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/challenges/events/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteChallengeEvent.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a challenge template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    public deleteChallengeTemplate (id: string, cascade?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/challenges/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteChallengeTemplate.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = cascade;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a challenge
     * 
     * @param id The challenge id
     */
    public getChallenge (id: number) : Promise<{ response: http.ClientResponse; body: ChallengeResource;  }> {
        const localVarPath = this.basePath + '/challenges/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getChallenge.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ChallengeResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search challenge activities
     * 
     * @param challengeId The challenge id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getChallengeActivities (challengeId: number, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceBareChallengeActivityResource;  }> {
        const localVarPath = this.basePath + '/challenges/{challenge_id}/activities'
            .replace('{' + 'challenge_id' + '}', String(challengeId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'challengeId' is not null or undefined
        if (challengeId === null || challengeId === undefined) {
            throw new Error('Required parameter challengeId was null or undefined when calling getChallengeActivities.');
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceBareChallengeActivityResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single challenge activity
     * 
     * @param activityId The activity id
     */
    public getChallengeActivity (activityId: number) : Promise<{ response: http.ClientResponse; body: ChallengeActivityResource;  }> {
        const localVarPath = this.basePath + '/challenges/{challenge_id}/activities/{activity_id}'
            .replace('{' + 'activity_id' + '}', String(activityId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'activityId' is not null or undefined
        if (activityId === null || activityId === undefined) {
            throw new Error('Required parameter activityId was null or undefined when calling getChallengeActivity.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ChallengeActivityResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a single challenge event details
     * 
     * @param id The challenge event id
     */
    public getChallengeEvent (id: number) : Promise<{ response: http.ClientResponse; body: ChallengeEventResource;  }> {
        const localVarPath = this.basePath + '/challenges/events/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getChallengeEvent.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ChallengeEventResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a list of challenge events
     * 
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the event start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the event end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterCampaigns check only for events from currently running campaigns
     * @param filterChallenge check only for events from the challenge specified by id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getChallengeEvents (filterStartDate?: string, filterEndDate?: string, filterCampaigns?: boolean, filterChallenge?: number, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceChallengeEventResource;  }> {
        const localVarPath = this.basePath + '/challenges/events';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterStartDate !== undefined) {
            queryParameters['filter_start_date'] = filterStartDate;
        }

        if (filterEndDate !== undefined) {
            queryParameters['filter_end_date'] = filterEndDate;
        }

        if (filterCampaigns !== undefined) {
            queryParameters['filter_campaigns'] = filterCampaigns;
        }

        if (filterChallenge !== undefined) {
            queryParameters['filter_challenge'] = filterChallenge;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceChallengeEventResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single challenge template
     * 
     * @param id The id of the template
     */
    public getChallengeTemplate (id: string) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/challenges/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getChallengeTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search challenge templates
     * 
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getChallengeTemplates (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }> {
        const localVarPath = this.basePath + '/challenges/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a list of challenges
     * 
     * @param filterTemplate Filter for challenges that are not tied to campaigns (templates)
     * @param filterActiveCampaign Filter for challenges that are tied to active campaigns
     */
    public getChallenges (filterTemplate?: boolean, filterActiveCampaign?: boolean) : Promise<{ response: http.ClientResponse; body: PageResourceChallengeResource;  }> {
        const localVarPath = this.basePath + '/challenges';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterTemplate !== undefined) {
            queryParameters['filter_template'] = filterTemplate;
        }

        if (filterActiveCampaign !== undefined) {
            queryParameters['filter_active_campaign'] = filterActiveCampaign;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceChallengeResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a challenge
     * If the challenge is a copy, changes will propagate to all the related challenges
     * @param id The challenge id
     * @param challengeResource The challenge resource object
     */
    public updateChallenge (id: number, challengeResource?: ChallengeResource) : Promise<{ response: http.ClientResponse; body: ChallengeResource;  }> {
        const localVarPath = this.basePath + '/challenges/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateChallenge.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: challengeResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ChallengeResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a challenge activity
     * 
     * @param activityId The activity id
     * @param challengeId The challenge id
     * @param challengeActivityResource The challenge activity resource object
     */
    public updateChallengeActivity (activityId: number, challengeId: number, challengeActivityResource?: ChallengeActivityResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/challenges/{challenge_id}/activities/{activity_id}'
            .replace('{' + 'activity_id' + '}', String(activityId))
            .replace('{' + 'challenge_id' + '}', String(challengeId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'activityId' is not null or undefined
        if (activityId === null || activityId === undefined) {
            throw new Error('Required parameter activityId was null or undefined when calling updateChallengeActivity.');
        }

        // verify required parameter 'challengeId' is not null or undefined
        if (challengeId === null || challengeId === undefined) {
            throw new Error('Required parameter challengeId was null or undefined when calling updateChallengeActivity.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: challengeActivityResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a challenge template
     * 
     * @param id The id of the template
     * @param challengeTemplateResource The challenge template resource object
     */
    public updateChallengeTemplate (id: string, challengeTemplateResource?: TemplateResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/challenges/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateChallengeTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: challengeTemplateResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CampaignsRewardsApiApiKeys {
}

export class CampaignsRewardsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CampaignsRewardsApiApiKeys, value: string) {
        this.authentications[CampaignsRewardsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Create a reward set
     * 
     * @param rewardSetResource The reward set resource object
     */
    public createRewardSet (rewardSetResource?: RewardSetResource) : Promise<{ response: http.ClientResponse; body: RewardSetResource;  }> {
        const localVarPath = this.basePath + '/rewards';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: rewardSetResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RewardSetResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a reward set
     * 
     * @param id The reward id
     */
    public deleteRewardSet (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/rewards/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteRewardSet.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single reward set
     * 
     * @param id The reward id
     */
    public getRewardSet (id: number) : Promise<{ response: http.ClientResponse; body: RewardSetResource;  }> {
        const localVarPath = this.basePath + '/rewards/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getRewardSet.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RewardSetResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search reward sets
     * 
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getRewardSets (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceRewardSetResource;  }> {
        const localVarPath = this.basePath + '/rewards';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceRewardSetResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a reward set
     * 
     * @param id The reward id
     * @param rewardSetResource The reward set resource object
     */
    public updateRewardSet (id: number, rewardSetResource?: RewardSetResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/rewards/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateRewardSet.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: rewardSetResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CategoriesApiApiKeys {
}

export class CategoriesApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CategoriesApiApiKeys, value: string) {
        this.authentications[CategoriesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Create a new category
     * 
     * @param category The category to create
     */
    public createCategory (category?: CategoryResource) : Promise<{ response: http.ClientResponse; body: CategoryResource;  }> {
        const localVarPath = this.basePath + '/categories';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: category,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CategoryResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a category template
     * Templates define a type of category and the properties they have
     * @param template The template to create
     */
    public createCategoryTemplate (template?: TemplateResource) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/categories/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: template,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an existing category
     * 
     * @param id The id of the category to be deleted
     */
    public deleteCategory (id: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/categories/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteCategory.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a category template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    public deleteCategoryTemplate (id: string, cascade?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/categories/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteCategoryTemplate.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = cascade;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search categories with optional filters
     * 
     * @param filterSearch Filter for categories whose names begin with provided string
     * @param filterActive Filter for categories that are specifically active or inactive
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getCategories (filterSearch?: string, filterActive?: boolean, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceCategoryResource;  }> {
        const localVarPath = this.basePath + '/categories';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterSearch !== undefined) {
            queryParameters['filter_search'] = filterSearch;
        }

        if (filterActive !== undefined) {
            queryParameters['filter_active'] = filterActive;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceCategoryResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single category
     * 
     * @param id The id of the category to retrieve
     */
    public getCategory (id: string) : Promise<{ response: http.ClientResponse; body: CategoryResource;  }> {
        const localVarPath = this.basePath + '/categories/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getCategory.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CategoryResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single category template
     * 
     * @param id The id of the template
     */
    public getCategoryTemplate (id: string) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/categories/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getCategoryTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search category templates
     * 
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getCategoryTemplates (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }> {
        const localVarPath = this.basePath + '/categories/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List all trivia tags in the system
     * 
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getTags (size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourcestring;  }> {
        const localVarPath = this.basePath + '/tags';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourcestring;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an existing category
     * 
     * @param id The id of the category
     * @param category The category to update
     */
    public updateCategory (id: string, category?: CategoryResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/categories/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateCategory.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: category,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a category template
     * 
     * @param id The id of the template
     * @param template The updated template information
     */
    public updateCategoryTemplate (id: string, template?: TemplateResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/categories/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateCategoryTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: template,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ConfigsApiApiKeys {
}

export class ConfigsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: ConfigsApiApiKeys, value: string) {
        this.authentications[ConfigsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Create a new config
     * 
     * @param config The config object
     */
    public createConfig (config?: Config) : Promise<{ response: http.ClientResponse; body: Config;  }> {
        const localVarPath = this.basePath + '/configs';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: config,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Config;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an existing config
     * 
     * @param name The config name
     */
    public deleteConfig (name: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/configs/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteConfig.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single config
     * Only configs that are public readable will be shown without admin access
     * @param name The config name
     */
    public getConfig (name: string) : Promise<{ response: http.ClientResponse; body: Config;  }> {
        const localVarPath = this.basePath + '/configs/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getConfig.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Config;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search configs
     * 
     * @param filterSearch Filter for configs whose name contains the given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getConfigs (filterSearch?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceConfig;  }> {
        const localVarPath = this.basePath + '/configs';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterSearch !== undefined) {
            queryParameters['filter_search'] = filterSearch;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceConfig;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an existing config
     * 
     * @param name The config name
     * @param config The config object
     */
    public updateConfig (name: string, config?: Config) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/configs/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling updateConfig.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: config,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ContentArticlesApiApiKeys {
}

export class ContentArticlesApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: ContentArticlesApiApiKeys, value: string) {
        this.authentications[ContentArticlesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Create a new article
     * Articles are blobs of text with titles, a category and assets. Formatting and display of the text is in the hands of the front end.
     * @param articleResource The new article
     */
    public createArticle (articleResource?: ArticleResource) : Promise<{ response: http.ClientResponse; body: ArticleResource;  }> {
        const localVarPath = this.basePath + '/content/articles';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: articleResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ArticleResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create an article template
     * Article Templates define a type of article and the properties they have
     * @param articleTemplateResource The article template resource object
     */
    public createArticleTemplate (articleTemplateResource?: TemplateResource) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/content/articles/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: articleTemplateResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an existing article
     * 
     * @param id The article id
     */
    public deleteArticle (id: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/content/articles/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteArticle.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an article template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    public deleteArticleTemplate (id: string, cascade?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/content/articles/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteArticleTemplate.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = cascade;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single article
     * 
     * @param id The article id
     */
    public getArticle (id: string) : Promise<{ response: http.ClientResponse; body: ArticleResource;  }> {
        const localVarPath = this.basePath + '/content/articles/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getArticle.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ArticleResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single article template
     * 
     * @param id The id of the template
     */
    public getArticleTemplate (id: string) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/content/articles/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getArticleTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search article templates
     * 
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getArticleTemplates (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }> {
        const localVarPath = this.basePath + '/content/articles/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search articles
     * Get a list of articles with optional filtering. Assets will not be filled in on the resources returned. Use &#39;Get a single article&#39; to retrieve the full resource with assets for a given item as needed.
     * @param filterCategory Filter for articles from a specific category by id
     * @param filterTagset Filter for articles with specified tags (separated by comma)
     * @param filterTitle Filter for articles whose title contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getArticles (filterCategory?: string, filterTagset?: string, filterTitle?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceArticleResource;  }> {
        const localVarPath = this.basePath + '/content/articles';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterCategory !== undefined) {
            queryParameters['filter_category'] = filterCategory;
        }

        if (filterTagset !== undefined) {
            queryParameters['filter_tagset'] = filterTagset;
        }

        if (filterTitle !== undefined) {
            queryParameters['filter_title'] = filterTitle;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceArticleResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an existing article
     * 
     * @param id The article id
     * @param articleResource The article object
     */
    public updateArticle (id: string, articleResource?: ArticleResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/content/articles/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateArticle.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: articleResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an article template
     * 
     * @param id The id of the template
     * @param articleTemplateResource The article template resource object
     */
    public updateArticleTemplate (id: string, articleTemplateResource?: TemplateResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/content/articles/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateArticleTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: articleTemplateResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ContentCommentsApiApiKeys {
}

export class ContentCommentsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: ContentCommentsApiApiKeys, value: string) {
        this.authentications[ContentCommentsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Add a new comment
     * 
     * @param commentResource The comment to be added
     */
    public addComment (commentResource?: CommentResource) : Promise<{ response: http.ClientResponse; body: CommentResource;  }> {
        const localVarPath = this.basePath + '/comments';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: commentResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CommentResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a comment
     * 
     * @param id The comment id
     */
    public deleteComment (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/comments/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteComment.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return a comment
     * 
     * @param id The comment id
     */
    public getComment (id: number) : Promise<{ response: http.ClientResponse; body: CommentResource;  }> {
        const localVarPath = this.basePath + '/comments/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getComment.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CommentResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a page of comments
     * 
     * @param context Get comments by context type
     * @param contextId Get comments by context id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getComments (context: string, contextId: number, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceCommentResource;  }> {
        const localVarPath = this.basePath + '/comments';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'context' is not null or undefined
        if (context === null || context === undefined) {
            throw new Error('Required parameter context was null or undefined when calling getComments.');
        }

        // verify required parameter 'contextId' is not null or undefined
        if (contextId === null || contextId === undefined) {
            throw new Error('Required parameter contextId was null or undefined when calling getComments.');
        }

        if (context !== undefined) {
            queryParameters['context'] = context;
        }

        if (contextId !== undefined) {
            queryParameters['context_id'] = contextId;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceCommentResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Search the comment index
     * The body is an ElasticSearch query json. Please see their &lt;a href&#x3D;&#39;https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html&#39;&gt;documentation&lt;/a&gt; for details on the format and search options
     * @param query The search query
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public searchComments (query?: any, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: CommentSearch;  }> {
        const localVarPath = this.basePath + '/comments/search';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: query,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CommentSearch;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a comment
     * 
     * @param id The comment id
     * @param content The comment content
     */
    public updateComment (id: number, content?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/comments/{id}/content'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateComment.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: content,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ContentPollsApiApiKeys {
}

export class ContentPollsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: ContentPollsApiApiKeys, value: string) {
        this.authentications[ContentPollsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Add your vote to a poll
     * 
     * @param id The poll id
     * @param answerKey The answer key
     */
    public answerPoll (id: string, answerKey?: string) : Promise<{ response: http.ClientResponse; body: PollResponseResource;  }> {
        const localVarPath = this.basePath + '/media/polls/{id}/response'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling answerPoll.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: answerKey,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PollResponseResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a new poll
     * Polls are blobs of text with titles, a category and assets. Formatting and display of the text is in the hands of the front end.
     * @param pollResource The poll object
     */
    public createPoll (pollResource?: PollResource) : Promise<{ response: http.ClientResponse; body: PollResource;  }> {
        const localVarPath = this.basePath + '/media/polls';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: pollResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PollResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a poll template
     * Poll templates define a type of poll and the properties they have
     * @param pollTemplateResource The poll template resource object
     */
    public createPollTemplate (pollTemplateResource?: TemplateResource) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/media/polls/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: pollTemplateResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an existing poll
     * 
     * @param id The poll id
     */
    public deletePoll (id: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/media/polls/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deletePoll.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a poll template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    public deletePollTemplate (id: string, cascade?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/media/polls/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deletePollTemplate.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = cascade;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single poll
     * 
     * @param id The poll id
     */
    public getPoll (id: string) : Promise<{ response: http.ClientResponse; body: PollResource;  }> {
        const localVarPath = this.basePath + '/media/polls/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getPoll.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PollResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get poll answer
     * 
     * @param id The poll id
     */
    public getPollAnswer (id: string) : Promise<{ response: http.ClientResponse; body: PollResponseResource;  }> {
        const localVarPath = this.basePath + '/media/polls/{id}/response'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getPollAnswer.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PollResponseResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single poll template
     * 
     * @param id The id of the template
     */
    public getPollTemplate (id: string) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/media/polls/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getPollTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search poll templates
     * 
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getPollTemplates (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }> {
        const localVarPath = this.basePath + '/media/polls/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search polls
     * Get a list of polls with optional filtering. Assets will not be filled in on the resources returned. Use &#39;Get a single poll&#39; to retrieve the full resource with assets for a given item as needed.
     * @param filterCategory Filter for polls from a specific category by id
     * @param filterTagset Filter for polls with specified tags (separated by comma)
     * @param filterText Filter for polls whose text contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getPolls (filterCategory?: string, filterTagset?: string, filterText?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourcePollResource;  }> {
        const localVarPath = this.basePath + '/media/polls';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterCategory !== undefined) {
            queryParameters['filter_category'] = filterCategory;
        }

        if (filterTagset !== undefined) {
            queryParameters['filter_tagset'] = filterTagset;
        }

        if (filterText !== undefined) {
            queryParameters['filter_text'] = filterText;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourcePollResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an existing poll
     * 
     * @param id The poll id
     * @param pollResource The poll object
     */
    public updatePoll (id: string, pollResource?: PollResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/media/polls/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updatePoll.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: pollResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a poll template
     * 
     * @param id The id of the template
     * @param pollTemplateResource The poll template resource object
     */
    public updatePollTemplate (id: string, pollTemplateResource?: TemplateResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/media/polls/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updatePollTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: pollTemplateResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CurrenciesApiApiKeys {
}

export class CurrenciesApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CurrenciesApiApiKeys, value: string) {
        this.authentications[CurrenciesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Create a currency
     * 
     * @param currency The currency object
     */
    public createCurrency (currency?: CurrencyResource) : Promise<{ response: http.ClientResponse; body: CurrencyResource;  }> {
        const localVarPath = this.basePath + '/currencies';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: currency,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CurrencyResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a currency
     * 
     * @param code The currency code
     */
    public deleteCurrency (code: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/currencies/{code}'
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling deleteCurrency.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search currencies
     * 
     * @param filterEnabledCurrencies Filter for alternate currencies setup explicitely in system config
     * @param filterType Filter currencies by type.  Allowable values: (&#39;virtual&#39;, &#39;real&#39;)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getCurrencies (filterEnabledCurrencies?: boolean, filterType?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceCurrencyResource;  }> {
        const localVarPath = this.basePath + '/currencies';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterEnabledCurrencies !== undefined) {
            queryParameters['filter_enabled_currencies'] = filterEnabledCurrencies;
        }

        if (filterType !== undefined) {
            queryParameters['filter_type'] = filterType;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceCurrencyResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single currency
     * 
     * @param code The currency code
     */
    public getCurrency (code: string) : Promise<{ response: http.ClientResponse; body: CurrencyResource;  }> {
        const localVarPath = this.basePath + '/currencies/{code}'
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling getCurrency.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CurrencyResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a currency
     * 
     * @param code The currency code
     * @param currency The currency object
     */
    public updateCurrency (code: string, currency?: CurrencyResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/currencies/{code}'
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling updateCurrency.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: currency,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DevicesApiApiKeys {
}

export class DevicesApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: DevicesApiApiKeys, value: string) {
        this.authentications[DevicesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Create a device
     * 
     * @param device device
     */
    public createDevice (device: DeviceResource) : Promise<{ response: http.ClientResponse; body: DeviceResource;  }> {
        const localVarPath = this.basePath + '/devices';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'device' is not null or undefined
        if (device === null || device === undefined) {
            throw new Error('Required parameter device was null or undefined when calling createDevice.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: device,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeviceResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a device
     * 
     * @param id id
     */
    public deleteDevice (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/devices/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteDevice.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single device
     * 
     * @param id id
     */
    public getDevice (id: number) : Promise<{ response: http.ClientResponse; body: DeviceResource;  }> {
        const localVarPath = this.basePath + '/devices/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getDevice.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeviceResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search devices
     * Get a list of devices with optional filtering
     * @param filterMake Filter for devices with specified make
     * @param filterModel Filter for devices with specified model
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getDevices (filterMake?: string, filterModel?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceDeviceResource;  }> {
        const localVarPath = this.basePath + '/devices';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterMake !== undefined) {
            queryParameters['filter_make'] = filterMake;
        }

        if (filterModel !== undefined) {
            queryParameters['filter_model'] = filterModel;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceDeviceResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a device
     * 
     * @param device device
     * @param id id
     */
    public updateDevice (device: DeviceResource, id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/devices/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'device' is not null or undefined
        if (device === null || device === undefined) {
            throw new Error('Required parameter device was null or undefined when calling updateDevice.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateDevice.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: device,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DispositionsApiApiKeys {
}

export class DispositionsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: DispositionsApiApiKeys, value: string) {
        this.authentications[DispositionsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Add a new disposition
     * 
     * @param disposition The new disposition record
     */
    public addDisposition (disposition?: DispositionResource) : Promise<{ response: http.ClientResponse; body: DispositionResource;  }> {
        const localVarPath = this.basePath + '/dispositions';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: disposition,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DispositionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a disposition
     * 
     * @param id The id of the disposition record
     */
    public deleteDisposition (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/dispositions/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteDisposition.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a disposition
     * 
     * @param id The id of the disposition record
     */
    public getDisposition (id: number) : Promise<{ response: http.ClientResponse; body: DispositionResource;  }> {
        const localVarPath = this.basePath + '/dispositions/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getDisposition.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DispositionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a list of disposition counts
     * 
     * @param filterContext Filter for dispositions within a context type (games, articles, polls, etc). Optionally with a specific id like filter_context&#x3D;video:47
     * @param filterOwner Filter for dispositions from a specific user by id or &#39;me&#39;
     */
    public getDispositionCounts (filterContext?: string, filterOwner?: string) : Promise<{ response: http.ClientResponse; body: Array<DispositionCount>;  }> {
        const localVarPath = this.basePath + '/dispositions/count';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterContext !== undefined) {
            queryParameters['filter_context'] = filterContext;
        }

        if (filterOwner !== undefined) {
            queryParameters['filter_owner'] = filterOwner;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<DispositionCount>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a page of dispositions
     * 
     * @param filterContext Filter for dispositions within a context type (games, articles, polls, etc). Optionally with a specific id like filter_context&#x3D;video:47
     * @param filterOwner Filter for dispositions from a specific user by id or &#39;me&#39;
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getDispositions (filterContext?: string, filterOwner?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceDispositionResource;  }> {
        const localVarPath = this.basePath + '/dispositions';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterContext !== undefined) {
            queryParameters['filter_context'] = filterContext;
        }

        if (filterOwner !== undefined) {
            queryParameters['filter_owner'] = filterOwner;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceDispositionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum FulfillmentApiApiKeys {
}

export class FulfillmentApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: FulfillmentApiApiKeys, value: string) {
        this.authentications[FulfillmentApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Create a fulfillment type
     * 
     * @param type The fulfillment type
     */
    public createFulfillmentType (type?: FulfillmentType) : Promise<{ response: http.ClientResponse; body: FulfillmentType;  }> {
        const localVarPath = this.basePath + '/store/fulfillment/types';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: type,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FulfillmentType;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a fulfillment type
     * 
     * @param id The id
     */
    public deleteFulfillmentType (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/store/fulfillment/types/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteFulfillmentType.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single fulfillment type
     * 
     * @param id The id
     */
    public getFulfillmentType (id: number) : Promise<{ response: http.ClientResponse; body: FulfillmentType;  }> {
        const localVarPath = this.basePath + '/store/fulfillment/types/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getFulfillmentType.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FulfillmentType;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search fulfillment types
     * 
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getFulfillmentTypes (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceFulfillmentType;  }> {
        const localVarPath = this.basePath + '/store/fulfillment/types';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceFulfillmentType;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a fulfillment type
     * 
     * @param id The id
     * @param fulfillmentType The fulfillment type
     */
    public updateFulfillmentType (id: number, fulfillmentType?: FulfillmentType) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/store/fulfillment/types/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateFulfillmentType.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: fulfillmentType,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum GamificationAchievementsApiApiKeys {
}

export class GamificationAchievementsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: GamificationAchievementsApiApiKeys, value: string) {
        this.authentications[GamificationAchievementsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Create a new achievement definition
     * If the definition contains a trigger event name, a BRE rule is created, so that tracking logic is executed when the triggering event occurs. If no trigger event name is specified, the user&#39;s achievement status must manually be updated via the API.
     * @param achievement The achievement definition
     */
    public createAchievement (achievement?: AchievementDefinitionResource) : Promise<{ response: http.ClientResponse; body: AchievementDefinitionResource;  }> {
        const localVarPath = this.basePath + '/achievements';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: achievement,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AchievementDefinitionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create an achievement template
     * Achievement templates define a type of achievement and the properties they have
     * @param template The achievement template to be created
     */
    public createAchievementTemplate (template?: TemplateResource) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/achievements/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: template,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an achievement definition
     * Will also disable the associated generated rule, if any.
     * @param name The name of the achievement
     */
    public deleteAchievement (name: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/achievements/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteAchievement.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an achievement template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    public deleteAchievementTemplate (id: string, cascade?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/achievements/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteAchievementTemplate.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = cascade;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single achievement definition
     * 
     * @param name The name of the achievement
     */
    public getAchievement (name: string) : Promise<{ response: http.ClientResponse; body: AchievementDefinitionResource;  }> {
        const localVarPath = this.basePath + '/achievements/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getAchievement.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AchievementDefinitionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single achievement template
     * 
     * @param id The id of the template
     */
    public getAchievementTemplate (id: string) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/achievements/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getAchievementTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search achievement templates
     * 
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getAchievementTemplates (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }> {
        const localVarPath = this.basePath + '/achievements/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the list of triggers that can be used to trigger an achievement progress update
     * 
     */
    public getAchievementTriggers () : Promise<{ response: http.ClientResponse; body: Array<BreTriggerResource>;  }> {
        const localVarPath = this.basePath + '/achievements/triggers';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<BreTriggerResource>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all achievement definitions in the system
     * 
     * @param filterTagset Filter for achievements with specified tags (separated by comma)
     * @param filterName Filter for achievements whose name contains a string
     * @param filterHidden Filter for achievements that are hidden or not
     * @param filterDerived Filter for achievements that are derived from other services
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getAchievements (filterTagset?: string, filterName?: string, filterHidden?: boolean, filterDerived?: boolean, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceAchievementDefinitionResource;  }> {
        const localVarPath = this.basePath + '/achievements';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterTagset !== undefined) {
            queryParameters['filter_tagset'] = filterTagset;
        }

        if (filterName !== undefined) {
            queryParameters['filter_name'] = filterName;
        }

        if (filterHidden !== undefined) {
            queryParameters['filter_hidden'] = filterHidden;
        }

        if (filterDerived !== undefined) {
            queryParameters['filter_derived'] = filterDerived;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceAchievementDefinitionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of derived achievements
     * Used by other services that depend on achievements
     * @param name The name of the derived achievement
     */
    public getDerivedAchievements (name: string) : Promise<{ response: http.ClientResponse; body: Array<AchievementDefinitionResource>;  }> {
        const localVarPath = this.basePath + '/achievements/derived/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getDerivedAchievements.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<AchievementDefinitionResource>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve progress on a given achievement for a given user
     * Assets will not be filled in on the resources returned. Use &#39;Get a single poll&#39; to retrieve the full resource with assets for a given item as needed.
     * @param userId The user&#39;s id
     * @param achievementName The achievement&#39;s name
     */
    public getUserAchievementProgress (userId: number, achievementName: string) : Promise<{ response: http.ClientResponse; body: UserAchievementGroupResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/achievements/{achievement_name}'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'achievement_name' + '}', String(achievementName));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserAchievementProgress.');
        }

        // verify required parameter 'achievementName' is not null or undefined
        if (achievementName === null || achievementName === undefined) {
            throw new Error('Required parameter achievementName was null or undefined when calling getUserAchievementProgress.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserAchievementGroupResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve progress on achievements for a given user
     * Assets will not be filled in on the resources returned. Use &#39;Get a single poll&#39; to retrieve the full resource with assets for a given item as needed.
     * @param userId The user&#39;s id
     * @param filterAchievementDerived Filter for achievements that are derived from other services
     * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
     * @param filterAchievementName Filter for achievements whose name contains a string
     * @param filterAchievementHidden Filter for achievements that are hidden or not
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getUserAchievementsProgress (userId: number, filterAchievementDerived?: boolean, filterAchievementTagset?: string, filterAchievementName?: string, filterAchievementHidden?: boolean, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceUserAchievementGroupResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/achievements'
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserAchievementsProgress.');
        }

        if (filterAchievementDerived !== undefined) {
            queryParameters['filter_achievement_derived'] = filterAchievementDerived;
        }

        if (filterAchievementTagset !== undefined) {
            queryParameters['filter_achievement_tagset'] = filterAchievementTagset;
        }

        if (filterAchievementName !== undefined) {
            queryParameters['filter_achievement_name'] = filterAchievementName;
        }

        if (filterAchievementHidden !== undefined) {
            queryParameters['filter_achievement_hidden'] = filterAchievementHidden;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceUserAchievementGroupResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve progress on a given achievement for all users
     * Assets will not be filled in on the resources returned. Use &#39;Get single achievement progress for user&#39; to retrieve the full resource with assets for a given user as needed.
     * @param achievementName The achievement&#39;s name
     * @param filterAchievementDerived Filter for achievements that are derived from other services
     * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
     * @param filterAchievementHidden Filter for achievements that are hidden or not
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getUsersAchievementProgress (achievementName: string, filterAchievementDerived?: boolean, filterAchievementTagset?: string, filterAchievementHidden?: boolean, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceUserAchievementGroupResource;  }> {
        const localVarPath = this.basePath + '/users/achievements/{achievement_name}'
            .replace('{' + 'achievement_name' + '}', String(achievementName));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'achievementName' is not null or undefined
        if (achievementName === null || achievementName === undefined) {
            throw new Error('Required parameter achievementName was null or undefined when calling getUsersAchievementProgress.');
        }

        if (filterAchievementDerived !== undefined) {
            queryParameters['filter_achievement_derived'] = filterAchievementDerived;
        }

        if (filterAchievementTagset !== undefined) {
            queryParameters['filter_achievement_tagset'] = filterAchievementTagset;
        }

        if (filterAchievementHidden !== undefined) {
            queryParameters['filter_achievement_hidden'] = filterAchievementHidden;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceUserAchievementGroupResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve progress on achievements for all users
     * Assets will not be filled in on the resources returned. Use &#39;Get single achievement progress for user&#39; to retrieve the full resource with assets for a given user as needed.
     * @param filterAchievementDerived Filter for achievements that are derived from other services
     * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
     * @param filterAchievementName Filter for achievements whose name contains a string
     * @param filterAchievementHidden Filter for achievements that are hidden or not
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getUsersAchievementsProgress (filterAchievementDerived?: boolean, filterAchievementTagset?: string, filterAchievementName?: string, filterAchievementHidden?: boolean, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceUserAchievementGroupResource;  }> {
        const localVarPath = this.basePath + '/users/achievements';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterAchievementDerived !== undefined) {
            queryParameters['filter_achievement_derived'] = filterAchievementDerived;
        }

        if (filterAchievementTagset !== undefined) {
            queryParameters['filter_achievement_tagset'] = filterAchievementTagset;
        }

        if (filterAchievementName !== undefined) {
            queryParameters['filter_achievement_name'] = filterAchievementName;
        }

        if (filterAchievementHidden !== undefined) {
            queryParameters['filter_achievement_hidden'] = filterAchievementHidden;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceUserAchievementGroupResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an achievement definition
     * The existing generated rule, if any, will be deleted. A new rule will be created if a trigger event name is specified in the new version.
     * @param name The name of the achievement
     * @param achievement The achievement definition
     */
    public updateAchievement (name: string, achievement?: AchievementDefinitionResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/achievements/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling updateAchievement.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: achievement,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update or create an achievement progress record for a user
     * If no progress record yet exists for the user, it will be created. Otherwise it will be updated. If progress meets or exceeds the achievement&#39;s max_value it will be marked as earned and a BRE event will be triggered for the &lt;code&gt;BreAchievementEarnedTrigger&lt;/code&gt;.
     * @param userId The user&#39;s id
     * @param achievementName The achievement&#39;s name
     * @param request The progress update details
     */
    public updateAchievementProgress (userId: number, achievementName: string, request?: AchievementProgressUpdateRequest) : Promise<{ response: http.ClientResponse; body: UserAchievementGroupResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/achievements/{achievement_name}'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'achievement_name' + '}', String(achievementName));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling updateAchievementProgress.');
        }

        // verify required parameter 'achievementName' is not null or undefined
        if (achievementName === null || achievementName === undefined) {
            throw new Error('Required parameter achievementName was null or undefined when calling updateAchievementProgress.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: request,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserAchievementGroupResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an achievement template
     * 
     * @param id The id of the template
     * @param template The updated template
     */
    public updateAchievementTemplate (id: string, template?: TemplateResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/achievements/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateAchievementTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: template,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum GamificationLeaderboardsApiApiKeys {
}

export class GamificationLeaderboardsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: GamificationLeaderboardsApiApiKeys, value: string) {
        this.authentications[GamificationLeaderboardsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Retrieves leaderboard details and paginated entries
     * The context type identifies the type of entity (i.e., &#39;activity&#39;) being tracked on the leaderboard. The context ID is the unique ID of the actual entity tracked by the leaderboard.
     * @param contextType The context type for the leaderboard
     * @param contextId The context id for the leaderboard
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getLeaderboard (contextType: string, contextId: string, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: LeaderboardResource;  }> {
        const localVarPath = this.basePath + '/leaderboards/{context_type}/{context_id}'
            .replace('{' + 'context_type' + '}', String(contextType))
            .replace('{' + 'context_id' + '}', String(contextId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'contextType' is not null or undefined
        if (contextType === null || contextType === undefined) {
            throw new Error('Required parameter contextType was null or undefined when calling getLeaderboard.');
        }

        // verify required parameter 'contextId' is not null or undefined
        if (contextId === null || contextId === undefined) {
            throw new Error('Required parameter contextId was null or undefined when calling getLeaderboard.');
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LeaderboardResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a specific user entry with rank
     * The context type identifies the type of entity (i.e., &#39;activity&#39;) being tracked on the leaderboard. The context ID is the unique ID of the actual entity tracked by the leaderboard
     * @param contextType The context type for the leaderboard
     * @param contextId The context id for the leaderboard
     * @param id The id of a user
     */
    public getLeaderboardRank (contextType: string, contextId: string, id: string) : Promise<{ response: http.ClientResponse; body: LeaderboardEntryResource;  }> {
        const localVarPath = this.basePath + '/leaderboards/{context_type}/{context_id}/users/{id}/rank'
            .replace('{' + 'context_type' + '}', String(contextType))
            .replace('{' + 'context_id' + '}', String(contextId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'contextType' is not null or undefined
        if (contextType === null || contextType === undefined) {
            throw new Error('Required parameter contextType was null or undefined when calling getLeaderboardRank.');
        }

        // verify required parameter 'contextId' is not null or undefined
        if (contextId === null || contextId === undefined) {
            throw new Error('Required parameter contextId was null or undefined when calling getLeaderboardRank.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getLeaderboardRank.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LeaderboardEntryResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of available leaderboard strategy names
     * 
     */
    public getLeaderboardStrategies () : Promise<{ response: http.ClientResponse; body: Array<string>;  }> {
        const localVarPath = this.basePath + '/leaderboards/strategies';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<string>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum GamificationLevelingApiApiKeys {
}

export class GamificationLevelingApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: GamificationLevelingApiApiKeys, value: string) {
        this.authentications[GamificationLevelingApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Create a level schema
     * 
     * @param level The level schema definition
     */
    public createLevel (level?: LevelingResource) : Promise<{ response: http.ClientResponse; body: LevelingResource;  }> {
        const localVarPath = this.basePath + '/leveling';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: level,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LevelingResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a level
     * 
     * @param name The level schema name
     */
    public deleteLevel (name: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/leveling/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteLevel.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a level
     * 
     * @param name The level schema name
     */
    public getLevel (name: string) : Promise<{ response: http.ClientResponse; body: LevelingResource;  }> {
        const localVarPath = this.basePath + '/leveling/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getLevel.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LevelingResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the list of triggers that can be used to trigger a leveling progress update
     * 
     */
    public getLevelTriggers () : Promise<{ response: http.ClientResponse; body: Array<BreTriggerResource>;  }> {
        const localVarPath = this.basePath + '/leveling/triggers';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<BreTriggerResource>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search levels
     * Get a list of levels schemas with optional filtering
     * @param filterName Filter for level schemas whose name contains a given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getLevels (filterName?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceLevelingResource;  }> {
        const localVarPath = this.basePath + '/leveling';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterName !== undefined) {
            queryParameters['filter_name'] = filterName;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceLevelingResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a user&#39;s progress for a given level schema
     * 
     * @param userId The id of the user
     * @param name The level schema name
     */
    public getUserLevel (userId: number, name: string) : Promise<{ response: http.ClientResponse; body: UserLevelingResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/leveling/{name}'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserLevel.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getUserLevel.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserLevelingResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a user&#39;s progress for all level schemas
     * 
     * @param userId The id of the user
     */
    public getUserLevels (userId: number) : Promise<{ response: http.ClientResponse; body: PageResourceUserLevelingResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/leveling'
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserLevels.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceUserLevelingResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a level
     * 
     * @param name The level schema name
     * @param newLevel The level schema definition
     */
    public updateLevel (name: string, newLevel?: LevelingResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/leveling/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling updateLevel.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: newLevel,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update or create a leveling progress record for a user
     * If no progress record yet exists for the user, it will be created. Otherwise it will be updated. If progress meets or exceeds the level&#39;s max_value it will be marked as earned and a BRE event will be triggered for the &lt;code&gt;BreAchievementEarnedTrigger&lt;/code&gt;.
     * @param userId The id of the user
     * @param name The level schema name
     * @param progress The current progress amount
     */
    public updateUserLevel (userId: number, name: string, progress?: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/leveling/{name}'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling updateUserLevel.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling updateUserLevel.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: progress,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum GamificationMetricsApiApiKeys {
}

export class GamificationMetricsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: GamificationMetricsApiApiKeys, value: string) {
        this.authentications[GamificationMetricsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Add a metric
     * Post a new score/stat for an activity occurrence without ending the occurrence itself
     * @param metric The new metric
     */
    public addMetric (metric?: MetricResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/metrics';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: metric,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum GamificationTriviaApiApiKeys {
}

export class GamificationTriviaApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: GamificationTriviaApiApiKeys, value: string) {
        this.authentications[GamificationTriviaApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Add an answer to a question
     * 
     * @param questionId The id of the question
     * @param answer The new answer
     */
    public addQuestionAnswers (questionId: string, answer?: AnswerResource) : Promise<{ response: http.ClientResponse; body: AnswerResource;  }> {
        const localVarPath = this.basePath + '/trivia/questions/{question_id}/answers'
            .replace('{' + 'question_id' + '}', String(questionId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'questionId' is not null or undefined
        if (questionId === null || questionId === undefined) {
            throw new Error('Required parameter questionId was null or undefined when calling addQuestionAnswers.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: answer,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AnswerResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Add a tag to a question
     * 
     * @param id The id of the question
     * @param tag The new tag
     */
    public addQuestionTag (id: string, tag?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/trivia/questions/{id}/tags'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling addQuestionTag.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: tag,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Add a tag to a batch of questions
     * All questions that dont&#39;t have the tag and match filters will have it added. The returned number is the number of questions updated.
     * @param tag The tag to add
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTag Filter for questions with specified tag
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    public addTagToQuestionsBatch (tag?: string, filterSearch?: string, filterIdset?: string, filterCategory?: string, filterTag?: string, filterTagset?: string, filterType?: string, filterPublished?: boolean, filterImportId?: number) : Promise<{ response: http.ClientResponse; body: number;  }> {
        const localVarPath = this.basePath + '/trivia/questions/tags';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterSearch !== undefined) {
            queryParameters['filter_search'] = filterSearch;
        }

        if (filterIdset !== undefined) {
            queryParameters['filter_idset'] = filterIdset;
        }

        if (filterCategory !== undefined) {
            queryParameters['filter_category'] = filterCategory;
        }

        if (filterTag !== undefined) {
            queryParameters['filter_tag'] = filterTag;
        }

        if (filterTagset !== undefined) {
            queryParameters['filter_tagset'] = filterTagset;
        }

        if (filterType !== undefined) {
            queryParameters['filter_type'] = filterType;
        }

        if (filterPublished !== undefined) {
            queryParameters['filter_published'] = filterPublished;
        }

        if (filterImportId !== undefined) {
            queryParameters['filter_import_id'] = filterImportId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: tag,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: number;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create an import job
     * Set up a job to import a set of trivia questions from a cvs file at a remote url. the file will be validated asynchronously but will not be processed until started manually with the process endpoint.
     * @param request The new import job
     */
    public createImportJob (request?: ImportJobResource) : Promise<{ response: http.ClientResponse; body: ImportJobResource;  }> {
        const localVarPath = this.basePath + '/trivia/import';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: request,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ImportJobResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a question
     * 
     * @param question The new question
     */
    public createQuestion (question?: QuestionResource) : Promise<{ response: http.ClientResponse; body: QuestionResource;  }> {
        const localVarPath = this.basePath + '/trivia/questions';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: question,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: QuestionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a question template
     * Question templates define a type of question and the properties they have
     * @param questionTemplateResource The question template resource object
     */
    public createQuestionTemplate (questionTemplateResource?: QuestionTemplateResource) : Promise<{ response: http.ClientResponse; body: QuestionTemplateResource;  }> {
        const localVarPath = this.basePath + '/trivia/questions/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: questionTemplateResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: QuestionTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an import job
     * Also deletes all questions that were imported by it
     * @param id The id of the job
     */
    public deleteImportJob (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/trivia/import/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteImportJob.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a question
     * 
     * @param id The id of the question
     */
    public deleteQuestion (id: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/trivia/questions/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteQuestion.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Remove an answer from a question
     * 
     * @param questionId The id of the question
     * @param id The id of the answer
     */
    public deleteQuestionAnswers (questionId: string, id: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/trivia/questions/{question_id}/answers/{id}'
            .replace('{' + 'question_id' + '}', String(questionId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'questionId' is not null or undefined
        if (questionId === null || questionId === undefined) {
            throw new Error('Required parameter questionId was null or undefined when calling deleteQuestionAnswers.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteQuestionAnswers.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a question template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    public deleteQuestionTemplate (id: string, cascade?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/trivia/questions/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteQuestionTemplate.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = cascade;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get an import job
     * 
     * @param id The id of the job
     */
    public getImportJob (id: number) : Promise<{ response: http.ClientResponse; body: ImportJobResource;  }> {
        const localVarPath = this.basePath + '/trivia/import/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getImportJob.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ImportJobResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of import job
     * 
     * @param filterVendor Filter for jobs by vendor id
     * @param filterCategory Filter for jobs by category id
     * @param filterName Filter for jobs which name *STARTS* with the given string
     * @param filterStatus Filter for jobs that are in a specific set of statuses (comma separated)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getImportJobs (filterVendor?: string, filterCategory?: string, filterName?: string, filterStatus?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceImportJobResource;  }> {
        const localVarPath = this.basePath + '/trivia/import';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterVendor !== undefined) {
            queryParameters['filter_vendor'] = filterVendor;
        }

        if (filterCategory !== undefined) {
            queryParameters['filter_category'] = filterCategory;
        }

        if (filterName !== undefined) {
            queryParameters['filter_name'] = filterName;
        }

        if (filterStatus !== undefined) {
            queryParameters['filter_status'] = filterStatus;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceImportJobResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single question
     * 
     * @param id The id of the question
     */
    public getQuestion (id: string) : Promise<{ response: http.ClientResponse; body: QuestionResource;  }> {
        const localVarPath = this.basePath + '/trivia/questions/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getQuestion.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: QuestionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get an answer for a question
     * 
     * @param questionId The id of the question
     * @param id The id of the answer
     */
    public getQuestionAnswer (questionId: string, id: string) : Promise<{ response: http.ClientResponse; body: AnswerResource;  }> {
        const localVarPath = this.basePath + '/trivia/questions/{question_id}/answers/{id}'
            .replace('{' + 'question_id' + '}', String(questionId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'questionId' is not null or undefined
        if (questionId === null || questionId === undefined) {
            throw new Error('Required parameter questionId was null or undefined when calling getQuestionAnswer.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getQuestionAnswer.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AnswerResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List the answers available for a question
     * 
     * @param questionId The id of the question
     */
    public getQuestionAnswers (questionId: string) : Promise<{ response: http.ClientResponse; body: Array<AnswerResource>;  }> {
        const localVarPath = this.basePath + '/trivia/questions/{question_id}/answers'
            .replace('{' + 'question_id' + '}', String(questionId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'questionId' is not null or undefined
        if (questionId === null || questionId === undefined) {
            throw new Error('Required parameter questionId was null or undefined when calling getQuestionAnswers.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<AnswerResource>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List question deltas in ascending order of updated date
     * The &#39;since&#39; parameter is important to avoid getting a full list of all questions. Implementors should make sure they pass the updated date of the last resource loaded, not the date of the last request, in order to avoid gaps
     * @param since Timestamp in seconds
     */
    public getQuestionDeltas (since?: number) : Promise<{ response: http.ClientResponse; body: Array<DeltaResource>;  }> {
        const localVarPath = this.basePath + '/trivia/questions/delta';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (since !== undefined) {
            queryParameters['since'] = since;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<DeltaResource>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List the tags for a question
     * 
     * @param id The id of the question
     */
    public getQuestionTags (id: string) : Promise<{ response: http.ClientResponse; body: Array<string>;  }> {
        const localVarPath = this.basePath + '/trivia/questions/{id}/tags'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getQuestionTags.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<string>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search tags by the beginning of the string
     * For performance reasons, search &amp; category filters are mutually exclusive. If category is specified, search filter will be ignored in order to do fast matches for typeahead.
     * @param filterSearch Filter for tags starting with the given text
     * @param filterCategory Filter for tags on questions from a specific category
     * @param filterImportId Filter for tags on questions from a specific import job
     */
    public getQuestionTags1 (filterSearch?: string, filterCategory?: string, filterImportId?: number) : Promise<{ response: http.ClientResponse; body: Collectionstring;  }> {
        const localVarPath = this.basePath + '/trivia/tags';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterSearch !== undefined) {
            queryParameters['filter_search'] = filterSearch;
        }

        if (filterCategory !== undefined) {
            queryParameters['filter_category'] = filterCategory;
        }

        if (filterImportId !== undefined) {
            queryParameters['filter_import_id'] = filterImportId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Collectionstring;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single question template
     * 
     * @param id The id of the template
     */
    public getQuestionTemplate (id: string) : Promise<{ response: http.ClientResponse; body: QuestionTemplateResource;  }> {
        const localVarPath = this.basePath + '/trivia/questions/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getQuestionTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: QuestionTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search question templates
     * 
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getQuestionTemplates (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceQuestionTemplateResource;  }> {
        const localVarPath = this.basePath + '/trivia/questions/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceQuestionTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search questions
     * 
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    public getQuestions (size?: number, page?: number, order?: string, filterSearch?: string, filterIdset?: string, filterCategory?: string, filterTagset?: string, filterType?: string, filterPublished?: boolean, filterImportId?: number) : Promise<{ response: http.ClientResponse; body: PageResourceQuestionResource;  }> {
        const localVarPath = this.basePath + '/trivia/questions';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        if (filterSearch !== undefined) {
            queryParameters['filter_search'] = filterSearch;
        }

        if (filterIdset !== undefined) {
            queryParameters['filter_idset'] = filterIdset;
        }

        if (filterCategory !== undefined) {
            queryParameters['filter_category'] = filterCategory;
        }

        if (filterTagset !== undefined) {
            queryParameters['filter_tagset'] = filterTagset;
        }

        if (filterType !== undefined) {
            queryParameters['filter_type'] = filterType;
        }

        if (filterPublished !== undefined) {
            queryParameters['filter_published'] = filterPublished;
        }

        if (filterImportId !== undefined) {
            queryParameters['filter_import_id'] = filterImportId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceQuestionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Count questions based on filters
     * This is also provided by the list endpoint so you don&#39;t need to call this for pagination purposes
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTag Filter for questions with specified tag
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     */
    public getQuestionsCount (filterSearch?: string, filterIdset?: string, filterCategory?: string, filterTag?: string, filterTagset?: string, filterType?: string, filterPublished?: boolean) : Promise<{ response: http.ClientResponse; body: number;  }> {
        const localVarPath = this.basePath + '/trivia/questions/count';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterSearch !== undefined) {
            queryParameters['filter_search'] = filterSearch;
        }

        if (filterIdset !== undefined) {
            queryParameters['filter_idset'] = filterIdset;
        }

        if (filterCategory !== undefined) {
            queryParameters['filter_category'] = filterCategory;
        }

        if (filterTag !== undefined) {
            queryParameters['filter_tag'] = filterTag;
        }

        if (filterTagset !== undefined) {
            queryParameters['filter_tagset'] = filterTagset;
        }

        if (filterType !== undefined) {
            queryParameters['filter_type'] = filterType;
        }

        if (filterPublished !== undefined) {
            queryParameters['filter_published'] = filterPublished;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: number;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Start processing an import job
     * Will process the CSV file and add new questions asynchronously. The status of the job must be &#39;VALID&#39;.
     * @param id The id of the job
     * @param publishNow Whether the new questions should be published live immediately
     */
    public processImportJob (id: number, publishNow: boolean) : Promise<{ response: http.ClientResponse; body: ImportJobResource;  }> {
        const localVarPath = this.basePath + '/trivia/import/{id}/process'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling processImportJob.');
        }

        // verify required parameter 'publishNow' is not null or undefined
        if (publishNow === null || publishNow === undefined) {
            throw new Error('Required parameter publishNow was null or undefined when calling processImportJob.');
        }

        if (publishNow !== undefined) {
            queryParameters['publish_now'] = publishNow;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ImportJobResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Remove a tag from a question
     * 
     * @param id The id of the question
     * @param tag The tag to remove
     */
    public removeQuestionTag (id: string, tag: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/trivia/questions/{id}/tags/{tag}'
            .replace('{' + 'id' + '}', String(id))
            .replace('{' + 'tag' + '}', String(tag));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling removeQuestionTag.');
        }

        // verify required parameter 'tag' is not null or undefined
        if (tag === null || tag === undefined) {
            throw new Error('Required parameter tag was null or undefined when calling removeQuestionTag.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Remove a tag from a batch of questions
     * ll questions that have the tag and match filters will have it removed. The returned number is the number of questions updated.
     * @param tag The tag to remove
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTag Filter for questions with specified tag
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    public removeTagToQuestionsBatch (tag: string, filterSearch?: string, filterIdset?: string, filterCategory?: string, filterTag?: string, filterTagset?: string, filterType?: string, filterPublished?: boolean, filterImportId?: number) : Promise<{ response: http.ClientResponse; body: number;  }> {
        const localVarPath = this.basePath + '/trivia/questions/tags/{tag}'
            .replace('{' + 'tag' + '}', String(tag));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tag' is not null or undefined
        if (tag === null || tag === undefined) {
            throw new Error('Required parameter tag was null or undefined when calling removeTagToQuestionsBatch.');
        }

        if (filterSearch !== undefined) {
            queryParameters['filter_search'] = filterSearch;
        }

        if (filterIdset !== undefined) {
            queryParameters['filter_idset'] = filterIdset;
        }

        if (filterCategory !== undefined) {
            queryParameters['filter_category'] = filterCategory;
        }

        if (filterTag !== undefined) {
            queryParameters['filter_tag'] = filterTag;
        }

        if (filterTagset !== undefined) {
            queryParameters['filter_tagset'] = filterTagset;
        }

        if (filterType !== undefined) {
            queryParameters['filter_type'] = filterType;
        }

        if (filterPublished !== undefined) {
            queryParameters['filter_published'] = filterPublished;
        }

        if (filterImportId !== undefined) {
            queryParameters['filter_import_id'] = filterImportId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: number;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an import job
     * Changes should be made before process is started for there to be any effect.
     * @param id The id of the job
     * @param request The updated job
     */
    public updateImportJob (id: number, request?: ImportJobResource) : Promise<{ response: http.ClientResponse; body: ImportJobResource;  }> {
        const localVarPath = this.basePath + '/trivia/import/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateImportJob.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: request,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ImportJobResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a question
     * 
     * @param id The id of the question
     * @param question The updated question
     */
    public updateQuestion (id: string, question?: QuestionResource) : Promise<{ response: http.ClientResponse; body: QuestionResource;  }> {
        const localVarPath = this.basePath + '/trivia/questions/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateQuestion.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: question,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: QuestionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an answer for a question
     * 
     * @param questionId The id of the question
     * @param id The id of the answer
     * @param answer The updated answer
     */
    public updateQuestionAnswer (questionId: string, id: string, answer?: AnswerResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/trivia/questions/{question_id}/answers/{id}'
            .replace('{' + 'question_id' + '}', String(questionId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'questionId' is not null or undefined
        if (questionId === null || questionId === undefined) {
            throw new Error('Required parameter questionId was null or undefined when calling updateQuestionAnswer.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateQuestionAnswer.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: answer,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a question template
     * 
     * @param id The id of the template
     * @param questionTemplateResource The question template resource object
     */
    public updateQuestionTemplate (id: string, questionTemplateResource?: QuestionTemplateResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/trivia/questions/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateQuestionTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: questionTemplateResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Bulk update questions
     * Will update all questions that match filters used (or all questions in system if no filters used). Body should match a question resource with only those properties you wish to set. Null values will be ignored. Returned number is how many were updated.
     * @param question New values for a set of question fields
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    public updateQuestionsInBulk (question?: QuestionResource, filterSearch?: string, filterIdset?: string, filterCategory?: string, filterTagset?: string, filterType?: string, filterPublished?: boolean, filterImportId?: number) : Promise<{ response: http.ClientResponse; body: number;  }> {
        const localVarPath = this.basePath + '/trivia/questions';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterSearch !== undefined) {
            queryParameters['filter_search'] = filterSearch;
        }

        if (filterIdset !== undefined) {
            queryParameters['filter_idset'] = filterIdset;
        }

        if (filterCategory !== undefined) {
            queryParameters['filter_category'] = filterCategory;
        }

        if (filterTagset !== undefined) {
            queryParameters['filter_tagset'] = filterTagset;
        }

        if (filterType !== undefined) {
            queryParameters['filter_type'] = filterType;
        }

        if (filterPublished !== undefined) {
            queryParameters['filter_published'] = filterPublished;
        }

        if (filterImportId !== undefined) {
            queryParameters['filter_import_id'] = filterImportId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: question,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: number;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum InvoicesApiApiKeys {
}

export class InvoicesApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: InvoicesApiApiKeys, value: string) {
        this.authentications[InvoicesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Create an invoice
     * Create an invoice(s) by providing a cart GUID. Note that there may be multiple invoices created, one per vendor.
     * @param req Invoice to be created
     */
    public createInvoice (req?: InvoiceCreateRequest) : Promise<{ response: http.ClientResponse; body: Array<InvoiceResource>;  }> {
        const localVarPath = this.basePath + '/invoices';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: req,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<InvoiceResource>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an invoice
     * 
     * @param id The id of the invoice
     */
    public getInvoice (id: number) : Promise<{ response: http.ClientResponse; body: InvoiceResource;  }> {
        const localVarPath = this.basePath + '/invoices/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getInvoice.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InvoiceResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List invoice logs
     * 
     * @param id The id of the invoice
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getInvoiceLogs (id: number, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceInvoiceLogEntry;  }> {
        const localVarPath = this.basePath + '/invoices/{id}/logs'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getInvoiceLogs.');
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceInvoiceLogEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve invoices
     * Without INVOICES_ADMIN permission the results are automatically filtered for only the logged in user&#39;s invoices. It is recomended however that filter_user be added to avoid issues for admin users accidentally getting additional invoices.
     * @param filterUser The id of a user to get invoices for. Automtically added if not being called with admin permissions.
     * @param filterEmail Filters invoices by customer&#39;s email. Admins only.
     * @param filterFulfillmentStatus Filters invoices by fulfillment status type. Can be a comma separated list of statuses
     * @param filterPaymentStatus Filters invoices by payment status type. Can be a comma separated list of statuses
     * @param filterItemName Filters invoices by item name containing the given string
     * @param filterCreatedDate Filters invoices by creation date. Multiple values possible for range search. Format: filter_created_date&#x3D;OP,ts&amp;... where OP in (GT, LT, GOE, LOE, EQ) and ts is a unix timestamp in seconds. Ex: filter_created_date&#x3D;GT,1452154258,LT,1554254874
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getInvoices (filterUser?: number, filterEmail?: string, filterFulfillmentStatus?: string, filterPaymentStatus?: string, filterItemName?: string, filterCreatedDate?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceInvoiceResource;  }> {
        const localVarPath = this.basePath + '/invoices';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterUser !== undefined) {
            queryParameters['filter_user'] = filterUser;
        }

        if (filterEmail !== undefined) {
            queryParameters['filter_email'] = filterEmail;
        }

        if (filterFulfillmentStatus !== undefined) {
            queryParameters['filter_fulfillment_status'] = filterFulfillmentStatus;
        }

        if (filterPaymentStatus !== undefined) {
            queryParameters['filter_payment_status'] = filterPaymentStatus;
        }

        if (filterItemName !== undefined) {
            queryParameters['filter_item_name'] = filterItemName;
        }

        if (filterCreatedDate !== undefined) {
            queryParameters['filter_created_date'] = filterCreatedDate;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceInvoiceResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Lists available fulfillment statuses
     * 
     */
    public listFulFillmentStatuses () : Promise<{ response: http.ClientResponse; body: Array<string>;  }> {
        const localVarPath = this.basePath + '/invoices/fulfillment-statuses';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<string>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Lists available payment statuses
     * 
     */
    public listPaymentStatuses () : Promise<{ response: http.ClientResponse; body: Array<string>;  }> {
        const localVarPath = this.basePath + '/invoices/payment-statuses';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<string>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Trigger payment of an invoice
     * 
     * @param id The id of the invoice
     * @param request Payment info
     */
    public payInvoice (id: number, request?: PayBySavedMethodRequest) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/invoices/{id}/payments'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling payInvoice.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: request,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set the fulfillment status of an invoice item
     * This allows external fulfillment systems to report success or failure. Fulfillment status changes are restricted by a specific flow determining which status can lead to which.
     * @param id The id of the invoice
     * @param sku The sku of an item in the invoice
     * @param status The new fulfillment status for the item. Additional options may be available based on configuration.  Allowable values:  &#39;unfulfilled&#39;, &#39;fulfilled&#39;, &#39;not fulfillable&#39;, &#39;failed&#39;, &#39;processing&#39;, &#39;failed_permanent&#39;, &#39;delayed&#39;
     */
    public setInvoiceItemFulfillmentStatus (id: number, sku: string, status: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/invoices/{id}/items/{sku}/fulfillment-status'
            .replace('{' + 'id' + '}', String(id))
            .replace('{' + 'sku' + '}', String(sku));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling setInvoiceItemFulfillmentStatus.');
        }

        // verify required parameter 'sku' is not null or undefined
        if (sku === null || sku === undefined) {
            throw new Error('Required parameter sku was null or undefined when calling setInvoiceItemFulfillmentStatus.');
        }

        // verify required parameter 'status' is not null or undefined
        if (status === null || status === undefined) {
            throw new Error('Required parameter status was null or undefined when calling setInvoiceItemFulfillmentStatus.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: status,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set the order notes of an invoice
     * 
     * @param id The id of the invoice
     * @param orderNotes Payment status info
     */
    public setOrderNotes (id: number, orderNotes?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/invoices/{id}/order-notes'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling setOrderNotes.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: orderNotes,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set the payment status of an invoice
     * This may trigger fulfillment if setting the status to &#39;paid&#39;. This is mainly intended to support external payment systems that cannot be incorporated into the payment method system. Payment status changes are restricted by a specific flow determining which status can lead to which.
     * @param id The id of the invoice
     * @param request Payment status info
     */
    public setPaymentStatusUsingPUT (id: number, request?: InvoicePaymentStatusRequest) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/invoices/{id}/payment-status'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling setPaymentStatusUsingPUT.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: request,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set or update billing info
     * 
     * @param id The id of the invoice
     * @param billingInfoRequest Address info
     */
    public updateBillingInfo (id: number, billingInfoRequest?: AddressResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/invoices/{id}/billing-address'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateBillingInfo.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: billingInfoRequest,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LocationsApiApiKeys {
}

export class LocationsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: LocationsApiApiKeys, value: string) {
        this.authentications[LocationsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Get a list of a state&#39;s cities
     * 
     * @param countryCodeIso3 The iso3 code of the country
     * @param stateCode The code of the state
     */
    public getCities (countryCodeIso3: string, stateCode: string) : Promise<{ response: http.ClientResponse; body: Array<CityResource>;  }> {
        const localVarPath = this.basePath + '/location/countries/{country_code_iso3}/states/{state_code}/cities'
            .replace('{' + 'country_code_iso3' + '}', String(countryCodeIso3))
            .replace('{' + 'state_code' + '}', String(stateCode));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'countryCodeIso3' is not null or undefined
        if (countryCodeIso3 === null || countryCodeIso3 === undefined) {
            throw new Error('Required parameter countryCodeIso3 was null or undefined when calling getCities.');
        }

        // verify required parameter 'stateCode' is not null or undefined
        if (stateCode === null || stateCode === undefined) {
            throw new Error('Required parameter stateCode was null or undefined when calling getCities.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<CityResource>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of countries
     * 
     */
    public getCountries1 () : Promise<{ response: http.ClientResponse; body: Array<CountryResource>;  }> {
        const localVarPath = this.basePath + '/location/countries';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<CountryResource>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of a country&#39;s states
     * 
     * @param countryCodeIso3 The iso3 code of the country
     */
    public getCountries2 (countryCodeIso3: string) : Promise<{ response: http.ClientResponse; body: Array<StateResource>;  }> {
        const localVarPath = this.basePath + '/location/countries/{country_code_iso3}/states'
            .replace('{' + 'country_code_iso3' + '}', String(countryCodeIso3));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'countryCodeIso3' is not null or undefined
        if (countryCodeIso3 === null || countryCodeIso3 === undefined) {
            throw new Error('Required parameter countryCodeIso3 was null or undefined when calling getCountries2.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<StateResource>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the iso3 code of your country
     * Determined by geo ip location
     */
    public getCountryByGeoLocation () : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/location/geolocation/country';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the currency information of your country
     * Determined by geo ip location, currency to country mapping and a fallback setting
     */
    public getCurrencyByGeoLocation () : Promise<{ response: http.ClientResponse; body: CurrencyResource;  }> {
        const localVarPath = this.basePath + '/location/geolocation/currency';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CurrencyResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LogsApiApiKeys {
}

export class LogsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: LogsApiApiKeys, value: string) {
        this.authentications[LogsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Add a user log entry
     * 
     * @param logEntry The user log entry to be added
     */
    public addUserLog (logEntry?: UserActionLog) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/audit/logs';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: logEntry,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get an existing BRE event log entry by id
     * 
     * @param id The BRE event log entry id
     */
    public getBREEventLog (id: string) : Promise<{ response: http.ClientResponse; body: BreEventLog;  }> {
        const localVarPath = this.basePath + '/bre/logs/event-log/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getBREEventLog.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BreEventLog;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a list of BRE event log entries
     * 
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the event log start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEventName Filter event logs by event name
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getBREEventLogs (filterStartDate?: string, filterEventName?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceBreEventLog;  }> {
        const localVarPath = this.basePath + '/bre/logs/event-log';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterStartDate !== undefined) {
            queryParameters['filter_start_date'] = filterStartDate;
        }

        if (filterEventName !== undefined) {
            queryParameters['filter_event_name'] = filterEventName;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceBreEventLog;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get an existing forward log entry by id
     * 
     * @param id The forward log entry id
     */
    public getBREForwardLog (id: string) : Promise<{ response: http.ClientResponse; body: ForwardLog;  }> {
        const localVarPath = this.basePath + '/bre/logs/forward-log/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getBREForwardLog.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ForwardLog;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a list of forward log entries
     * 
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the log end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterStatusCode Filter forward logs by http status code
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getBREForwardLogs (filterStartDate?: string, filterEndDate?: string, filterStatusCode?: number, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceForwardLog;  }> {
        const localVarPath = this.basePath + '/bre/logs/forward-log';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterStartDate !== undefined) {
            queryParameters['filter_start_date'] = filterStartDate;
        }

        if (filterEndDate !== undefined) {
            queryParameters['filter_end_date'] = filterEndDate;
        }

        if (filterStatusCode !== undefined) {
            queryParameters['filter_status_code'] = filterStatusCode;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceForwardLog;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a user log entry by id
     * 
     * @param id The user log entry id
     */
    public getUserLog (id: string) : Promise<{ response: http.ClientResponse; body: UserActionLog;  }> {
        const localVarPath = this.basePath + '/audit/logs/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getUserLog.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserActionLog;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a page of user logs entries
     * 
     * @param filterUser Filter for actions taken by a specific user by id
     * @param filterActionName Filter for actions of a specific name
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getUserLogs (filterUser?: number, filterActionName?: string, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceUserActionLog;  }> {
        const localVarPath = this.basePath + '/audit/logs';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterUser !== undefined) {
            queryParameters['filter_user'] = filterUser;
        }

        if (filterActionName !== undefined) {
            queryParameters['filter_action_name'] = filterActionName;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceUserActionLog;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MediaArtistsApiApiKeys {
}

export class MediaArtistsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: MediaArtistsApiApiKeys, value: string) {
        this.authentications[MediaArtistsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Adds a new artist in the system
     * Adds a new artist in the system. Use specific media contributions endpoint to add contributions
     * @param artistResource The new artist
     */
    public addArtist (artistResource?: ArtistResource) : Promise<{ response: http.ClientResponse; body: ArtistResource;  }> {
        const localVarPath = this.basePath + '/media/artists';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: artistResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ArtistResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create an artist template
     * Artist Templates define a type of artist and the properties they have
     * @param artistTemplateResource The artist template resource object
     */
    public createArtistTemplate (artistTemplateResource?: TemplateResource) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/media/artists/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: artistTemplateResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Removes an artist from the system IF no resources are attached to it
     * 
     * @param id The artist id
     */
    public deleteArtist (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/media/artists/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteArtist.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an artist template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    public deleteArtistTemplate (id: string, cascade?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/media/artists/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteArtistTemplate.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = cascade;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Loads a specific artist details
     * 
     * @param id The artist id
     * @param showContributions The number of contributions to show fetch
     */
    public getArtist (id: number, showContributions?: number) : Promise<{ response: http.ClientResponse; body: ArtistResource;  }> {
        const localVarPath = this.basePath + '/media/artists/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getArtist.');
        }

        if (showContributions !== undefined) {
            queryParameters['show_contributions'] = showContributions;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ArtistResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single artist template
     * 
     * @param id The id of the template
     */
    public getArtistTemplate (id: string) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/media/artists/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getArtistTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search artist templates
     * 
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getArtistTemplates (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }> {
        const localVarPath = this.basePath + '/media/artists/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Search for artists
     * 
     * @param filterArtistsByName Filter for artists which name *STARTS* with the given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getArtists (filterArtistsByName?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceArtistResource;  }> {
        const localVarPath = this.basePath + '/media/artists';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterArtistsByName !== undefined) {
            queryParameters['filter_artists_by_name'] = filterArtistsByName;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceArtistResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Modifies an artist details
     * 
     * @param id The artist id
     * @param artistResource The new artist
     */
    public updateArtist (id: number, artistResource?: ArtistResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/media/artists/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateArtist.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: artistResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an artist template
     * 
     * @param id The id of the template
     * @param artistTemplateResource The artist template resource object
     */
    public updateArtistTemplate (id: string, artistTemplateResource?: TemplateResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/media/artists/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateArtistTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: artistTemplateResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MediaModerationApiApiKeys {
}

export class MediaModerationApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: MediaModerationApiApiKeys, value: string) {
        this.authentications[MediaModerationApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Get a flag report
     * 
     * @param id The flag report id
     */
    public getModerationReport (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/moderation/reports/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getModerationReport.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a page of flag reports
     * Context can be either a free-form string or a pre-defined context name
     * @param excludeResolved Ignore resolved context
     * @param filterContext Filter by moderation context
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getModerationReports (excludeResolved?: boolean, filterContext?: string, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceFlagReportResource;  }> {
        const localVarPath = this.basePath + '/moderation/reports';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (excludeResolved !== undefined) {
            queryParameters['exclude_resolved'] = excludeResolved;
        }

        if (filterContext !== undefined) {
            queryParameters['filter_context'] = filterContext;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceFlagReportResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a flag report
     * Lets you set the resolution of a report. Resolution types is {banned,ignore} in case of &#39;banned&#39; you will need to pass the reason.
     * @param id The flag report id
     * @param flagReportResource The new flag report
     */
    public updateModerationReport (id: number, flagReportResource?: FlagReportResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/moderation/reports/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateModerationReport.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: flagReportResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MediaVideosApiApiKeys {
}

export class MediaVideosApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: MediaVideosApiApiKeys, value: string) {
        this.authentications[MediaVideosApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Adds a user to a video&#39;s whitelist
     * Whitelisted users can view video regardless of privacy setting.
     * @param id The video id
     * @param userId The user id
     */
    public addUserToVideoWhitelist (id: number, userId?: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/media/videos/{id}/whitelist'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling addUserToVideoWhitelist.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: userId,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Adds a new video in the system
     * 
     * @param videoResource The video object
     */
    public addVideo (videoResource?: VideoResource) : Promise<{ response: http.ClientResponse; body: VideoResource;  }> {
        const localVarPath = this.basePath + '/media/videos';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: videoResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VideoResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Add a new video comment
     * 
     * @param videoId The video id 
     * @param commentResource The comment object
     */
    public addVideoComment (videoId: number, commentResource?: CommentResource) : Promise<{ response: http.ClientResponse; body: CommentResource;  }> {
        const localVarPath = this.basePath + '/media/videos/{video_id}/comments'
            .replace('{' + 'video_id' + '}', String(videoId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'videoId' is not null or undefined
        if (videoId === null || videoId === undefined) {
            throw new Error('Required parameter videoId was null or undefined when calling addVideoComment.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: commentResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CommentResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Adds a contributor to a video
     * 
     * @param videoId The video id
     * @param contributionResource The contribution object
     */
    public addVideoContributor (videoId: number, contributionResource?: ContributionResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/media/videos/{video_id}/contributors'
            .replace('{' + 'video_id' + '}', String(videoId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'videoId' is not null or undefined
        if (videoId === null || videoId === undefined) {
            throw new Error('Required parameter videoId was null or undefined when calling addVideoContributor.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: contributionResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Add a new flag
     * 
     * @param videoId The video id
     * @param reason The flag reason
     */
    public addVideoFlag (videoId: number, reason?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/media/videos/{video_id}/moderation'
            .replace('{' + 'video_id' + '}', String(videoId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'videoId' is not null or undefined
        if (videoId === null || videoId === undefined) {
            throw new Error('Required parameter videoId was null or undefined when calling addVideoFlag.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: reason,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Adds one or more existing videos as related to this one
     * 
     * @param videoId The video id
     * @param videoRelationshipResource The video relationship object 
     */
    public addVideoRelationships (videoId: number, videoRelationshipResource?: VideoRelationshipResource) : Promise<{ response: http.ClientResponse; body: VideoRelationshipResource;  }> {
        const localVarPath = this.basePath + '/media/videos/{video_id}/related'
            .replace('{' + 'video_id' + '}', String(videoId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'videoId' is not null or undefined
        if (videoId === null || videoId === undefined) {
            throw new Error('Required parameter videoId was null or undefined when calling addVideoRelationships.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: videoRelationshipResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VideoRelationshipResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a video disposition
     * 
     * @param videoId The video id
     * @param dispositionResource The disposition object
     */
    public createVideoDisposition (videoId: number, dispositionResource?: DispositionResource) : Promise<{ response: http.ClientResponse; body: DispositionResource;  }> {
        const localVarPath = this.basePath + '/media/videos/{video_id}/dispositions'
            .replace('{' + 'video_id' + '}', String(videoId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'videoId' is not null or undefined
        if (videoId === null || videoId === undefined) {
            throw new Error('Required parameter videoId was null or undefined when calling createVideoDisposition.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: dispositionResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DispositionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes a video from the system if no resources are attached to it
     * 
     * @param id The video id
     */
    public deleteVideo (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/media/videos/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteVideo.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a video comment
     * 
     * @param videoId The video id
     * @param id The comment id
     */
    public deleteVideoComment (videoId: number, id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/media/videos/{video_id}/comments/{id}'
            .replace('{' + 'video_id' + '}', String(videoId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'videoId' is not null or undefined
        if (videoId === null || videoId === undefined) {
            throw new Error('Required parameter videoId was null or undefined when calling deleteVideoComment.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteVideoComment.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a video disposition
     * 
     * @param dispositionId The disposition id
     */
    public deleteVideoDisposition (dispositionId: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/media/videos/{video_id}/dispositions/{disposition_id}'
            .replace('{' + 'disposition_id' + '}', String(dispositionId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'dispositionId' is not null or undefined
        if (dispositionId === null || dispositionId === undefined) {
            throw new Error('Required parameter dispositionId was null or undefined when calling deleteVideoDisposition.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a flag
     * 
     * @param videoId The video id
     */
    public deleteVideoFlag (videoId: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/media/videos/{video_id}/moderation'
            .replace('{' + 'video_id' + '}', String(videoId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'videoId' is not null or undefined
        if (videoId === null || videoId === undefined) {
            throw new Error('Required parameter videoId was null or undefined when calling deleteVideoFlag.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a video&#39;s relationship
     * 
     * @param videoId The video id
     * @param id The relationship id
     */
    public deleteVideoRelationship (videoId: number, id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/media/videos/{video_id}/related/{id}'
            .replace('{' + 'video_id' + '}', String(videoId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'videoId' is not null or undefined
        if (videoId === null || videoId === undefined) {
            throw new Error('Required parameter videoId was null or undefined when calling deleteVideoRelationship.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteVideoRelationship.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get user videos
     * 
     * @param userId The user id
     * @param excludeFlagged Skip videos that have been flagged by the current user
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getUserVideos (userId: number, excludeFlagged?: boolean, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceVideoResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/videos'
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserVideos.');
        }

        if (excludeFlagged !== undefined) {
            queryParameters['exclude_flagged'] = excludeFlagged;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceVideoResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Loads a specific video details
     * 
     * @param id The video id
     */
    public getVideo (id: number) : Promise<{ response: http.ClientResponse; body: VideoResource;  }> {
        const localVarPath = this.basePath + '/media/videos/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getVideo.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VideoResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a page of comments for a video
     * 
     * @param videoId The video id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getVideoComments (videoId: number, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceCommentResource;  }> {
        const localVarPath = this.basePath + '/media/videos/{video_id}/comments'
            .replace('{' + 'video_id' + '}', String(videoId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'videoId' is not null or undefined
        if (videoId === null || videoId === undefined) {
            throw new Error('Required parameter videoId was null or undefined when calling getVideoComments.');
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceCommentResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a page of dispositions for a video
     * 
     * @param videoId The video id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getVideoDispositions (videoId: number, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceDispositionResource;  }> {
        const localVarPath = this.basePath + '/media/videos/{video_id}/dispositions'
            .replace('{' + 'video_id' + '}', String(videoId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'videoId' is not null or undefined
        if (videoId === null || videoId === undefined) {
            throw new Error('Required parameter videoId was null or undefined when calling getVideoDispositions.');
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceDispositionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a page of video relationships
     * 
     * @param videoId The video id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getVideoRelationships (videoId: number, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceVideoRelationshipResource;  }> {
        const localVarPath = this.basePath + '/media/videos/{video_id}/related'
            .replace('{' + 'video_id' + '}', String(videoId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'videoId' is not null or undefined
        if (videoId === null || videoId === undefined) {
            throw new Error('Required parameter videoId was null or undefined when calling getVideoRelationships.');
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceVideoRelationshipResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Search videos using the documented filters
     * 
     * @param excludeFlagged Skip videos that have been flagged by the current user
     * @param filterVideosByUploader Filter for videos by uploader id
     * @param filterCategory Filter for videos from a specific category by id
     * @param filterTagset Filter for videos with specified tags (separated by comma)
     * @param filterVideosByName Filter for videos which name *STARTS* with the given string
     * @param filterVideosByContributor Filter for videos with contribution from the artist specified by ID
     * @param filterVideosByAuthor Filter for videos with an artist as author specified by ID
     * @param filterHasAuthor Filter for videos that have an author set if true, or that have no author if false
     * @param filterHasUploader Filter for videos that have an uploader set if true, or that have no uploader if false
     * @param filterRelatedTo Filter for videos that have designated a particular video as the TO of a relationship. Pattern should match VIDEO_ID or VIDEO_ID:DETAILS to match with a specific details string as well
     * @param filterFriends Filter for videos uploaded by friends. &#39;true&#39; for friends of the caller (requires user token) or a user id for a specific user&#39;s friends (requires VIDEOS_ADMIN permission)
     * @param filterDisposition Filter for videos a given user has a given disposition towards. USER_ID:DISPOSITION where USER_ID is the id of the user who has this disposition or &#39;me&#39; for the caller (requires user token for &#39;me&#39;) and DISPOSITION is the name of the disposition. E.G. filter_disposition&#x3D;123:like or filter_disposition&#x3D;me:favorite
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getVideos (excludeFlagged?: boolean, filterVideosByUploader?: string, filterCategory?: string, filterTagset?: string, filterVideosByName?: string, filterVideosByContributor?: string, filterVideosByAuthor?: string, filterHasAuthor?: boolean, filterHasUploader?: boolean, filterRelatedTo?: string, filterFriends?: boolean, filterDisposition?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceVideoResource;  }> {
        const localVarPath = this.basePath + '/media/videos';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (excludeFlagged !== undefined) {
            queryParameters['exclude_flagged'] = excludeFlagged;
        }

        if (filterVideosByUploader !== undefined) {
            queryParameters['filter_videos_by_uploader'] = filterVideosByUploader;
        }

        if (filterCategory !== undefined) {
            queryParameters['filter_category'] = filterCategory;
        }

        if (filterTagset !== undefined) {
            queryParameters['filter_tagset'] = filterTagset;
        }

        if (filterVideosByName !== undefined) {
            queryParameters['filter_videos_by_name'] = filterVideosByName;
        }

        if (filterVideosByContributor !== undefined) {
            queryParameters['filter_videos_by_contributor'] = filterVideosByContributor;
        }

        if (filterVideosByAuthor !== undefined) {
            queryParameters['filter_videos_by_author'] = filterVideosByAuthor;
        }

        if (filterHasAuthor !== undefined) {
            queryParameters['filter_has_author'] = filterHasAuthor;
        }

        if (filterHasUploader !== undefined) {
            queryParameters['filter_has_uploader'] = filterHasUploader;
        }

        if (filterRelatedTo !== undefined) {
            queryParameters['filter_related_to'] = filterRelatedTo;
        }

        if (filterFriends !== undefined) {
            queryParameters['filter_friends'] = filterFriends;
        }

        if (filterDisposition !== undefined) {
            queryParameters['filter_disposition'] = filterDisposition;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceVideoResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Removes a user from a video&#39;s whitelist
     * Remove the user with the id given in the path from the whitelist of users that can view this video regardless of privacy setting.
     * @param videoId The video id
     * @param id The user id
     */
    public removeUserFromVideoWhitelist (videoId: number, id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/media/videos/{video_id}/whitelist/{id}'
            .replace('{' + 'video_id' + '}', String(videoId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'videoId' is not null or undefined
        if (videoId === null || videoId === undefined) {
            throw new Error('Required parameter videoId was null or undefined when calling removeUserFromVideoWhitelist.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling removeUserFromVideoWhitelist.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Removes a contributor from a video
     * 
     * @param videoId The video id
     * @param id The contributor id
     */
    public removeVideoContributor (videoId: number, id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/media/videos/{video_id}/contributors/{id}'
            .replace('{' + 'video_id' + '}', String(videoId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'videoId' is not null or undefined
        if (videoId === null || videoId === undefined) {
            throw new Error('Required parameter videoId was null or undefined when calling removeVideoContributor.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling removeVideoContributor.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Modifies a video&#39;s details
     * 
     * @param id The video id
     * @param videoResource The video object
     */
    public updateVideo (id: number, videoResource?: VideoResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/media/videos/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateVideo.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: videoResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a video comment
     * 
     * @param videoId The video id
     * @param id The comment id
     * @param content The comment content
     */
    public updateVideoComment (videoId: number, id: number, content?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/media/videos/{video_id}/comments/{id}/content'
            .replace('{' + 'video_id' + '}', String(videoId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'videoId' is not null or undefined
        if (videoId === null || videoId === undefined) {
            throw new Error('Required parameter videoId was null or undefined when calling updateVideoComment.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateVideoComment.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: content,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a video&#39;s relationship details
     * 
     * @param videoId The video id
     * @param relationshipId The relationship id
     * @param details The video relationship details
     */
    public updateVideoRelationship (videoId: number, relationshipId: number, details?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/media/videos/{video_id}/related/{id}/relationship_details'
            .replace('{' + 'video_id' + '}', String(videoId))
            .replace('{' + 'relationship_id' + '}', String(relationshipId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'videoId' is not null or undefined
        if (videoId === null || videoId === undefined) {
            throw new Error('Required parameter videoId was null or undefined when calling updateVideoRelationship.');
        }

        // verify required parameter 'relationshipId' is not null or undefined
        if (relationshipId === null || relationshipId === undefined) {
            throw new Error('Required parameter relationshipId was null or undefined when calling updateVideoRelationship.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: details,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Increment a video&#39;s view count
     * 
     * @param id The video id
     */
    public viewVideo (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/media/videos/{id}/views'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling viewVideo.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MessagingApiApiKeys {
}

export class MessagingApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: MessagingApiApiKeys, value: string) {
        this.authentications[MessagingApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Send a raw email to one or more users
     * 
     * @param rawEmailResource The new raw email to be sent
     */
    public sendRawEmail (rawEmailResource?: RawEmailResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/messaging/raw-email';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: rawEmailResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Send a raw SMS
     * Sends a raw SMS text message to one or more users. User&#39;s without registered mobile numbers will be skipped.
     * @param rawSMSResource The new raw SMS to be sent
     */
    public sendRawSMS (rawSMSResource?: RawSMSResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/messaging/raw-sms';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: rawSMSResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Send a templated email to one or more users
     * 
     * @param messageResource The new template email to be sent
     */
    public sendTemplatedEmail (messageResource?: TemplateEmailResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/messaging/templated-email';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: messageResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Send a new templated SMS
     * Sends a templated SMS text message to one or more users. User&#39;s without registered mobile numbers will be skipped.
     * @param templateSMSResource The new template SMS to be sent
     */
    public sendTemplatedSMS (templateSMSResource?: TemplateSMSResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/messaging/templated-sms';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: templateSMSResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PaymentsApiApiKeys {
}

export class PaymentsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: PaymentsApiApiKeys, value: string) {
        this.authentications[PaymentsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Create a new payment method for a user
     * 
     * @param userId ID of the user for whom the payment method is being created
     * @param paymentMethod Payment method being created
     */
    public createPaymentMethod (userId: number, paymentMethod?: PaymentMethodResource) : Promise<{ response: http.ClientResponse; body: PaymentMethodResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/payment-methods'
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling createPaymentMethod.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: paymentMethod,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PaymentMethodResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an existing payment method for a user
     * 
     * @param userId ID of the user for whom the payment method is being updated
     * @param id ID of the payment method being deleted
     */
    public deletePaymentMethod (userId: number, id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/payment-methods/{id}'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling deletePaymentMethod.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deletePaymentMethod.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single payment method for a user
     * 
     * @param userId ID of the user for whom the payment method is being retrieved
     * @param id ID of the payment method being retrieved
     */
    public getPaymentMethod (userId: number, id: number) : Promise<{ response: http.ClientResponse; body: PaymentMethodResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/payment-methods/{id}'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getPaymentMethod.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getPaymentMethod.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PaymentMethodResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all payment methods for a user
     * 
     * @param userId ID of the user for whom the payment methods are being retrieved
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order a comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getPaymentMethods (userId: number, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: Array<PaymentMethodResource>;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/payment-methods'
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getPaymentMethods.');
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<PaymentMethodResource>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Authorize payment of an invoice for later capture
     * 
     * @param request Payment authorization request
     */
    public paymentAuthorization (request?: PaymentAuthorizationResource) : Promise<{ response: http.ClientResponse; body: PaymentAuthorizationResource;  }> {
        const localVarPath = this.basePath + '/payment/authorizations';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: request,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PaymentAuthorizationResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Capture an existing invoice payment authorization
     * 
     * @param id ID of the payment authorization to capture
     */
    public paymentCapture (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/payment/authorizations/{id}/capture'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling paymentCapture.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an existing payment method for a user
     * 
     * @param userId ID of the user for whom the payment method is being updated
     * @param id ID of the payment method being updated
     * @param paymentMethod The updated payment method data
     */
    public updatePaymentMethod (userId: number, id: number, paymentMethod?: PaymentMethodResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/payment-methods/{id}'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling updatePaymentMethod.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updatePaymentMethod.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: paymentMethod,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PaymentsAppleApiApiKeys {
}

export class PaymentsAppleApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: PaymentsAppleApiApiKeys, value: string) {
        this.authentications[PaymentsAppleApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Pay invoice with Apple receipt
     * Mark an invoice paid using Apple payment receipt. A receipt will only be accepted once and the details of the transaction must match the invoice, including the product_id matching the sku text of the item in the invoice. Returns the transaction ID if successful.
     * @param request The request for paying an invoice through an Apple receipt
     */
    public verifyAppleReceipt (request?: ApplyPaymentRequest) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/payment/provider/apple/receipt';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: request,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PaymentsGoogleApiApiKeys {
}

export class PaymentsGoogleApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: PaymentsGoogleApiApiKeys, value: string) {
        this.authentications[PaymentsGoogleApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Mark an invoice paid with Google
     * Mark an invoice paid with Google. Verifies signature from Google and treats the developerPayload field inside the json payload as the id of the invoice to pay. Returns the transaction ID if successful.
     * @param request The request for paying an invoice through a Google in-app payment
     */
    public handleGooglePayment (request?: GooglePaymentRequest) : Promise<{ response: http.ClientResponse; body: number;  }> {
        const localVarPath = this.basePath + '/payment/provider/google/payments';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: request,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: number;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PaymentsOptimalApiApiKeys {
}

export class PaymentsOptimalApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: PaymentsOptimalApiApiKeys, value: string) {
        this.authentications[PaymentsOptimalApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Initiate silent post with Optimal
     * Will return the url for a hosted payment endpoint to post to. See Optimal documentation for details.
     * @param request The payment request to initiate
     */
    public silentPostOptimal (request?: OptimalPaymentRequest) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/payment/provider/optimal/silent';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: request,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PaymentsPayPalClassicApiApiKeys {
}

export class PaymentsPayPalClassicApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: PaymentsPayPalClassicApiApiKeys, value: string) {
        this.authentications[PaymentsPayPalClassicApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Create a PayPal Classic billing agreement for the user
     * Returns the token that should be used to forward the user to PayPal so they can accept the agreement.
     * @param request The request to create a PayPal billing agreement
     */
    public createPayPalBillingAgreementUrl (request?: CreateBillingAgreementRequest) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/payment/provider/paypal/classic/agreements/start';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: request,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a payment token for PayPal express checkout
     * Returns the token that should be used to forward the user to PayPal so they can complete the checkout.
     * @param request The request to create a PayPal payment token
     */
    public createPayPalExpressCheckout (request?: CreatePayPalPaymentRequest) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/payment/provider/paypal/classic/checkout/start';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: request,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Finalizes a billing agreement after the user has accepted through PayPal
     * Returns the ID of the new payment method created for the user for the billing agreement.
     * @param request The request to finalize a PayPal billing agreement
     */
    public finalizePayPalBillingAgreement (request?: FinalizeBillingAgreementRequest) : Promise<{ response: http.ClientResponse; body: number;  }> {
        const localVarPath = this.basePath + '/payment/provider/paypal/classic/agreements/finish';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: request,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: number;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Finalizes a payment after the user has completed checkout with PayPal
     * The invoice will be marked paid/failed by asynchronous IPN callback.
     * @param request The request to finalize the payment
     */
    public finalizePayPalCheckout (request?: FinalizePayPalPaymentRequest) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/payment/provider/paypal/classic/checkout/finish';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: request,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PaymentsStripeApiApiKeys {
}

export class PaymentsStripeApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: PaymentsStripeApiApiKeys, value: string) {
        this.authentications[PaymentsStripeApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Create a Stripe payment method for a user
     * Stores customer information and creates a payment method that can be used to pay invoices through the payments endpoints.
     * @param request The request to create a Stripe customer with payment info
     */
    public createStripePaymentMethod (request?: StripeCreatePaymentMethod) : Promise<{ response: http.ClientResponse; body: PaymentMethodResource;  }> {
        const localVarPath = this.basePath + '/payment/provider/stripe/payment-methods';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: request,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PaymentMethodResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Pay with a single use token
     * 
     * @param request The request to pay an invoice
     */
    public payStripeInvoice (request?: StripePaymentRequest) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/payment/provider/stripe/payments';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: request,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PaymentsTransactionsApiApiKeys {
}

export class PaymentsTransactionsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: PaymentsTransactionsApiApiKeys, value: string) {
        this.authentications[PaymentsTransactionsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Get the details for a single transaction
     * 
     * @param id id
     */
    public getTransaction (id: number) : Promise<{ response: http.ClientResponse; body: TransactionResource;  }> {
        const localVarPath = this.basePath + '/transactions/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTransaction.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TransactionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search transactions
     * 
     * @param filterInvoice Filter for transactions from a specific invoice
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getTransactions (filterInvoice?: number, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceTransactionResource;  }> {
        const localVarPath = this.basePath + '/transactions';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterInvoice !== undefined) {
            queryParameters['filter_invoice'] = filterInvoice;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceTransactionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Refund a payment transaction, in full or in part
     * Will not allow for refunding more than the full amount even with multiple partial refunds. Money is refunded to the payment method used to make the original payment. Payment method must support refunds.
     * @param id The id of the transaction to refund
     * @param request Request containing refund details
     */
    public refundTransaction (id: number, request?: RefundRequest) : Promise<{ response: http.ClientResponse; body: RefundResource;  }> {
        const localVarPath = this.basePath + '/transactions/{id}/refunds'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling refundTransaction.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: request,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RefundResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PaymentsWalletsApiApiKeys {
}

export class PaymentsWalletsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: PaymentsWalletsApiApiKeys, value: string) {
        this.authentications[PaymentsWalletsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Returns the user&#39;s wallet for the given currency code
     * 
     * @param userId The ID of the user for whom wallet is being retrieved
     * @param currencyCode Currency code of the user&#39;s wallet
     */
    public getUserWallet (userId: number, currencyCode: string) : Promise<{ response: http.ClientResponse; body: SimpleWallet;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/wallets/{currency_code}'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'currency_code' + '}', String(currencyCode));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserWallet.');
        }

        // verify required parameter 'currencyCode' is not null or undefined
        if (currencyCode === null || currencyCode === undefined) {
            throw new Error('Required parameter currencyCode was null or undefined when calling getUserWallet.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SimpleWallet;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a user&#39;s wallet transactions
     * 
     * @param userId The ID of the user for whom wallet transactions are being retrieved
     * @param currencyCode Currency code of the user&#39;s wallet
     * @param filterType Filter for transactions with specified type
     * @param filterMaxDate Filter for transactions from no earlier than the specified date as a unix timestamp in seconds
     * @param filterMinDate Filter for transactions from no later than the specified date as a unix timestamp in seconds
     * @param filterSign Filter for transactions with amount with the given sign.  Allowable values: (&#39;positive&#39;, &#39;negative&#39;)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getUserWalletTransactions (userId: number, currencyCode: string, filterType?: string, filterMaxDate?: number, filterMinDate?: number, filterSign?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceWalletTransactionResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/wallets/{currency_code}/transactions'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'currency_code' + '}', String(currencyCode));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserWalletTransactions.');
        }

        // verify required parameter 'currencyCode' is not null or undefined
        if (currencyCode === null || currencyCode === undefined) {
            throw new Error('Required parameter currencyCode was null or undefined when calling getUserWalletTransactions.');
        }

        if (filterType !== undefined) {
            queryParameters['filter_type'] = filterType;
        }

        if (filterMaxDate !== undefined) {
            queryParameters['filter_max_date'] = filterMaxDate;
        }

        if (filterMinDate !== undefined) {
            queryParameters['filter_min_date'] = filterMinDate;
        }

        if (filterSign !== undefined) {
            queryParameters['filter_sign'] = filterSign;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceWalletTransactionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List all of a user&#39;s wallets
     * 
     * @param userId The ID of the user for whom wallets are being retrieved
     */
    public getUserWallets (userId: number) : Promise<{ response: http.ClientResponse; body: Array<SimpleWallet>;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/wallets'
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserWallets.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<SimpleWallet>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a summation of wallet balances by currency code
     * 
     */
    public getWalletBalances () : Promise<{ response: http.ClientResponse; body: PageResourceWalletTotalResponse;  }> {
        const localVarPath = this.basePath + '/wallets/totals';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceWalletTotalResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve wallet transactions across the system
     * 
     * @param filterInvoice Filter for transactions from a specific invoice
     * @param filterType Filter for transactions with specified type
     * @param filterMaxDate Filter for transactions from no earlier than the specified date as a unix timestamp in seconds
     * @param filterMinDate Filter for transactions from no later than the specified date as a unix timestamp in seconds
     * @param filterSign Filter for transactions with amount with the given sign
     * @param filterUserId Filter for transactions for specific userId
     * @param filterUsername Filter for transactions for specific username that start with the given string
     * @param filterDetails Filter for transactions for specific details that start with the given string
     * @param filterCurrencyCode Filter for transactions for specific currency code
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getWalletTransactions (filterInvoice?: number, filterType?: string, filterMaxDate?: number, filterMinDate?: number, filterSign?: string, filterUserId?: number, filterUsername?: string, filterDetails?: string, filterCurrencyCode?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceWalletTransactionResource;  }> {
        const localVarPath = this.basePath + '/wallets/transactions';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterInvoice !== undefined) {
            queryParameters['filter_invoice'] = filterInvoice;
        }

        if (filterType !== undefined) {
            queryParameters['filter_type'] = filterType;
        }

        if (filterMaxDate !== undefined) {
            queryParameters['filter_max_date'] = filterMaxDate;
        }

        if (filterMinDate !== undefined) {
            queryParameters['filter_min_date'] = filterMinDate;
        }

        if (filterSign !== undefined) {
            queryParameters['filter_sign'] = filterSign;
        }

        if (filterUserId !== undefined) {
            queryParameters['filter_user_id'] = filterUserId;
        }

        if (filterUsername !== undefined) {
            queryParameters['filter_username'] = filterUsername;
        }

        if (filterDetails !== undefined) {
            queryParameters['filter_details'] = filterDetails;
        }

        if (filterCurrencyCode !== undefined) {
            queryParameters['filter_currency_code'] = filterCurrencyCode;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceWalletTransactionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a list of wallets across the system
     * 
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getWallets (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceSimpleWallet;  }> {
        const localVarPath = this.basePath + '/wallets';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceSimpleWallet;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates the balance for a user&#39;s wallet
     * 
     * @param userId The ID of the user for whom wallet is being modified
     * @param currencyCode Currency code of the user&#39;s wallet
     * @param request The requested balance modification to be made to the user&#39;s wallet
     */
    public updateWalletBalance (userId: number, currencyCode: string, request?: WalletAlterRequest) : Promise<{ response: http.ClientResponse; body: WalletTransactionResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/wallets/{currency_code}/balance'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'currency_code' + '}', String(currencyCode));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling updateWalletBalance.');
        }

        // verify required parameter 'currencyCode' is not null or undefined
        if (currencyCode === null || currencyCode === undefined) {
            throw new Error('Required parameter currencyCode was null or undefined when calling updateWalletBalance.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: request,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: WalletTransactionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PaymentsXsollaApiApiKeys {
}

export class PaymentsXsollaApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: PaymentsXsollaApiApiKeys, value: string) {
        this.authentications[PaymentsXsollaApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Create a payment token that should be used to forward the user to Xsolla so they can complete payment
     * 
     * @param request The payment request to be sent to XSolla
     */
    public createXsollaTokenUrl (request?: XsollaPaymentRequest) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/payment/provider/xsolla/payment';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: request,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Receives payment response from Xsolla
     * Only used by XSolla to call back to JSAPI after processing user payment action
     */
    public receiveNotificationUsingPOST () : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/payment/provider/xsolla/notifications';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ReportingChallengesApiApiKeys {
}

export class ReportingChallengesApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: ReportingChallengesApiApiKeys, value: string) {
        this.authentications[ReportingChallengesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Retrieve a challenge event leaderboard details
     * Lists all leaderboard entries with additional user details
     * @param filterEvent A sepecific challenge event id
     */
    public getChallengeEventLeaderboard (filterEvent?: number) : Promise<{ response: http.ClientResponse; body: PageResourceChallengeEventParticipantResource;  }> {
        const localVarPath = this.basePath + '/reporting/events/leaderboard';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterEvent !== undefined) {
            queryParameters['filter_event'] = filterEvent;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceChallengeEventParticipantResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a challenge event participant details
     * Lists all user submitted scores sorted by value, including those that do not apear in the leaderboard due to value or aggregation
     * @param filterEvent A sepecific challenge event id
     */
    public getChallengeEventParticipants (filterEvent?: number) : Promise<{ response: http.ClientResponse; body: PageResourceChallengeEventParticipantResource;  }> {
        const localVarPath = this.basePath + '/reporting/events/participants';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterEvent !== undefined) {
            queryParameters['filter_event'] = filterEvent;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceChallengeEventParticipantResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ReportingOrdersApiApiKeys {
}

export class ReportingOrdersApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: ReportingOrdersApiApiKeys, value: string) {
        this.authentications[ReportingOrdersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Retrieve invoice counts aggregated by time ranges
     * 
     * @param currencyCode The code for a currency to get sales data for
     * @param granularity The time duration to aggregate by
     * @param filterPaymentStatus A payment status to filter results by, can be a comma separated list
     * @param filterFulfillmentStatus An invoice fulfillment status to filter results by, can be a comma separated list
     * @param startDate The start of the time range to return, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to return, unix timestamp in seconds. Default is end of time
     */
    public getInvoiceReports (currencyCode: string, granularity?: string, filterPaymentStatus?: string, filterFulfillmentStatus?: string, startDate?: number, endDate?: number) : Promise<{ response: http.ClientResponse; body: PageResourceAggregateInvoiceReportResource;  }> {
        const localVarPath = this.basePath + '/reporting/orders/count/{currency_code}'
            .replace('{' + 'currency_code' + '}', String(currencyCode));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'currencyCode' is not null or undefined
        if (currencyCode === null || currencyCode === undefined) {
            throw new Error('Required parameter currencyCode was null or undefined when calling getInvoiceReports.');
        }

        if (granularity !== undefined) {
            queryParameters['granularity'] = granularity;
        }

        if (filterPaymentStatus !== undefined) {
            queryParameters['filter_payment_status'] = filterPaymentStatus;
        }

        if (filterFulfillmentStatus !== undefined) {
            queryParameters['filter_fulfillment_status'] = filterFulfillmentStatus;
        }

        if (startDate !== undefined) {
            queryParameters['start_date'] = startDate;
        }

        if (endDate !== undefined) {
            queryParameters['end_date'] = endDate;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceAggregateInvoiceReportResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ReportingRevenueApiApiKeys {
}

export class ReportingRevenueApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: ReportingRevenueApiApiKeys, value: string) {
        this.authentications[ReportingRevenueApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Get item revenue info
     * Get basic info about revenue from sales of items and bundles (not subscriptions, shipping, etc), summed up within a time range
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     */
    public getItemRevenue (currencyCode: string, startDate?: number, endDate?: number) : Promise<{ response: http.ClientResponse; body: RevenueReportResource;  }> {
        const localVarPath = this.basePath + '/reporting/revenue/item-sales/{currency_code}'
            .replace('{' + 'currency_code' + '}', String(currencyCode));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'currencyCode' is not null or undefined
        if (currencyCode === null || currencyCode === undefined) {
            throw new Error('Required parameter currencyCode was null or undefined when calling getItemRevenue.');
        }

        if (startDate !== undefined) {
            queryParameters['start_date'] = startDate;
        }

        if (endDate !== undefined) {
            queryParameters['end_date'] = endDate;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RevenueReportResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get refund revenue info
     * Get basic info about revenue loss from refunds (for all item types), summed up within a time range.
     * @param currencyCode The code for a currency to get refund data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     */
    public getRefundRevenue (currencyCode: string, startDate?: number, endDate?: number) : Promise<{ response: http.ClientResponse; body: RevenueReportResource;  }> {
        const localVarPath = this.basePath + '/reporting/revenue/refunds/{currency_code}'
            .replace('{' + 'currency_code' + '}', String(currencyCode));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'currencyCode' is not null or undefined
        if (currencyCode === null || currencyCode === undefined) {
            throw new Error('Required parameter currencyCode was null or undefined when calling getRefundRevenue.');
        }

        if (startDate !== undefined) {
            queryParameters['start_date'] = startDate;
        }

        if (endDate !== undefined) {
            queryParameters['end_date'] = endDate;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RevenueReportResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get revenue info by country
     * Get basic info about revenue from sales of all types, summed up within a time range and split out by country. Sorted for largest revenue at the top
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getRevenueByCountry (currencyCode: string, startDate?: number, endDate?: number, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceRevenueCountryReportResource;  }> {
        const localVarPath = this.basePath + '/reporting/revenue/countries/{currency_code}'
            .replace('{' + 'currency_code' + '}', String(currencyCode));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'currencyCode' is not null or undefined
        if (currencyCode === null || currencyCode === undefined) {
            throw new Error('Required parameter currencyCode was null or undefined when calling getRevenueByCountry.');
        }

        if (startDate !== undefined) {
            queryParameters['start_date'] = startDate;
        }

        if (endDate !== undefined) {
            queryParameters['end_date'] = endDate;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceRevenueCountryReportResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get revenue info by item
     * Get basic info about revenue from sales of all types, summed up within a time range and split out by specific item. Sorted for largest revenue at the top
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getRevenueByItem (currencyCode: string, startDate?: number, endDate?: number, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceRevenueProductReportResource;  }> {
        const localVarPath = this.basePath + '/reporting/revenue/products/{currency_code}'
            .replace('{' + 'currency_code' + '}', String(currencyCode));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'currencyCode' is not null or undefined
        if (currencyCode === null || currencyCode === undefined) {
            throw new Error('Required parameter currencyCode was null or undefined when calling getRevenueByItem.');
        }

        if (startDate !== undefined) {
            queryParameters['start_date'] = startDate;
        }

        if (endDate !== undefined) {
            queryParameters['end_date'] = endDate;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceRevenueProductReportResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get subscription revenue info
     * Get basic info about revenue from sales of new subscriptions as well as recurring payemnts, summed up within a time range
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     */
    public getSubscriptionRevenue (currencyCode: string, startDate?: number, endDate?: number) : Promise<{ response: http.ClientResponse; body: RevenueReportResource;  }> {
        const localVarPath = this.basePath + '/reporting/revenue/subscription-sales/{currency_code}'
            .replace('{' + 'currency_code' + '}', String(currencyCode));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'currencyCode' is not null or undefined
        if (currencyCode === null || currencyCode === undefined) {
            throw new Error('Required parameter currencyCode was null or undefined when calling getSubscriptionRevenue.');
        }

        if (startDate !== undefined) {
            queryParameters['start_date'] = startDate;
        }

        if (endDate !== undefined) {
            queryParameters['end_date'] = endDate;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RevenueReportResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ReportingSubscriptionsApiApiKeys {
}

export class ReportingSubscriptionsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: ReportingSubscriptionsApiApiKeys, value: string) {
        this.authentications[ReportingSubscriptionsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Get a list of available subscription reports in most recent first order
     * 
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getSubscriptionReports (size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceBillingReport;  }> {
        const localVarPath = this.basePath + '/reporting/subscription';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceBillingReport;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ReportingUsageApiApiKeys {
}

export class ReportingUsageApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: ReportingUsageApiApiKeys, value: string) {
        this.authentications[ReportingUsageApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Returns aggregated endpoint usage information by day
     * 
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getUsageByDay (startDate: number, endDate: number, combineEndpoints?: boolean, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceUsageInfo;  }> {
        const localVarPath = this.basePath + '/reporting/usage/day';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'startDate' is not null or undefined
        if (startDate === null || startDate === undefined) {
            throw new Error('Required parameter startDate was null or undefined when calling getUsageByDay.');
        }

        // verify required parameter 'endDate' is not null or undefined
        if (endDate === null || endDate === undefined) {
            throw new Error('Required parameter endDate was null or undefined when calling getUsageByDay.');
        }

        if (startDate !== undefined) {
            queryParameters['start_date'] = startDate;
        }

        if (endDate !== undefined) {
            queryParameters['end_date'] = endDate;
        }

        if (combineEndpoints !== undefined) {
            queryParameters['combine_endpoints'] = combineEndpoints;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceUsageInfo;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns aggregated endpoint usage information by hour
     * 
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getUsageByHour (startDate: number, endDate: number, combineEndpoints?: boolean, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceUsageInfo;  }> {
        const localVarPath = this.basePath + '/reporting/usage/hour';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'startDate' is not null or undefined
        if (startDate === null || startDate === undefined) {
            throw new Error('Required parameter startDate was null or undefined when calling getUsageByHour.');
        }

        // verify required parameter 'endDate' is not null or undefined
        if (endDate === null || endDate === undefined) {
            throw new Error('Required parameter endDate was null or undefined when calling getUsageByHour.');
        }

        if (startDate !== undefined) {
            queryParameters['start_date'] = startDate;
        }

        if (endDate !== undefined) {
            queryParameters['end_date'] = endDate;
        }

        if (combineEndpoints !== undefined) {
            queryParameters['combine_endpoints'] = combineEndpoints;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceUsageInfo;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns aggregated endpoint usage information by minute
     * 
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getUsageByMinute (startDate: number, endDate: number, combineEndpoints?: boolean, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceUsageInfo;  }> {
        const localVarPath = this.basePath + '/reporting/usage/minute';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'startDate' is not null or undefined
        if (startDate === null || startDate === undefined) {
            throw new Error('Required parameter startDate was null or undefined when calling getUsageByMinute.');
        }

        // verify required parameter 'endDate' is not null or undefined
        if (endDate === null || endDate === undefined) {
            throw new Error('Required parameter endDate was null or undefined when calling getUsageByMinute.');
        }

        if (startDate !== undefined) {
            queryParameters['start_date'] = startDate;
        }

        if (endDate !== undefined) {
            queryParameters['end_date'] = endDate;
        }

        if (combineEndpoints !== undefined) {
            queryParameters['combine_endpoints'] = combineEndpoints;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceUsageInfo;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns aggregated endpoint usage information by month
     * 
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getUsageByMonth (startDate: number, endDate: number, combineEndpoints?: boolean, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceUsageInfo;  }> {
        const localVarPath = this.basePath + '/reporting/usage/month';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'startDate' is not null or undefined
        if (startDate === null || startDate === undefined) {
            throw new Error('Required parameter startDate was null or undefined when calling getUsageByMonth.');
        }

        // verify required parameter 'endDate' is not null or undefined
        if (endDate === null || endDate === undefined) {
            throw new Error('Required parameter endDate was null or undefined when calling getUsageByMonth.');
        }

        if (startDate !== undefined) {
            queryParameters['start_date'] = startDate;
        }

        if (endDate !== undefined) {
            queryParameters['end_date'] = endDate;
        }

        if (combineEndpoints !== undefined) {
            queryParameters['combine_endpoints'] = combineEndpoints;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceUsageInfo;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns aggregated endpoint usage information by year
     * 
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getUsageByYear (startDate: number, endDate: number, combineEndpoints?: boolean, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceUsageInfo;  }> {
        const localVarPath = this.basePath + '/reporting/usage/year';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'startDate' is not null or undefined
        if (startDate === null || startDate === undefined) {
            throw new Error('Required parameter startDate was null or undefined when calling getUsageByYear.');
        }

        // verify required parameter 'endDate' is not null or undefined
        if (endDate === null || endDate === undefined) {
            throw new Error('Required parameter endDate was null or undefined when calling getUsageByYear.');
        }

        if (startDate !== undefined) {
            queryParameters['start_date'] = startDate;
        }

        if (endDate !== undefined) {
            queryParameters['end_date'] = endDate;
        }

        if (combineEndpoints !== undefined) {
            queryParameters['combine_endpoints'] = combineEndpoints;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceUsageInfo;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ReportingUsersApiApiKeys {
}

export class ReportingUsersApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: ReportingUsersApiApiKeys, value: string) {
        this.authentications[ReportingUsersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Get user registration info
     * Get user registration counts grouped by time range
     * @param granularity The time duration to aggregate by
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     */
    public getUserRegistrations (granularity?: string, startDate?: number, endDate?: number) : Promise<{ response: http.ClientResponse; body: PageResourceAggregateCountResource;  }> {
        const localVarPath = this.basePath + '/reporting/users/registrations';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (granularity !== undefined) {
            queryParameters['granularity'] = granularity;
        }

        if (startDate !== undefined) {
            queryParameters['start_date'] = startDate;
        }

        if (endDate !== undefined) {
            queryParameters['end_date'] = endDate;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceAggregateCountResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SearchApiApiKeys {
}

export class SearchApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: SearchApiApiKeys, value: string) {
        this.authentications[SearchApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Add a new object to an index
     * Mainly intended for internal use.
     * @param type The index type
     * @param id The ID of the object
     * @param object The object to add
     */
    public addSearchIndex (type: string, id: string, object?: any) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/search/index/{type}/{id}'
            .replace('{' + 'type' + '}', String(type))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling addSearchIndex.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling addSearchIndex.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: object,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Register reference mappings
     * Add a new type mapping to connect data from one index to another, or discover an exsting one. Mainly intended for internal use.
     * @param mappings The mappings to add
     */
    public addSearchMappings (mappings?: Array<SearchReferenceMapping>) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/search/mappings';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: mappings,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an object
     * Mainly intended for internal use. Requires SEARCH_ADMIN.
     * @param type The index type
     * @param id The ID of the object to delete
     */
    public deleteSearchIndex (type: string, id: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/search/index/{type}/{id}'
            .replace('{' + 'type' + '}', String(type))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling deleteSearchIndex.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteSearchIndex.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete all objects in an index
     * Mainly intended for internal use
     * @param type The index type
     */
    public deleteSearchIndexes (type: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/search/index/{type}'
            .replace('{' + 'type' + '}', String(type));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling deleteSearchIndexes.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Search an index
     * The body is an ElasticSearch query in JSON format. Please see their &lt;a href&#x3D;&#39;https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html&#39;&gt;documentation&lt;/a&gt; for details on the format and search options. The searchable object&#39;s format depends on on the type. See individual search endpoints on other resources for details on their format.
     * @param type The index type
     * @param query The query to be used for the search
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public searchIndex (type: string, query?: any, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceMapstringobject;  }> {
        const localVarPath = this.basePath + '/search/index/{type}'
            .replace('{' + 'type' + '}', String(type));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling searchIndex.');
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: query,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceMapstringobject;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StoreApiApiKeys {
}

export class StoreApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: StoreApiApiKeys, value: string) {
        this.authentications[StoreApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Create an item template
     * Item Templates define a type of item and the properties they have.
     * @param itemTemplateResource The new item template
     */
    public createItemTemplate (itemTemplateResource?: StoreItemTemplateResource) : Promise<{ response: http.ClientResponse; body: StoreItemTemplateResource;  }> {
        const localVarPath = this.basePath + '/store/items/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: itemTemplateResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: StoreItemTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a store item
     * SKUs have to be unique in the entire store. If a duplicate SKU is found, a 400 error is generated and the response will have a \&quot;parameters\&quot; field that is a list of duplicates. A duplicate is an object like {item_id, offending_sku_list}. Ex:&lt;br /&gt; {..., parameters: [[{item: 1, skus: [\&quot;SKU-1\&quot;]}]]}&lt;br /&gt; If an item is brand new and has duplicate SKUs within itself, the item ID will be 0.  Item subclasses are not allowed here, you will have to use their respective endpoints.
     * @param storeItem The store item object
     */
    public createStoreItem (storeItem?: StoreItem) : Promise<{ response: http.ClientResponse; body: StoreItem;  }> {
        const localVarPath = this.basePath + '/store/items';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: storeItem,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: StoreItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an item template
     * 
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    public deleteItemTemplate (id: string, cascade?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/store/items/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteItemTemplate.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = cascade;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a store item
     * 
     * @param id The id of the item
     */
    public deleteStoreItem (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/store/items/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteStoreItem.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single item template
     * Item Templates define a type of item and the properties they have.
     * @param id The id of the template
     */
    public getItemTemplate (id: string) : Promise<{ response: http.ClientResponse; body: StoreItemTemplateResource;  }> {
        const localVarPath = this.basePath + '/store/items/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getItemTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: StoreItemTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search item templates
     * 
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getItemTemplates (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceStoreItemTemplateResource;  }> {
        const localVarPath = this.basePath + '/store/items/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceStoreItemTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a listing of store items
     * The exact structure of each items may differ to include fields specific to the type. The same is true for behaviors.
     * @param limit The amount of items returned
     * @param page The page of the request
     * @param useCatalog Whether to remove items that are not intended for display or not in date
     * @param ignoreLocation Whether to ignore country restrictions based on the caller&#39;s location
     * @param inStockOnly Whether only in-stock items should be returned.  Default value is false
     */
    public getStore (limit?: number, page?: number, useCatalog?: boolean, ignoreLocation?: boolean, inStockOnly?: boolean) : Promise<{ response: http.ClientResponse; body: PageResourceStoreItem;  }> {
        const localVarPath = this.basePath + '/store';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (useCatalog !== undefined) {
            queryParameters['use_catalog'] = useCatalog;
        }

        if (ignoreLocation !== undefined) {
            queryParameters['ignore_location'] = ignoreLocation;
        }

        if (inStockOnly !== undefined) {
            queryParameters['in_stock_only'] = inStockOnly;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceStoreItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single store item
     * 
     * @param id The id of the item
     */
    public getStoreItem (id: number) : Promise<{ response: http.ClientResponse; body: StoreItem;  }> {
        const localVarPath = this.basePath + '/store/items/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getStoreItem.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: StoreItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search store items
     * 
     * @param filterNameSearch Filter for items whose name starts with a given string.
     * @param filterUniqueKey Filter for items whose unique_key is a given string.
     * @param filterPublished Filter for skus that have been published.
     * @param filterDisplayable Filter for items that are displayable.
     * @param filterStart A comma separated string without spaces.  First value is the operator to search on, second value is the store start date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterEnd A comma separated string without spaces.  First value is the operator to search on, second value is the store end date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the sku start date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterStopDate A comma separated string without spaces.  First value is the operator to search on, second value is the sku end date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterSku Filter for skus whose name starts with a given string.
     * @param filterPrice A colon separated string without spaces.  First value is the operator to search on, second value is the price of a sku.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterTag A comma separated list without spaces of the names of tags. Will only return items with at least one of the tags.
     * @param filterItemsByType Filter for item type based on its type hint.
     * @param filterBundledSkus Filter for skus inside bundles whose name starts with a given string.  Used only when type hint is &#39;bundle_item&#39;
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getStoreItems (filterNameSearch?: string, filterUniqueKey?: string, filterPublished?: boolean, filterDisplayable?: boolean, filterStart?: string, filterEnd?: string, filterStartDate?: string, filterStopDate?: string, filterSku?: string, filterPrice?: string, filterTag?: string, filterItemsByType?: string, filterBundledSkus?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceStoreItem;  }> {
        const localVarPath = this.basePath + '/store/items';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterNameSearch !== undefined) {
            queryParameters['filter_name_search'] = filterNameSearch;
        }

        if (filterUniqueKey !== undefined) {
            queryParameters['filter_unique_key'] = filterUniqueKey;
        }

        if (filterPublished !== undefined) {
            queryParameters['filter_published'] = filterPublished;
        }

        if (filterDisplayable !== undefined) {
            queryParameters['filter_displayable'] = filterDisplayable;
        }

        if (filterStart !== undefined) {
            queryParameters['filter_start'] = filterStart;
        }

        if (filterEnd !== undefined) {
            queryParameters['filter_end'] = filterEnd;
        }

        if (filterStartDate !== undefined) {
            queryParameters['filter_start_date'] = filterStartDate;
        }

        if (filterStopDate !== undefined) {
            queryParameters['filter_stop_date'] = filterStopDate;
        }

        if (filterSku !== undefined) {
            queryParameters['filter_sku'] = filterSku;
        }

        if (filterPrice !== undefined) {
            queryParameters['filter_price'] = filterPrice;
        }

        if (filterTag !== undefined) {
            queryParameters['filter_tag'] = filterTag;
        }

        if (filterItemsByType !== undefined) {
            queryParameters['filter_items_by_type'] = filterItemsByType;
        }

        if (filterBundledSkus !== undefined) {
            queryParameters['filter_bundled_skus'] = filterBundledSkus;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceStoreItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an item template
     * 
     * @param id The id of the template
     * @param itemTemplateResource The item template resource object
     */
    public updateItemTemplate (id: string, itemTemplateResource?: StoreItemTemplateResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/store/items/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateItemTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: itemTemplateResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a store item
     * 
     * @param id The id of the item
     * @param storeItem The store item object
     */
    public updateStoreItem (id: number, storeItem?: StoreItem) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/store/items/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateStoreItem.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: storeItem,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StoreBundlesApiApiKeys {
}

export class StoreBundlesApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: StoreBundlesApiApiKeys, value: string) {
        this.authentications[StoreBundlesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Create a bundle item
     * The SKU for the bundle itself must be unique and there can only be one SKU.  Extra notes for price_override:  The price of all the items (multiplied by the quantity) must equal the price of the bundle.  With individual prices set, items will be processed individually and can be refunded as such.  However, if all prices are set to null, the price of the bundle will be used and will be treated as one item.
     * @param bundleItem The bundle item object
     */
    public createBundleItem (bundleItem?: BundleItem) : Promise<{ response: http.ClientResponse; body: BundleItem;  }> {
        const localVarPath = this.basePath + '/store/bundles';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: bundleItem,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BundleItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a bundle template
     * Bundle Templates define a type of bundle and the properties they have.
     * @param bundleTemplateResource The new bundle template
     */
    public createBundleTemplate (bundleTemplateResource?: ItemTemplateResource) : Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }> {
        const localVarPath = this.basePath + '/store/bundles/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: bundleTemplateResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a bundle item
     * 
     * @param id The id of the bundle
     */
    public deleteBundleItem (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/store/bundles/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteBundleItem.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a bundle template
     * 
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    public deleteBundleTemplate (id: string, cascade?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/store/bundles/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteBundleTemplate.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = cascade;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single bundle item
     * 
     * @param id The id of the bundle
     */
    public getBundleItem (id: number) : Promise<{ response: http.ClientResponse; body: BundleItem;  }> {
        const localVarPath = this.basePath + '/store/bundles/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getBundleItem.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BundleItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single bundle template
     * Bundle Templates define a type of bundle and the properties they have.
     * @param id The id of the template
     */
    public getBundleTemplate (id: string) : Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }> {
        const localVarPath = this.basePath + '/store/bundles/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getBundleTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search bundle templates
     * 
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getBundleTemplates (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceItemTemplateResource;  }> {
        const localVarPath = this.basePath + '/store/bundles/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceItemTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a bundle item
     * 
     * @param id The id of the bundle
     * @param bundleItem The bundle item object
     */
    public updateBundleItem (id: number, bundleItem?: BundleItem) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/store/bundles/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateBundleItem.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: bundleItem,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a bundle template
     * 
     * @param id The id of the template
     * @param bundleTemplateResource The bundle template resource object
     */
    public updateBundleTemplate (id: string, bundleTemplateResource?: ItemTemplateResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/store/bundles/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateBundleTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: bundleTemplateResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StoreCouponsApiApiKeys {
}

export class StoreCouponsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: StoreCouponsApiApiKeys, value: string) {
        this.authentications[StoreCouponsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Create a coupon item
     * SKUs have to be unique in the entire store.
     * @param couponItem The coupon item object
     */
    public createCouponItem (couponItem?: CouponItem) : Promise<{ response: http.ClientResponse; body: CouponItem;  }> {
        const localVarPath = this.basePath + '/store/coupons';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: couponItem,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CouponItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a coupon template
     * Coupon Templates define a type of coupon and the properties they have.
     * @param couponTemplateResource The new coupon template
     */
    public createCouponTemplate (couponTemplateResource?: ItemTemplateResource) : Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }> {
        const localVarPath = this.basePath + '/store/coupons/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: couponTemplateResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a coupon item
     * 
     * @param id The id of the coupon
     */
    public deleteCouponItem (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/store/coupons/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteCouponItem.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a coupon template
     * 
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    public deleteCouponTemplate (id: string, cascade?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/store/coupons/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteCouponTemplate.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = cascade;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single coupon item
     * 
     * @param id The id of the coupon
     */
    public getCouponItem (id: number) : Promise<{ response: http.ClientResponse; body: CouponItem;  }> {
        const localVarPath = this.basePath + '/store/coupons/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getCouponItem.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CouponItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single coupon template
     * Coupon Templates define a type of coupon and the properties they have.
     * @param id The id of the template
     */
    public getCouponTemplate (id: string) : Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }> {
        const localVarPath = this.basePath + '/store/coupons/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getCouponTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search coupon templates
     * 
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getCouponTemplates (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceItemTemplateResource;  }> {
        const localVarPath = this.basePath + '/store/coupons/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceItemTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a coupon item
     * 
     * @param id The id of the coupon
     * @param couponItem The coupon item object
     */
    public updateCouponItem (id: number, couponItem?: CouponItem) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/store/coupons/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateCouponItem.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: couponItem,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a coupon template
     * 
     * @param id The id of the template
     * @param couponTemplateResource The coupon template resource object
     */
    public updateCouponTemplate (id: string, couponTemplateResource?: ItemTemplateResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/store/coupons/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateCouponTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: couponTemplateResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StoreSalesApiApiKeys {
}

export class StoreSalesApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: StoreSalesApiApiKeys, value: string) {
        this.authentications[StoreSalesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Create a sale
     * 
     * @param catalogSale The catalog sale object
     */
    public createCatalogSale (catalogSale?: CatalogSale) : Promise<{ response: http.ClientResponse; body: CatalogSale;  }> {
        const localVarPath = this.basePath + '/store/sales';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: catalogSale,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CatalogSale;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a sale
     * 
     * @param id The id of the sale
     */
    public deleteCatalogSale (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/store/sales/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteCatalogSale.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single sale
     * 
     * @param id The id of the sale
     */
    public getCatalogSale (id: number) : Promise<{ response: http.ClientResponse; body: CatalogSale;  }> {
        const localVarPath = this.basePath + '/store/sales/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getCatalogSale.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CatalogSale;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search sales
     * 
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getCatalogSales (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceCatalogSale;  }> {
        const localVarPath = this.basePath + '/store/sales';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceCatalogSale;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a sale
     * 
     * @param id The id of the sale
     * @param catalogSale The catalog sale object
     */
    public updateCatalogSale (id: number, catalogSale?: CatalogSale) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/store/sales/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateCatalogSale.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: catalogSale,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StoreShippingApiApiKeys {
}

export class StoreShippingApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: StoreShippingApiApiKeys, value: string) {
        this.authentications[StoreShippingApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Create a shipping item
     * A shipping item represents a shipping option and cost. SKUs have to be unique in the entire store.
     * @param shippingItem The shipping item object
     */
    public createShippingItem (shippingItem?: ShippingItem) : Promise<{ response: http.ClientResponse; body: ShippingItem;  }> {
        const localVarPath = this.basePath + '/store/shipping';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: shippingItem,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ShippingItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a shipping template
     * Shipping Templates define a type of shipping and the properties they have.
     * @param shippingTemplateResource The new shipping template
     */
    public createShippingTemplate (shippingTemplateResource?: ItemTemplateResource) : Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }> {
        const localVarPath = this.basePath + '/store/shipping/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: shippingTemplateResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a shipping item
     * 
     * @param id The id of the shipping item
     */
    public deleteShippingItem (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/store/shipping/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteShippingItem.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a shipping template
     * 
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    public deleteShippingTemplate (id: string, cascade?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/store/shipping/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteShippingTemplate.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = cascade;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single shipping item
     * 
     * @param id The id of the shipping item
     */
    public getShippingItem (id: number) : Promise<{ response: http.ClientResponse; body: ShippingItem;  }> {
        const localVarPath = this.basePath + '/store/shipping/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getShippingItem.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ShippingItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single shipping template
     * Shipping Templates define a type of shipping and the properties they have.
     * @param id The id of the template
     */
    public getShippingTemplate (id: string) : Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }> {
        const localVarPath = this.basePath + '/store/shipping/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getShippingTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search shipping templates
     * 
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getShippingTemplates (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceItemTemplateResource;  }> {
        const localVarPath = this.basePath + '/store/shipping/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceItemTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a shipping item
     * 
     * @param id The id of the shipping item
     * @param shippingItem The shipping item object
     */
    public updateShippingItem (id: number, shippingItem?: ShippingItem) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/store/shipping/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateShippingItem.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: shippingItem,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a shipping template
     * 
     * @param id The id of the template
     * @param shippingTemplateResource The shipping template resource object
     */
    public updateShippingTemplate (id: string, shippingTemplateResource?: ItemTemplateResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/store/shipping/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateShippingTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: shippingTemplateResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StoreShoppingCartsApiApiKeys {
}

export class StoreShoppingCartsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: StoreShoppingCartsApiApiKeys, value: string) {
        this.authentications[StoreShoppingCartsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Adds a discount coupon to the cart
     * 
     * @param id The id of the cart
     * @param skuRequest The request of the sku
     */
    public addDiscountToCart (id: string, skuRequest?: SkuRequest) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/carts/{id}/discounts'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling addDiscountToCart.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: skuRequest,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Add an item to the cart
     * Currently, carts cannot contain virtual and real currency items at the same time. Furthermore, the API only support a single virtual item at the moment
     * @param id The id of the cart
     * @param cartItemRequest The cart item request object
     */
    public addItemToCart (id: string, cartItemRequest?: CartItemRequest) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/carts/{id}/items'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling addItemToCart.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: cartItemRequest,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a cart
     * You don&#39;t have to have a user to create a cart but the API requires authentication to checkout
     * @param owner Set the owner of a cart. If not specified, defaults to the calling user&#39;s id. If specified and is not the calling user&#39;s id, SHOPPING_CARTS_ADMIN permission is required
     * @param currencyCode Set the currency for the cart, by currency code. May be disallowed by site settings.
     */
    public createCart (owner?: number, currencyCode?: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/carts';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (owner !== undefined) {
            queryParameters['owner'] = owner;
        }

        if (currencyCode !== undefined) {
            queryParameters['currency_code'] = currencyCode;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns the cart with the given GUID
     * 
     * @param id The id of the cart
     */
    public getCart (id: string) : Promise<{ response: http.ClientResponse; body: Cart;  }> {
        const localVarPath = this.basePath + '/carts/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getCart.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Cart;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of carts
     * 
     * @param filterOwnerId Filter by the id of the owner
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getCarts (filterOwnerId?: number, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceCartSummary;  }> {
        const localVarPath = this.basePath + '/carts';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterOwnerId !== undefined) {
            queryParameters['filter_owner_id'] = filterOwnerId;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceCartSummary;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the list of available shipping countries per vendor
     * Since a cart can have multiple vendors with different shipping options, the countries are broken down by vendors. Please see notes about the response object as the fields are variable.
     * @param id The id of the cart
     */
    public getCountries (id: string) : Promise<{ response: http.ClientResponse; body: SampleCountriesResponse;  }> {
        const localVarPath = this.basePath + '/carts/{id}/countries'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getCountries.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SampleCountriesResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns whether a cart requires shipping
     * 
     * @param id The id of the cart
     */
    public getShippable (id: string) : Promise<{ response: http.ClientResponse; body: CartShippableResponse;  }> {
        const localVarPath = this.basePath + '/carts/{id}/shippable'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getShippable.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CartShippableResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Removes a discount coupon from the cart
     * 
     * @param id The id of the cart
     * @param code The SKU code of the coupon to remove
     */
    public removeDiscountFromCart (id: string, code: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/carts/{id}/discounts/{code}'
            .replace('{' + 'id' + '}', String(id))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling removeDiscountFromCart.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling removeDiscountFromCart.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Sets the currency to use for the cart
     * May be disallowed by site settings.
     * @param id The id of the cart
     * @param currencyCode The code of the currency
     */
    public setCartCurrency (id: string, currencyCode?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/carts/{id}/currency'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling setCartCurrency.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: currencyCode,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Sets the owner of a cart if none is set already
     * 
     * @param id The id of the cart
     * @param userId The id of the user
     */
    public setCartOwner (id: string, userId?: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/carts/{id}/owner'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling setCartOwner.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: userId,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Changes the quantity of an item already in the cart
     * A quantity of zero will remove the item from the cart altogether.
     * @param id The id of the cart
     * @param cartItemRequest The cart item request object
     */
    public updateItemInCart (id: string, cartItemRequest?: CartItemRequest) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/carts/{id}/items'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateItemInCart.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: cartItemRequest,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Modifies or sets the order shipping address
     * 
     * @param id The id of the cart
     * @param cartShippingAddressRequest The cart shipping address request object
     */
    public updateShippingAddress (id: string, cartShippingAddressRequest?: CartShippingAddressRequest) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/carts/{id}/shipping-address'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateShippingAddress.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: cartShippingAddressRequest,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StoreSubscriptionsApiApiKeys {
}

export class StoreSubscriptionsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: StoreSubscriptionsApiApiKeys, value: string) {
        this.authentications[StoreSubscriptionsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Creates a subscription item and associated plans
     * 
     * @param subscriptionResource The subscription to be created
     */
    public createSubscription (subscriptionResource?: SubscriptionResource) : Promise<{ response: http.ClientResponse; body: SubscriptionResource;  }> {
        const localVarPath = this.basePath + '/subscriptions';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: subscriptionResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SubscriptionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a subscription template
     * Subscription Templates define a type of subscription and the properties they have.
     * @param subscriptionTemplateResource The new subscription template
     */
    public createSubscriptionTemplate (subscriptionTemplateResource?: SubscriptionTemplateResource) : Promise<{ response: http.ClientResponse; body: SubscriptionTemplateResource;  }> {
        const localVarPath = this.basePath + '/subscriptions/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: subscriptionTemplateResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SubscriptionTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a subscription plan
     * Must not be locked or a migration target
     * @param id The id of the subscription
     * @param planId The id of the plan
     */
    public deleteSubscription (id: number, planId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/subscriptions/{id}/plans/{plan_id}'
            .replace('{' + 'id' + '}', String(id))
            .replace('{' + 'plan_id' + '}', String(planId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteSubscription.');
        }

        // verify required parameter 'planId' is not null or undefined
        if (planId === null || planId === undefined) {
            throw new Error('Required parameter planId was null or undefined when calling deleteSubscription.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a subscription template
     * 
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    public deleteSubscriptionTemplate (id: string, cascade?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/subscriptions/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteSubscriptionTemplate.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = cascade;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a single subscription item and associated plans
     * 
     * @param id The id of the subscription
     */
    public getSubscription (id: number) : Promise<{ response: http.ClientResponse; body: SubscriptionResource;  }> {
        const localVarPath = this.basePath + '/subscriptions/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getSubscription.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SubscriptionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single subscription template
     * Subscription Templates define a type of subscription and the properties they have.
     * @param id The id of the template
     */
    public getSubscriptionTemplate (id: string) : Promise<{ response: http.ClientResponse; body: SubscriptionTemplateResource;  }> {
        const localVarPath = this.basePath + '/subscriptions/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getSubscriptionTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SubscriptionTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search subscription templates
     * 
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getSubscriptionTemplates (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceSubscriptionTemplateResource;  }> {
        const localVarPath = this.basePath + '/subscriptions/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceSubscriptionTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List available subscription items and associated plans
     * 
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getSubscriptions (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceSubscriptionResource;  }> {
        const localVarPath = this.basePath + '/subscriptions';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceSubscriptionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Processes subscriptions and charge dues
     * 
     */
    public processSubscriptions () : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/subscriptions/process';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates a subscription item and associated plans
     * Will not remove plans left out
     * @param id The id of the subscription
     * @param subscriptionResource The subscription resource object
     */
    public updateSubscription (id: number, subscriptionResource?: SubscriptionResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/subscriptions/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateSubscription.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: subscriptionResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a subscription template
     * 
     * @param id The id of the template
     * @param subscriptionTemplateResource The subscription template resource object
     */
    public updateSubscriptionTemplate (id: string, subscriptionTemplateResource?: SubscriptionTemplateResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/subscriptions/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateSubscriptionTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: subscriptionTemplateResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StoreVendorsApiApiKeys {
}

export class StoreVendorsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: StoreVendorsApiApiKeys, value: string) {
        this.authentications[StoreVendorsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Create a vendor
     * 
     * @param vendor The vendor
     */
    public createVendor (vendor?: VendorResource) : Promise<{ response: http.ClientResponse; body: VendorResource;  }> {
        const localVarPath = this.basePath + '/vendors';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: vendor,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VendorResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a vendor
     * 
     * @param id The id of the vendor
     */
    public deleteVendor (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/vendors/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteVendor.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single vendor
     * 
     * @param id The id of the vendor
     */
    public getVendor (id: number) : Promise<{ response: http.ClientResponse; body: VendorResource;  }> {
        const localVarPath = this.basePath + '/vendors/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getVendor.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VendorResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search vendors
     * 
     * @param filterName Filters vendors by name starting with the text provided in the filter
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getVendors (filterName?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceVendorResource;  }> {
        const localVarPath = this.basePath + '/vendors';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterName !== undefined) {
            queryParameters['filter_name'] = filterName;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceVendorResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a vendor
     * 
     * @param id The id of the vendor
     * @param vendor The vendor
     */
    public updateVendor (id: number, vendor?: VendorResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/vendors/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateVendor.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: vendor,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TaxesApiApiKeys {
}

export class TaxesApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: TaxesApiApiKeys, value: string) {
        this.authentications[TaxesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Create a country tax
     * 
     * @param taxResource The tax object
     */
    public createCountryTax (taxResource?: CountryTaxResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/tax/countries';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: taxResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a state tax
     * 
     * @param countryCodeIso3 The iso3 code of the country
     * @param taxResource The tax object
     */
    public createStateTax (countryCodeIso3: string, taxResource?: StateTaxResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/tax/countries/{country_code_iso3}/states'
            .replace('{' + 'country_code_iso3' + '}', String(countryCodeIso3));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'countryCodeIso3' is not null or undefined
        if (countryCodeIso3 === null || countryCodeIso3 === undefined) {
            throw new Error('Required parameter countryCodeIso3 was null or undefined when calling createStateTax.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: taxResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an existing tax
     * 
     * @param countryCodeIso3 The iso3 code of the country
     */
    public deleteCountryTax (countryCodeIso3: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/tax/countries/{country_code_iso3}'
            .replace('{' + 'country_code_iso3' + '}', String(countryCodeIso3));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'countryCodeIso3' is not null or undefined
        if (countryCodeIso3 === null || countryCodeIso3 === undefined) {
            throw new Error('Required parameter countryCodeIso3 was null or undefined when calling deleteCountryTax.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an existing state tax
     * 
     * @param countryCodeIso3 The iso3 code of the country
     * @param stateCode The code of the state
     */
    public deleteStateTax (countryCodeIso3: string, stateCode: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/tax/countries/{country_code_iso3}/states/{state_code}'
            .replace('{' + 'country_code_iso3' + '}', String(countryCodeIso3))
            .replace('{' + 'state_code' + '}', String(stateCode));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'countryCodeIso3' is not null or undefined
        if (countryCodeIso3 === null || countryCodeIso3 === undefined) {
            throw new Error('Required parameter countryCodeIso3 was null or undefined when calling deleteStateTax.');
        }

        // verify required parameter 'stateCode' is not null or undefined
        if (stateCode === null || stateCode === undefined) {
            throw new Error('Required parameter stateCode was null or undefined when calling deleteStateTax.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search taxes
     * Get a list of taxes
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getCountryTaxes (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceCountryTaxResource;  }> {
        const localVarPath = this.basePath + '/tax/countries';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceCountryTaxResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single state tax
     * 
     * @param countryCodeIso3 The iso3 code of the country
     * @param stateCode The code of the state
     */
    public getStateTax (countryCodeIso3: string, stateCode: string) : Promise<{ response: http.ClientResponse; body: StateTaxResource;  }> {
        const localVarPath = this.basePath + '/tax/countries/{country_code_iso3}/states/{state_code}'
            .replace('{' + 'country_code_iso3' + '}', String(countryCodeIso3))
            .replace('{' + 'state_code' + '}', String(stateCode));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'countryCodeIso3' is not null or undefined
        if (countryCodeIso3 === null || countryCodeIso3 === undefined) {
            throw new Error('Required parameter countryCodeIso3 was null or undefined when calling getStateTax.');
        }

        // verify required parameter 'stateCode' is not null or undefined
        if (stateCode === null || stateCode === undefined) {
            throw new Error('Required parameter stateCode was null or undefined when calling getStateTax.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: StateTaxResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search taxes across all countries
     * Get a list of taxes
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getStateTaxesForCountries (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceStateTaxResource;  }> {
        const localVarPath = this.basePath + '/tax/states';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceStateTaxResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search taxes within a country
     * Get a list of taxes
     * @param countryCodeIso3 The iso3 code of the country
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getStateTaxesForCountry (countryCodeIso3: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceStateTaxResource;  }> {
        const localVarPath = this.basePath + '/tax/countries/{country_code_iso3}/states'
            .replace('{' + 'country_code_iso3' + '}', String(countryCodeIso3));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'countryCodeIso3' is not null or undefined
        if (countryCodeIso3 === null || countryCodeIso3 === undefined) {
            throw new Error('Required parameter countryCodeIso3 was null or undefined when calling getStateTaxesForCountry.');
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceStateTaxResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single tax
     * 
     * @param countryCodeIso3 The iso3 code of the country
     */
    public getTaxUsingGET (countryCodeIso3: string) : Promise<{ response: http.ClientResponse; body: CountryTaxResource;  }> {
        const localVarPath = this.basePath + '/tax/countries/{country_code_iso3}'
            .replace('{' + 'country_code_iso3' + '}', String(countryCodeIso3));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'countryCodeIso3' is not null or undefined
        if (countryCodeIso3 === null || countryCodeIso3 === undefined) {
            throw new Error('Required parameter countryCodeIso3 was null or undefined when calling getTaxUsingGET.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CountryTaxResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create or update a tax
     * 
     * @param countryCodeIso3 The iso3 code of the country
     * @param taxResource The tax object
     */
    public updateCountryTax (countryCodeIso3: string, taxResource?: CountryTaxResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/tax/countries/{country_code_iso3}'
            .replace('{' + 'country_code_iso3' + '}', String(countryCodeIso3));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'countryCodeIso3' is not null or undefined
        if (countryCodeIso3 === null || countryCodeIso3 === undefined) {
            throw new Error('Required parameter countryCodeIso3 was null or undefined when calling updateCountryTax.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: taxResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create or update a state tax
     * 
     * @param countryCodeIso3 The iso3 code of the country
     * @param stateCode The code of the state
     * @param taxResource The tax object
     */
    public updateStateTax (countryCodeIso3: string, stateCode: string, taxResource?: StateTaxResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/tax/countries/{country_code_iso3}/states/{state_code}'
            .replace('{' + 'country_code_iso3' + '}', String(countryCodeIso3))
            .replace('{' + 'state_code' + '}', String(stateCode));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'countryCodeIso3' is not null or undefined
        if (countryCodeIso3 === null || countryCodeIso3 === undefined) {
            throw new Error('Required parameter countryCodeIso3 was null or undefined when calling updateStateTax.');
        }

        // verify required parameter 'stateCode' is not null or undefined
        if (stateCode === null || stateCode === undefined) {
            throw new Error('Required parameter stateCode was null or undefined when calling updateStateTax.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: taxResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UsersApiApiKeys {
}

export class UsersApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: UsersApiApiKeys, value: string) {
        this.authentications[UsersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Add a tag to a user
     * 
     * @param userId The id of the user
     * @param tag tag
     */
    public addUserTag (userId: number, tag: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/tags'
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling addUserTag.');
        }

        // verify required parameter 'tag' is not null or undefined
        if (tag === null || tag === undefined) {
            throw new Error('Required parameter tag was null or undefined when calling addUserTag.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: tag,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a user template
     * User Templates define a type of user and the properties they have
     * @param userTemplateResource The user template resource object
     */
    public createUserTemplate (userTemplateResource?: TemplateResource) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/users/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: userTemplateResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a user template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    public deleteUserTemplate (id: string, cascade?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteUserTemplate.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = cascade;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single user
     * Additional private info is included as USERS_ADMIN
     * @param id The id of the user or &#39;me&#39;
     */
    public getUser (id: string) : Promise<{ response: http.ClientResponse; body: UserResource;  }> {
        const localVarPath = this.basePath + '/users/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getUser.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List tags for a user
     * 
     * @param userId The id of the user
     */
    public getUserTags (userId: number) : Promise<{ response: http.ClientResponse; body: Array<string>;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/tags'
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserTags.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<string>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single user template
     * 
     * @param id The id of the template
     */
    public getUserTemplate (id: string) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/users/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getUserTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search user templates
     * 
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getUserTemplates (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }> {
        const localVarPath = this.basePath + '/users/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search users
     * Additional private info is included as USERS_ADMIN
     * @param filterDisplayname Filter for users whose display name starts with provided string.
     * @param filterEmail Filter for users whose email starts with provided string. Requires USERS_ADMIN permission
     * @param filterFirstname Filter for users whose first name starts with provided string. Requires USERS_ADMIN permission
     * @param filterFullname Filter for users whose full name starts with provided string. Requires USERS_ADMIN permission
     * @param filterLastname Filter for users whose last name starts with provided string. Requires USERS_ADMIN permission
     * @param filterUsername Filter for users whose username starts with the provided string. Requires USERS_ADMIN permission
     * @param filterTag Filter for users who have a given tag
     * @param filterGroup Filter for users in a given group, by unique name
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getUsers (filterDisplayname?: string, filterEmail?: string, filterFirstname?: string, filterFullname?: string, filterLastname?: string, filterUsername?: string, filterTag?: string, filterGroup?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceUserBaseResource;  }> {
        const localVarPath = this.basePath + '/users';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterDisplayname !== undefined) {
            queryParameters['filter_displayname'] = filterDisplayname;
        }

        if (filterEmail !== undefined) {
            queryParameters['filter_email'] = filterEmail;
        }

        if (filterFirstname !== undefined) {
            queryParameters['filter_firstname'] = filterFirstname;
        }

        if (filterFullname !== undefined) {
            queryParameters['filter_fullname'] = filterFullname;
        }

        if (filterLastname !== undefined) {
            queryParameters['filter_lastname'] = filterLastname;
        }

        if (filterUsername !== undefined) {
            queryParameters['filter_username'] = filterUsername;
        }

        if (filterTag !== undefined) {
            queryParameters['filter_tag'] = filterTag;
        }

        if (filterGroup !== undefined) {
            queryParameters['filter_group'] = filterGroup;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceUserBaseResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Choose a new password after a reset
     * Finish resetting a user&#39;s password using the secret provided from the password-reset endpoint.  Password should be in plain text and will be encrypted on receipt. Use SSL for security.
     * @param id The id of the user
     * @param newPasswordRequest The new password request object
     */
    public passwordReset (id: number, newPasswordRequest?: NewPasswordRequest) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{id}/password-reset'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling passwordReset.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: newPasswordRequest,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Register a new user
     * Password should be in plain text and will be encrypted on receipt. Use SSL for security
     * @param userResource The user resource object
     */
    public registerUser (userResource?: UserResource) : Promise<{ response: http.ClientResponse; body: UserResource;  }> {
        const localVarPath = this.basePath + '/users';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: userResource,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Remove a tag from a user
     * 
     * @param userId The id of the user
     * @param tag The tag to remove
     */
    public removeUserTag (userId: number, tag: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/tags/{tag}'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'tag' + '}', String(tag));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling removeUserTag.');
        }

        // verify required parameter 'tag' is not null or undefined
        if (tag === null || tag === undefined) {
            throw new Error('Required parameter tag was null or undefined when calling removeUserTag.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set a user&#39;s password
     * Password should be in plain text and will be encrypted on receipt. Use SSL for security.
     * @param id The id of the user
     * @param password The new plain text password
     */
    public setPassword (id: number, password?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{id}/password'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling setPassword.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: password,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Reset a user&#39;s password
     * A reset code will be generated and a &#39;forgot_password&#39; BRE event will be fired with that code; this can be routed to the user as needed and submitted to the &#39;choose a new password&#39; endpoint.
     * @param id The id of the user
     */
    public startPasswordReset (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{id}/password-reset'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling startPasswordReset.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a user
     * Password will not be edited on this endpoint, use password specific endpoints.
     * @param id The id of the user or &#39;me&#39;
     * @param userResource The user resource object
     */
    public updateUser (id: string, userResource?: UserResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateUser.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: userResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a user template
     * 
     * @param id The id of the template
     * @param userTemplateResource The user template resource object
     */
    public updateUserTemplate (id: string, userTemplateResource?: TemplateResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateUserTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: userTemplateResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UsersAddressesApiApiKeys {
}

export class UsersAddressesApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: UsersAddressesApiApiKeys, value: string) {
        this.authentications[UsersAddressesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Create a new address
     * 
     * @param userId The id of the user
     * @param savedAddressResource The new address
     */
    public createAddress (userId: string, savedAddressResource?: SavedAddressResource) : Promise<{ response: http.ClientResponse; body: SavedAddressResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/addresses'
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling createAddress.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: savedAddressResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SavedAddressResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an address
     * 
     * @param userId The id of the user
     * @param id The id of the address
     */
    public deleteAddress (userId: string, id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/addresses/{id}'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling deleteAddress.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteAddress.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single address
     * 
     * @param userId The id of the user
     * @param id The id of the address
     */
    public getAddress (userId: string, id: number) : Promise<{ response: http.ClientResponse; body: SavedAddressResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/addresses/{id}'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getAddress.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getAddress.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SavedAddressResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search addresses
     * 
     * @param userId The id of the user
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getAddresses (userId: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceSavedAddressResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/addresses'
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getAddresses.');
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceSavedAddressResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an address
     * 
     * @param userId The id of the user
     * @param id The id of the address
     * @param savedAddressResource The saved address resource object
     */
    public updateAddress (userId: string, id: number, savedAddressResource?: SavedAddressResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/addresses/{id}'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling updateAddress.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateAddress.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: savedAddressResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UsersFriendshipsApiApiKeys {
}

export class UsersFriendshipsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: UsersFriendshipsApiApiKeys, value: string) {
        this.authentications[UsersFriendshipsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Add a friend
     * As a user, either creates or confirm a pending request. As an admin, call this endpoint twice while inverting the IDs to create a confirmed friendship.
     * @param userId The id of the user or &#39;me&#39; if logged in
     * @param id The id of the user to befriend
     */
    public addFriend (userId: string, id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/friends/{id}'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling addFriend.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling addFriend.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get friends list
     * 
     * @param userId The id of the user or &#39;me&#39;
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getFriends (userId: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceSimpleUserResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/friends'
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getFriends.');
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceSimpleUserResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns the invite token
     * This is a unique invite token that allows direct connection to the request user.  Exposing that token presents privacy issues if the token is leaked. Use friend request flow instead if confirmation is required
     * @param userId The id of the user or &#39;me&#39; if logged in
     */
    public getInviteToken (userId: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/invite-token'
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getInviteToken.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get pending invites
     * Invites that the specified user received
     * @param userId The id of the user or &#39;me&#39;
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getInvites (userId: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceSimpleUserResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/invites'
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getInvites.');
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceSimpleUserResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Redeem friendship token
     * Immediately connects the requested user with the user mapped by the provided invite token
     * @param userId The id of the user or &#39;me&#39; if logged in
     * @param token The invite token
     */
    public redeemFriendshipToken (userId: string, token?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/friends/tokens'
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling redeemFriendshipToken.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: token,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Remove or decline a friend
     * 
     * @param userId The id of the user or &#39;me&#39; if logged in
     * @param id The id of the user to befriend
     */
    public removeOrDeclineFriend (userId: string, id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/friends/{id}'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling removeOrDeclineFriend.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling removeOrDeclineFriend.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UsersGroupsApiApiKeys {
}

export class UsersGroupsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: UsersGroupsApiApiKeys, value: string) {
        this.authentications[UsersGroupsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Adds a new member to the group
     * 
     * @param uniqueName The group unique name
     * @param username The username of a user to add to the group
     */
    public addMemberToGroup (uniqueName: string, username: GroupMemberResource) : Promise<{ response: http.ClientResponse; body: GroupMemberResource;  }> {
        const localVarPath = this.basePath + '/users/groups/{unique_name}/members'
            .replace('{' + 'unique_name' + '}', String(uniqueName));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'uniqueName' is not null or undefined
        if (uniqueName === null || uniqueName === undefined) {
            throw new Error('Required parameter uniqueName was null or undefined when calling addMemberToGroup.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling addMemberToGroup.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: username,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GroupMemberResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a group
     * 
     * @param groupResource The new group
     */
    public createGroup (groupResource?: GroupResource) : Promise<{ response: http.ClientResponse; body: GroupResource;  }> {
        const localVarPath = this.basePath + '/users/groups';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: groupResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GroupResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a group template
     * Group Templates define a type of group and the properties they have
     * @param groupTemplateResource The group template resource object
     */
    public createGroupTemplate (groupTemplateResource?: TemplateResource) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/users/groups/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: groupTemplateResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Removes a group from the system IF no resources are attached to it
     * 
     * @param uniqueName The group unique name
     */
    public deleteGroup (uniqueName: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/groups/{unique_name}'
            .replace('{' + 'unique_name' + '}', String(uniqueName));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'uniqueName' is not null or undefined
        if (uniqueName === null || uniqueName === undefined) {
            throw new Error('Required parameter uniqueName was null or undefined when calling deleteGroup.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a group template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    public deleteGroupTemplate (id: string, cascade?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/groups/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteGroupTemplate.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = cascade;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Loads a specific group&#39;s details
     * 
     * @param uniqueName The group unique name
     */
    public getGroup (uniqueName: string) : Promise<{ response: http.ClientResponse; body: GroupResource;  }> {
        const localVarPath = this.basePath + '/users/groups/{unique_name}'
            .replace('{' + 'unique_name' + '}', String(uniqueName));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'uniqueName' is not null or undefined
        if (uniqueName === null || uniqueName === undefined) {
            throw new Error('Required parameter uniqueName was null or undefined when calling getGroup.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GroupResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a user from a group
     * 
     * @param uniqueName The group unique name
     * @param userId The id of the user
     */
    public getGroupMember (uniqueName: string, userId: number) : Promise<{ response: http.ClientResponse; body: GroupMemberResource;  }> {
        const localVarPath = this.basePath + '/users/groups/{unique_name}/members/{user_id}'
            .replace('{' + 'unique_name' + '}', String(uniqueName))
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'uniqueName' is not null or undefined
        if (uniqueName === null || uniqueName === undefined) {
            throw new Error('Required parameter uniqueName was null or undefined when calling getGroupMember.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getGroupMember.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GroupMemberResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Lists members of the group
     * 
     * @param uniqueName The group unique name
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getGroupMembers (uniqueName: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceGroupMemberResource;  }> {
        const localVarPath = this.basePath + '/users/groups/{unique_name}/members'
            .replace('{' + 'unique_name' + '}', String(uniqueName));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'uniqueName' is not null or undefined
        if (uniqueName === null || uniqueName === undefined) {
            throw new Error('Required parameter uniqueName was null or undefined when calling getGroupMembers.');
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceGroupMemberResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single group template
     * 
     * @param id The id of the template
     */
    public getGroupTemplate (id: string) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/users/groups/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getGroupTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search group templates
     * 
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order a comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getGroupTemplates (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }> {
        const localVarPath = this.basePath + '/users/groups/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List groups a user is in
     * 
     * @param userId The id of the user
     */
    public getGroupsForUser (userId: number) : Promise<{ response: http.ClientResponse; body: Array<string>;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/groups'
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getGroupsForUser.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<string>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Removes a user from a group
     * 
     * @param uniqueName The group unique name
     * @param userId The id of the user to remove
     */
    public removeGroupMember (uniqueName: string, userId: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/groups/{unique_name}/members/{user_id}'
            .replace('{' + 'unique_name' + '}', String(uniqueName))
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'uniqueName' is not null or undefined
        if (uniqueName === null || uniqueName === undefined) {
            throw new Error('Required parameter uniqueName was null or undefined when calling removeGroupMember.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling removeGroupMember.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a group
     * 
     * @param uniqueName The group unique name
     * @param groupResource The updated group
     */
    public updateGroup (uniqueName: string, groupResource?: GroupResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/groups/{unique_name}'
            .replace('{' + 'unique_name' + '}', String(uniqueName));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'uniqueName' is not null or undefined
        if (uniqueName === null || uniqueName === undefined) {
            throw new Error('Required parameter uniqueName was null or undefined when calling updateGroup.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: groupResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Change a user&#39;s status
     * 
     * @param uniqueName The group unique name
     * @param userId The user id of the member to modify
     * @param status The new status for the user
     */
    public updateGroupMemberStatus (uniqueName: string, userId: number, status: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/groups/{unique_name}/members/{user_id}/status'
            .replace('{' + 'unique_name' + '}', String(uniqueName))
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'uniqueName' is not null or undefined
        if (uniqueName === null || uniqueName === undefined) {
            throw new Error('Required parameter uniqueName was null or undefined when calling updateGroupMemberStatus.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling updateGroupMemberStatus.');
        }

        // verify required parameter 'status' is not null or undefined
        if (status === null || status === undefined) {
            throw new Error('Required parameter status was null or undefined when calling updateGroupMemberStatus.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: status,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a group template
     * 
     * @param id The id of the template
     * @param groupTemplateResource The group template resource object
     */
    public updateGroupTemplate (id: string, groupTemplateResource?: TemplateResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/groups/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateGroupTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: groupTemplateResource,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search groups
     * 
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public updateGroups (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceGroupResource;  }> {
        const localVarPath = this.basePath + '/users/groups';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceGroupResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UsersInventoryApiApiKeys {
}

export class UsersInventoryApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: UsersInventoryApiApiKeys, value: string) {
        this.authentications[UsersInventoryApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Adds an item to the user inventory
     * The inventory is fulfilled asynchronously UNLESS the invoice is explicitely skipped. Depending on the use case, it might require the client to verify that the entitlement was added after the fact or configure a BRE rule to get a notification in real time
     * @param id The id of the user
     * @param userInventoryAddRequest The user inventory add request object
     */
    public addItemToUserInventory (id: number, userInventoryAddRequest?: UserInventoryAddRequest) : Promise<{ response: http.ClientResponse; body: InvoiceResource;  }> {
        const localVarPath = this.basePath + '/users/{id}/inventory'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling addItemToUserInventory.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: userInventoryAddRequest,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InvoiceResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Check for access to an item without consuming
     * Useful for pre-check and accounts for all various buisness rules
     * @param userId The id of the user to check for or &#39;me&#39; for logged in user
     * @param itemId The id of the item
     * @param sku The specific sku of an entitlement list addition to check entitlement for. This is of very limited and specific use and should generally be left out
     */
    public checkUserEntitlementItem (userId: string, itemId: number, sku?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/entitlements/{item_id}/check'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'item_id' + '}', String(itemId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling checkUserEntitlementItem.');
        }

        // verify required parameter 'itemId' is not null or undefined
        if (itemId === null || itemId === undefined) {
            throw new Error('Required parameter itemId was null or undefined when calling checkUserEntitlementItem.');
        }

        if (sku !== undefined) {
            queryParameters['sku'] = sku;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create an entitlement item
     * 
     * @param entitlementItem The entitlement item object
     */
    public createEntitlementItem (entitlementItem?: EntitlementItem) : Promise<{ response: http.ClientResponse; body: EntitlementItem;  }> {
        const localVarPath = this.basePath + '/entitlements';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: entitlementItem,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntitlementItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create an entitlement template
     * Entitlement templates define a type of entitlement and the properties they have
     * @param template The entitlement template to be created
     */
    public createEntitlementTemplate (template?: ItemTemplateResource) : Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }> {
        const localVarPath = this.basePath + '/entitlements/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: template,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an entitlement item
     * 
     * @param entitlementId The id of the entitlement
     */
    public deleteEntitlementItem (entitlementId: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/entitlements/{entitlement_id}'
            .replace('{' + 'entitlement_id' + '}', String(entitlementId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'entitlementId' is not null or undefined
        if (entitlementId === null || entitlementId === undefined) {
            throw new Error('Required parameter entitlementId was null or undefined when calling deleteEntitlementItem.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an entitlement template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    public deleteEntitlementTemplate (id: string, cascade?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/entitlements/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteEntitlementTemplate.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = cascade;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single entitlement item
     * 
     * @param entitlementId The id of the entitlement
     */
    public getEntitlementItem (entitlementId: number) : Promise<{ response: http.ClientResponse; body: EntitlementItem;  }> {
        const localVarPath = this.basePath + '/entitlements/{entitlement_id}'
            .replace('{' + 'entitlement_id' + '}', String(entitlementId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'entitlementId' is not null or undefined
        if (entitlementId === null || entitlementId === undefined) {
            throw new Error('Required parameter entitlementId was null or undefined when calling getEntitlementItem.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntitlementItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search entitlement items
     * 
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getEntitlementItems (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceEntitlementItem;  }> {
        const localVarPath = this.basePath + '/entitlements';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceEntitlementItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single entitlement template
     * 
     * @param id The id of the template
     */
    public getEntitlementTemplate (id: string) : Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }> {
        const localVarPath = this.basePath + '/entitlements/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getEntitlementTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List and search entitlement templates
     * 
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getEntitlementTemplates (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceItemTemplateResource;  }> {
        const localVarPath = this.basePath + '/entitlements/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceItemTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get an inventory entry
     * 
     * @param userId The id of the inventory owner or &#39;me&#39; for the logged in user
     * @param id The id of the user inventory
     */
    public getUserInventory (userId: number, id: number) : Promise<{ response: http.ClientResponse; body: UserInventoryResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/inventory/{id}'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserInventory.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getUserInventory.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserInventoryResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List the user inventory entries for a given user
     * 
     * @param id The id of the user
     * @param inactive If true, accepts inactive user inventories
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param filterItemName Filter by items whose name starts with a string
     * @param filterMinDate Filter for inventory added after the specified date, unix timestamp in seconds
     * @param filterMaxDate Filter for inventory added before the specified date, unix timestamp in seconds
     */
    public getUserInventory1 (id: number, inactive?: boolean, size?: number, page?: number, filterItemName?: string, filterMinDate?: number, filterMaxDate?: number) : Promise<{ response: http.ClientResponse; body: PageResourceUserInventoryResource;  }> {
        const localVarPath = this.basePath + '/users/{id}/inventory'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getUserInventory1.');
        }

        if (inactive !== undefined) {
            queryParameters['inactive'] = inactive;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (filterItemName !== undefined) {
            queryParameters['filter_item_name'] = filterItemName;
        }

        if (filterMinDate !== undefined) {
            queryParameters['filter_min_date'] = filterMinDate;
        }

        if (filterMaxDate !== undefined) {
            queryParameters['filter_max_date'] = filterMaxDate;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceUserInventoryResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List the log entries for this inventory entry
     * 
     * @param userId The id of the inventory owner or &#39;me&#39; for the logged in user
     * @param id The id of the user inventory
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getUserInventoryLog (userId: string, id: number, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceUserItemLogResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/inventory/{id}/log'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserInventoryLog.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getUserInventoryLog.');
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceUserItemLogResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set the expiration date
     * Will change the current grace period for a subscription but not the bill date (possibly even ending before having the chance to re-bill)
     * @param userId user_id
     * @param id The id of the user inventory
     * @param timestamp The new expiration date as a unix timestamp in seconds. May be null (no body).
     */
    public getUserInventoryLog1 (userId: number, id: number, timestamp?: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/inventory/{id}/expires'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserInventoryLog1.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getUserInventoryLog1.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: timestamp,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List the user inventory entries for all users
     * 
     * @param inactive If true, accepts inactive user inventories
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param filterItemName Filter by items whose name starts with a string
     * @param filterUsername Filter by entries owned by the user with the specified username
     * @param filterGroup Filter by entries owned by the users in a given group, by unique name
     * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE).
     */
    public getUsersInventory (inactive?: boolean, size?: number, page?: number, filterItemName?: string, filterUsername?: string, filterGroup?: string, filterDate?: string) : Promise<{ response: http.ClientResponse; body: PageResourceUserInventoryResource;  }> {
        const localVarPath = this.basePath + '/inventories';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (inactive !== undefined) {
            queryParameters['inactive'] = inactive;
        }

        if (size !== undefined) {
            queryParameters['size'] = size;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (filterItemName !== undefined) {
            queryParameters['filter_item_name'] = filterItemName;
        }

        if (filterUsername !== undefined) {
            queryParameters['filter_username'] = filterUsername;
        }

        if (filterGroup !== undefined) {
            queryParameters['filter_group'] = filterGroup;
        }

        if (filterDate !== undefined) {
            queryParameters['filter_date'] = filterDate;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceUserInventoryResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Grant an entitlement
     * 
     * @param userId The id of the user to grant the entitlement to
     * @param grantRequest grantRequest
     */
    public grantUserEntitlement (userId: number, grantRequest: EntitlementGrantRequest) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/entitlements'
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling grantUserEntitlement.');
        }

        // verify required parameter 'grantRequest' is not null or undefined
        if (grantRequest === null || grantRequest === undefined) {
            throw new Error('Required parameter grantRequest was null or undefined when calling grantUserEntitlement.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: grantRequest,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an entitlement item
     * 
     * @param entitlementId The id of the entitlement
     * @param entitlementItem The entitlement item object
     */
    public updateEntitlementItem (entitlementId: number, entitlementItem?: EntitlementItem) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/entitlements/{entitlement_id}'
            .replace('{' + 'entitlement_id' + '}', String(entitlementId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'entitlementId' is not null or undefined
        if (entitlementId === null || entitlementId === undefined) {
            throw new Error('Required parameter entitlementId was null or undefined when calling updateEntitlementItem.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: entitlementItem,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an entitlement template
     * 
     * @param id The id of the template
     * @param template The updated template
     */
    public updateEntitlementTemplate (id: string, template?: ItemTemplateResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/entitlements/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateEntitlementTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: template,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set the behavior data for an inventory entry
     * 
     * @param userId The id of the user
     * @param id The id of the user inventory
     * @param data The data map
     */
    public updateUserInventoryBehaviorData (userId: number, id: number, data?: any) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/inventory/{id}/behavior-data'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling updateUserInventoryBehaviorData.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateUserInventoryBehaviorData.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: data,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set the status for an inventory entry
     * 
     * @param userId The id of the user
     * @param id The id of the user inventory
     * @param inventoryStatus The inventory status object
     */
    public updateUserInventoryStatus (userId: number, id: number, inventoryStatus?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/inventory/{id}/status'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling updateUserInventoryStatus.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateUserInventoryStatus.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: inventoryStatus,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Use an item
     * 
     * @param userId The id of the user to check for or &#39;me&#39; for logged in user
     * @param itemId The id of the item
     * @param sku The specific sku of an entitlement_list addition to check entitlement for. This is of very limited and specific use and should generally be left out
     * @param info Any additional info to add to the log about this use
     */
    public useUserEntitlementItem (userId: string, itemId: number, sku?: string, info?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/entitlements/{item_id}/use'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'item_id' + '}', String(itemId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling useUserEntitlementItem.');
        }

        // verify required parameter 'itemId' is not null or undefined
        if (itemId === null || itemId === undefined) {
            throw new Error('Required parameter itemId was null or undefined when calling useUserEntitlementItem.');
        }

        if (sku !== undefined) {
            queryParameters['sku'] = sku;
        }

        if (info !== undefined) {
            queryParameters['info'] = info;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UsersRelationshipsApiApiKeys {
}

export class UsersRelationshipsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: UsersRelationshipsApiApiKeys, value: string) {
        this.authentications[UsersRelationshipsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Create a user relationship
     * 
     * @param relationship The new relationship
     */
    public createUserRelationship (relationship?: UserRelationshipResource) : Promise<{ response: http.ClientResponse; body: UserRelationshipResource;  }> {
        const localVarPath = this.basePath + '/users/relationships';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: relationship,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserRelationshipResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a user relationship
     * 
     * @param id The id of the relationship
     */
    public deleteUserRelationship (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/relationships/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteUserRelationship.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a user relationship
     * 
     * @param id The id of the relationship
     */
    public getUserRelationship (id: number) : Promise<{ response: http.ClientResponse; body: UserRelationshipResource;  }> {
        const localVarPath = this.basePath + '/users/relationships/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getUserRelationship.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserRelationshipResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of user relationships
     * 
     */
    public getUserRelationships () : Promise<{ response: http.ClientResponse; body: PageResourceUserRelationshipResource;  }> {
        const localVarPath = this.basePath + '/users/relationships';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceUserRelationshipResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a user relationship
     * 
     * @param id The id of the relationship
     * @param relationship The new relationship
     */
    public updateUserRelationship (id: number, relationship?: UserRelationshipResource) : Promise<{ response: http.ClientResponse; body: UserRelationshipResource;  }> {
        const localVarPath = this.basePath + '/users/relationships/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateUserRelationship.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: relationship,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserRelationshipResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UsersSubscriptionsApiApiKeys {
}

export class UsersSubscriptionsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: UsersSubscriptionsApiApiKeys, value: string) {
        this.authentications[UsersSubscriptionsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Get details about a user&#39;s subscription
     * 
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     */
    public getUserSubscriptionDetails (userId: number, inventoryId: number) : Promise<{ response: http.ClientResponse; body: InventorySubscriptionResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/subscriptions/{inventory_id}'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'inventory_id' + '}', String(inventoryId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserSubscriptionDetails.');
        }

        // verify required parameter 'inventoryId' is not null or undefined
        if (inventoryId === null || inventoryId === undefined) {
            throw new Error('Required parameter inventoryId was null or undefined when calling getUserSubscriptionDetails.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InventorySubscriptionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get details about a user&#39;s subscriptions
     * 
     * @param userId The id of the user
     */
    public getUsersSubscriptionDetails (userId: number) : Promise<{ response: http.ClientResponse; body: Array<InventorySubscriptionResource>;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/subscriptions'
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUsersSubscriptionDetails.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<InventorySubscriptionResource>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Reactivate a subscription and charge fee
     * 
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param reactivateSubscriptionRequest The reactivate subscription request object inventory
     */
    public reactivateUserSubscription (userId: number, inventoryId: number, reactivateSubscriptionRequest?: ReactivateSubscriptionRequest) : Promise<{ response: http.ClientResponse; body: InvoiceResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/subscriptions/{inventory_id}/reactivate'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'inventory_id' + '}', String(inventoryId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling reactivateUserSubscription.');
        }

        // verify required parameter 'inventoryId' is not null or undefined
        if (inventoryId === null || inventoryId === undefined) {
            throw new Error('Required parameter inventoryId was null or undefined when calling reactivateUserSubscription.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: reactivateSubscriptionRequest,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InvoiceResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set a new date to bill a subscription on
     * 
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param billDate The new bill date. Unix timestamp in seconds
     */
    public setSubscriptionBillDate (userId: number, inventoryId: number, billDate: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/subscriptions/{inventory_id}/bill-date'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'inventory_id' + '}', String(inventoryId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling setSubscriptionBillDate.');
        }

        // verify required parameter 'inventoryId' is not null or undefined
        if (inventoryId === null || inventoryId === undefined) {
            throw new Error('Required parameter inventoryId was null or undefined when calling setSubscriptionBillDate.');
        }

        // verify required parameter 'billDate' is not null or undefined
        if (billDate === null || billDate === undefined) {
            throw new Error('Required parameter billDate was null or undefined when calling setSubscriptionBillDate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: billDate,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set the payment method to use for a subscription
     * May send null to use floating default
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param paymentMethodId The id of the payment method
     */
    public setSubscriptionPaymentMethod (userId: number, inventoryId: number, paymentMethodId?: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/subscriptions/{inventory_id}/payment-method'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'inventory_id' + '}', String(inventoryId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling setSubscriptionPaymentMethod.');
        }

        // verify required parameter 'inventoryId' is not null or undefined
        if (inventoryId === null || inventoryId === undefined) {
            throw new Error('Required parameter inventoryId was null or undefined when calling setSubscriptionPaymentMethod.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: paymentMethodId,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set the status of a subscription
     * The body is a json string (put in quotes) that should match a desired invoice status type. Note that the new status may be blocked if the system is not configured to allow the current status to be changed to the new, to enforce proper flow. The default options for statuses are shown below but may be altered for special use cases
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param status The new status for the subscription. Actual options may differ from the indicated set if the invoice status type data has been altered.  Allowable values: (&#39;current&#39;, &#39;canceled&#39;, &#39;stopped&#39;, &#39;payment_failed&#39;, &#39;suspended&#39;)
     */
    public setSubscriptionStatus (userId: number, inventoryId: number, status: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/subscriptions/{inventory_id}/status'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'inventory_id' + '}', String(inventoryId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling setSubscriptionStatus.');
        }

        // verify required parameter 'inventoryId' is not null or undefined
        if (inventoryId === null || inventoryId === undefined) {
            throw new Error('Required parameter inventoryId was null or undefined when calling setSubscriptionStatus.');
        }

        // verify required parameter 'status' is not null or undefined
        if (status === null || status === undefined) {
            throw new Error('Required parameter status was null or undefined when calling setSubscriptionStatus.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: status,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set a new subscription plan for a user
     * 
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param planId The id of the new plan. Must be from the same subscription
     */
    public setUserSubscriptionPlan (userId: number, inventoryId: number, planId?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/subscriptions/{inventory_id}/plan'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'inventory_id' + '}', String(inventoryId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling setUserSubscriptionPlan.');
        }

        // verify required parameter 'inventoryId' is not null or undefined
        if (inventoryId === null || inventoryId === undefined) {
            throw new Error('Required parameter inventoryId was null or undefined when calling setUserSubscriptionPlan.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: planId,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UtilBatchApiApiKeys {
}

export class UtilBatchApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: UtilBatchApiApiKeys, value: string) {
        this.authentications[UtilBatchApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Request to run API call given the method, content type, path url, and body of request
     * 
     * @param batch The batch object
     */
    public sendBatch (batch?: Batch) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/batch';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: batch,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UtilHealthApiApiKeys {
}

export class UtilHealthApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: UtilHealthApiApiKeys, value: string) {
        this.authentications[UtilHealthApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Get health info
     * 
     */
    public getHealth () : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/health';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UtilMaintenanceApiApiKeys {
}

export class UtilMaintenanceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: UtilMaintenanceApiApiKeys, value: string) {
        this.authentications[UtilMaintenanceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Delete maintenance info
     * 
     */
    public deleteMaintenance () : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/maintenance';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get current maintenance info
     * Get current maintenance info. 404 if no maintenance.
     */
    public getMaintenance () : Promise<{ response: http.ClientResponse; body: Maintenance;  }> {
        const localVarPath = this.basePath + '/maintenance';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Maintenance;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set current maintenance info
     * 
     * @param maintenance The maintenance object
     */
    public updateMaintenance (maintenance?: Maintenance) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/maintenance';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: maintenance,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set current maintenance info
     * 
     * @param maintenance The maintenance object
     */
    public updateMaintenance1 (maintenance?: Maintenance) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/maintenance';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: maintenance,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UtilSecurityApiApiKeys {
}

export class UtilSecurityApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: UtilSecurityApiApiKeys, value: string) {
        this.authentications[UtilSecurityApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Returns the authentication log for a user
     * A log entry is recorded everytime a user requests a new token. Standard pagination available
     * @param userId The user id
     */
    public getUserLocationLog (userId?: number) : Promise<{ response: http.ClientResponse; body: PageResourceLocationLogResource;  }> {
        const localVarPath = this.basePath + '/security/country-log';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (userId !== undefined) {
            queryParameters['user_id'] = userId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceLocationLogResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns the authentication token details. Use /users endpoint for detailed user&#39;s info
     * 
     */
    public getUserTokenDetails () : Promise<{ response: http.ClientResponse; body: TokenDetailsResource;  }> {
        const localVarPath = this.basePath + '/me';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.knetik_oauth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TokenDetailsResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UtilVersionApiApiKeys {
}

export class UtilVersionApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'knetik_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: UtilVersionApiApiKeys, value: string) {
        this.authentications[UtilVersionApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.knetik_oauth.accessToken = token;
    }
    /**
     * Get current version info
     * 
     */
    public getVersion () : Promise<{ response: http.ClientResponse; body: Version;  }> {
        const localVarPath = this.basePath + '/version';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Version;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}

/**
 * Knetik Platform API Documentation latest 
 * This is the spec for the Knetik API.  Use this in conjunction with the documentation found at https://knetikcloud.com.
 *
 * OpenAPI spec version: latest 
 * Contact: support@knetik.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import request = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://sandbox.knetikcloud.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class AchievementDefinitionResource {
    /**
    * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this resource type
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * The date/time this resource was created in seconds since unix epoch
    */
    'createdDate': number;
    /**
    * The description of the achievement. Must be at least 2 characters in length.
    */
    'description': string;
    /**
    * Whether the achievement is hidden from the user
    */
    'hidden': boolean;
    /**
    * The name of the achievement. Must be at least 6 characters in length. IMMUTABLE
    */
    'name': string;
    /**
    * The required progress for the achievement definition
    */
    'requiredProgress': number;
    /**
    * The id of the rule generated for this achievement
    */
    'ruleId': string;
    /**
    * The tags for the achievement definition
    */
    'tags': Array<string>;
    /**
    * An achievement template this achievement is validated against (private). May be null and no validation of additional_properties will be done
    */
    'template': string;
    /**
    * The name of the trigger event associated with this achievement
    */
    'triggerEventName': string;
    /**
    * The date/time this resource was last updated in seconds since unix epoch
    */
    'updatedDate': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "additionalProperties",
            "baseName": "additional_properties",
            "type": "{ [key: string]: Property; }"
        },
        {
            "name": "createdDate",
            "baseName": "created_date",
            "type": "number"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "hidden",
            "baseName": "hidden",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "requiredProgress",
            "baseName": "required_progress",
            "type": "number"
        },
        {
            "name": "ruleId",
            "baseName": "rule_id",
            "type": "string"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "template",
            "baseName": "template",
            "type": "string"
        },
        {
            "name": "triggerEventName",
            "baseName": "trigger_event_name",
            "type": "string"
        },
        {
            "name": "updatedDate",
            "baseName": "updated_date",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return AchievementDefinitionResource.attributeTypeMap;
    }
}

export class ActionResource {
    /**
    * The category the action is in. All customer specific actions are in the 'custom' category
    */
    'category': ActionResource.CategoryEnum;
    /**
    * The description of the action
    */
    'description': string;
    /**
    * The name of the action. Used as the unique id for reference
    */
    'name': string;
    /**
    * A list of tags for searching
    */
    'tags': Array<string>;
    /**
    * The variables required for the action
    */
    'variables': Array<ActionVariableResource>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "category",
            "baseName": "category",
            "type": "ActionResource.CategoryEnum"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "variables",
            "baseName": "variables",
            "type": "Array<ActionVariableResource>"
        }    ];

    static getAttributeTypeMap() {
        return ActionResource.attributeTypeMap;
    }
}

export namespace ActionResource {
    export enum CategoryEnum {
        Achievement = <any> 'achievement',
        Behavior = <any> 'behavior',
        Comment = <any> 'comment',
        Disposition = <any> 'disposition',
        Device = <any> 'device',
        Entitlement = <any> 'entitlement',
        Friends = <any> 'friends',
        Fulfillment = <any> 'fulfillment',
        Gamification = <any> 'gamification',
        Inventory = <any> 'inventory',
        Invoice = <any> 'invoice',
        Media = <any> 'media',
        Scheduler = <any> 'scheduler',
        Store = <any> 'store',
        Subscription = <any> 'subscription',
        User = <any> 'user',
        Wallet = <any> 'wallet',
        Custom = <any> 'custom',
        Challenge = <any> 'challenge',
        Activity = <any> 'activity',
        Campaign = <any> 'campaign',
        Event = <any> 'event'
    }
}
export class ActionVariableResource {
    /**
    * The name of the variable
    */
    'name': string;
    /**
    * Whether this variable is optional and can be left out/null
    */
    'optional': boolean;
    /**
    * The type of the variable (see variable type endpoint for list)
    */
    'type': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "optional",
            "baseName": "optional",
            "type": "boolean"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ActionVariableResource.attributeTypeMap;
    }
}

export class ActivityEntitlementResource {
    /**
    * The ISO3 currency code the price is in, if available
    */
    'currencyCode': string;
    /**
    * The id of the entitlement item
    */
    'itemId': number;
    /**
    * The name of the entitlement item
    */
    'name': string;
    /**
    * The price of the sku, if available
    */
    'price': number;
    /**
    * The sku id, if available. If multiple are available, then first one is returned
    */
    'sku': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "itemId",
            "baseName": "item_id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "sku",
            "baseName": "sku",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ActivityEntitlementResource.attributeTypeMap;
    }
}

export class ActivityOccurrenceCreationFailure {
    /**
    * The details of each user's entry, or just the current user's if not run with ACTIVITIES_ADMIN permission
    */
    'userResults': Array<ActivityOccurrenceJoinResult>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "userResults",
            "baseName": "user_results",
            "type": "Array<ActivityOccurrenceJoinResult>"
        }    ];

    static getAttributeTypeMap() {
        return ActivityOccurrenceCreationFailure.attributeTypeMap;
    }
}

export class ActivityOccurrenceJoinResult {
    /**
    * The details on the entitlement object needed to enter the occurrence (if any)
    */
    'entitlement': ActivityEntitlementResource;
    /**
    * Zero if the user was/could be added to the occurrence. Jsapi error code indicating the reason of the failure otherwise
    */
    'errorCode': number;
    /**
    * An error message if failure
    */
    'message': string;
    /**
    * The user's id
    */
    'userId': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "entitlement",
            "baseName": "entitlement",
            "type": "ActivityEntitlementResource"
        },
        {
            "name": "errorCode",
            "baseName": "error_code",
            "type": "number"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "userId",
            "baseName": "user_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ActivityOccurrenceJoinResult.attributeTypeMap;
    }
}

/**
* A occurrence of an activity (the actual game for example). Used to track scores, participants, and provide settings
*/
export class ActivityOccurrenceResource {
    /**
    * The id of the activity
    */
    'activityId': number;
    /**
    * The id of the challenge activity (as part of the event, required if eventId set)
    */
    'challengeActivityId': number;
    /**
    * The date this occurrence was created, unix timestamp in seconds
    */
    'createdDate': number;
    /**
    * The entitlement item required to enter the occurrence. Required if not part of an event. Must come from the set of entitlement items listed in the activity
    */
    'entitlement': ActivityEntitlementResource;
    /**
    * The id of the event
    */
    'eventId': number;
    /**
    * The id of the activity occurrence
    */
    'id': number;
    /**
    * Indicate if the rewards have been given out already
    */
    'rewardStatus': ActivityOccurrenceResource.RewardStatusEnum;
    /**
    * The values selected from the available settings defined for the activity. Ex: difficulty: hard. Can be left out if the activity is played during an event and the settings are already set at the event level. Ex: every monday, difficulty: hard, number of questions: 10, category: sport. Otherwise, the set must exactly match those of the activity.
    */
    'settings': Array<SelectedSettingResource>;
    /**
    * Whether this occurrence will be ran as a simulation. Simulations will not be rewarded. Useful for bot play or trials
    */
    'simulated': boolean;
    /**
    * The date this occurrence was started, unix timestamp in seconds. null if not yet started
    */
    'startDate': number;
    /**
    * The current status of the occurrence (default: OPEN)
    */
    'status': ActivityOccurrenceResource.StatusEnum;
    /**
    * The date this occurrence was last updated, unix timestamp in seconds
    */
    'updatedDate': number;
    /**
    * The list of users participating in this occurrence. Can only be set directly with ACTIVITIES_ADMIN permission
    */
    'users': Array<ActivityUserResource>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "activityId",
            "baseName": "activity_id",
            "type": "number"
        },
        {
            "name": "challengeActivityId",
            "baseName": "challenge_activity_id",
            "type": "number"
        },
        {
            "name": "createdDate",
            "baseName": "created_date",
            "type": "number"
        },
        {
            "name": "entitlement",
            "baseName": "entitlement",
            "type": "ActivityEntitlementResource"
        },
        {
            "name": "eventId",
            "baseName": "event_id",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "rewardStatus",
            "baseName": "reward_status",
            "type": "ActivityOccurrenceResource.RewardStatusEnum"
        },
        {
            "name": "settings",
            "baseName": "settings",
            "type": "Array<SelectedSettingResource>"
        },
        {
            "name": "simulated",
            "baseName": "simulated",
            "type": "boolean"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "number"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "ActivityOccurrenceResource.StatusEnum"
        },
        {
            "name": "updatedDate",
            "baseName": "updated_date",
            "type": "number"
        },
        {
            "name": "users",
            "baseName": "users",
            "type": "Array<ActivityUserResource>"
        }    ];

    static getAttributeTypeMap() {
        return ActivityOccurrenceResource.attributeTypeMap;
    }
}

export namespace ActivityOccurrenceResource {
    export enum RewardStatusEnum {
        Pending = <any> 'pending',
        Failed = <any> 'failed',
        Complete = <any> 'complete',
        Partial = <any> 'partial'
    }
    export enum StatusEnum {
        SETUP = <any> 'SETUP',
        OPEN = <any> 'OPEN',
        PLAYING = <any> 'PLAYING',
        FINISHED = <any> 'FINISHED',
        ABANDONED = <any> 'ABANDONED'
    }
}
export class ActivityOccurrenceResults {
    /**
    * The game results for each user. Include all users that played (paid to get in) even if they were eliminated without a result. A null metric is allowed
    */
    'users': Array<UserActivityResults>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "users",
            "baseName": "users",
            "type": "Array<UserActivityResults>"
        }    ];

    static getAttributeTypeMap() {
        return ActivityOccurrenceResults.attributeTypeMap;
    }
}

export class ActivityOccurrenceResultsResource {
    /**
    * The game results for each user. Include all users that played (paid to get in) even if they were eliminated without a result. A null metric is allowed
    */
    'users': Array<UserActivityResultsResource>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "users",
            "baseName": "users",
            "type": "Array<UserActivityResultsResource>"
        }    ];

    static getAttributeTypeMap() {
        return ActivityOccurrenceResultsResource.attributeTypeMap;
    }
}

/**
* Represents an activity that can be parameterized and tracked through metrics (scores, etc)
*/
export class ActivityResource {
    /**
    * A map of additional properties keyed on the property name. Used to further describe an activity. While settings will vary from one activity occurrence (a game) to another, additional properties are shared by all the occurrences of this activity. Ex: Activity Logo, Disclaimer, Greeting, etc. Validated against template if one exists for activities
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * The date/time this resource was created in seconds since unix epoch
    */
    'createdDate': number;
    /**
    * The list of items that can be used for entitlement (wager amounts/etc)
    */
    'entitlements': Array<ActivityEntitlementResource>;
    /**
    * The unique ID for that resource
    */
    'id': number;
    /**
    * Details about how to launch the activity
    */
    'launch': string;
    /**
    * The user friendly name of that resource. Defaults to blank string
    */
    'longDescription': string;
    /**
    * The user friendly name of that resource
    */
    'name': string;
    /**
    * The rewards to give at the end of each occurence of the activity. When creating/updating only id is used. Reward set must be pre-existing
    */
    'rewardSet': RewardSetResource;
    /**
    * Define what parameters are required/available to start and run an activity. For example: Difficulty, Number of Questions, Character name, Avatar, Duration, etc. Not populated when getting listing
    */
    'settings': Array<AvailableSettingResource>;
    /**
    * The user friendly name of that resource. Defaults to blank string
    */
    'shortDescription': string;
    /**
    * Whether this activity is a template for other activities. Default: false
    */
    'template': boolean;
    /**
    * An activity template this activity is validated against (private). May be null and no validation of additional_properties will be done
    */
    'templateId': string;
    /**
    * The type of the activity
    */
    'type': string;
    /**
    * The unique key (for static reference in code) of the activity
    */
    'uniqueKey': string;
    /**
    * The date/time this resource was last updated in seconds since unix epoch
    */
    'updatedDate': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "additionalProperties",
            "baseName": "additional_properties",
            "type": "{ [key: string]: Property; }"
        },
        {
            "name": "createdDate",
            "baseName": "created_date",
            "type": "number"
        },
        {
            "name": "entitlements",
            "baseName": "entitlements",
            "type": "Array<ActivityEntitlementResource>"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "launch",
            "baseName": "launch",
            "type": "string"
        },
        {
            "name": "longDescription",
            "baseName": "long_description",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "rewardSet",
            "baseName": "reward_set",
            "type": "RewardSetResource"
        },
        {
            "name": "settings",
            "baseName": "settings",
            "type": "Array<AvailableSettingResource>"
        },
        {
            "name": "shortDescription",
            "baseName": "short_description",
            "type": "string"
        },
        {
            "name": "template",
            "baseName": "template",
            "type": "boolean"
        },
        {
            "name": "templateId",
            "baseName": "template_id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "uniqueKey",
            "baseName": "unique_key",
            "type": "string"
        },
        {
            "name": "updatedDate",
            "baseName": "updated_date",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ActivityResource.attributeTypeMap;
    }
}

export class ActivityUserResource {
    /**
    * Whether this user is the 'host' of the occurrence and has increased access to settings/etc (default: false)
    */
    'host': boolean;
    /**
    * The id of the activity user entry
    */
    'id': number;
    /**
    * The date this user last joined the occurrence, unix timestamp in seconds
    */
    'joinedDate': number;
    /**
    * The date this user last left the occurrence, unix timestamp in seconds. Null if still present
    */
    'leftDate': number;
    /**
    * The metric for the user's results, after the game is over
    */
    'metric': MetricResource;
    /**
    * The current status of the user in the occurrence (default: present)
    */
    'status': ActivityUserResource.StatusEnum;
    /**
    * The user
    */
    'user': SimpleUserResource;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "host",
            "baseName": "host",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "joinedDate",
            "baseName": "joined_date",
            "type": "number"
        },
        {
            "name": "leftDate",
            "baseName": "left_date",
            "type": "number"
        },
        {
            "name": "metric",
            "baseName": "metric",
            "type": "MetricResource"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "ActivityUserResource.StatusEnum"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "SimpleUserResource"
        }    ];

    static getAttributeTypeMap() {
        return ActivityUserResource.attributeTypeMap;
    }
}

export namespace ActivityUserResource {
    export enum StatusEnum {
        Present = <any> 'present',
        Ready = <any> 'ready',
        Left = <any> 'left',
        Surrendered = <any> 'surrendered',
        Disconnected = <any> 'disconnected'
    }
}
export class AddressResource {
    /**
    * The first line of the address
    */
    'address1': string;
    /**
    * A second line of the address
    */
    'address2': string;
    /**
    * The city
    */
    'city': string;
    /**
    * The iso3 code for the country
    */
    'countryCode': string;
    /**
    * The postal code
    */
    'postalCode': string;
    /**
    * The code for the state. Required if the country has states/provinces/equivalent
    */
    'stateCode': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "countryCode",
            "baseName": "country_code",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postal_code",
            "type": "string"
        },
        {
            "name": "stateCode",
            "baseName": "state_code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AddressResource.attributeTypeMap;
    }
}

export class AggregateCountResource {
    'count': number;
    'date': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AggregateCountResource.attributeTypeMap;
    }
}

export class AggregateInvoiceReportResource {
    'count': number;
    'date': string;
    'revenue': number;
    'userCount': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        },
        {
            "name": "revenue",
            "baseName": "revenue",
            "type": "number"
        },
        {
            "name": "userCount",
            "baseName": "user_count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return AggregateInvoiceReportResource.attributeTypeMap;
    }
}

export class AmazonS3Activity {
    /**
    * S3 action (i.e., 'PUT') associated with the activity
    */
    'action': string;
    /**
    * URL for accessing the resource via CDN if configured (will default to the main url if not)
    */
    'cdnUrl': string;
    /**
    * Date the resource was created in S3
    */
    'createdDate': number;
    /**
    * Name of the file being processed as a resource in S3
    */
    'filename': string;
    /**
    * Unique id of the S3 activity
    */
    'id': number;
    /**
    * S3 object key for the resource
    */
    'objectKey': string;
    /**
    * URL for posting and later accessing the S3 resource
    */
    'url': string;
    /**
    * The id of the user that created this S3 activity
    */
    'userId': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "action",
            "baseName": "action",
            "type": "string"
        },
        {
            "name": "cdnUrl",
            "baseName": "cdn_url",
            "type": "string"
        },
        {
            "name": "createdDate",
            "baseName": "created_date",
            "type": "number"
        },
        {
            "name": "filename",
            "baseName": "filename",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "objectKey",
            "baseName": "object_key",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "userId",
            "baseName": "user_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return AmazonS3Activity.attributeTypeMap;
    }
}

export class AnswerResource {
    /**
    * The answer to the question. Different 'type' values indicate different structures as the answer may be test, image, etc. See information on additional properties for the list and their structures
    */
    'answer': Property;
    /**
    * Whether the answer is correct or not
    */
    'correct': boolean;
    /**
    * The unique ID for that resource
    */
    'id': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "answer",
            "baseName": "answer",
            "type": "Property"
        },
        {
            "name": "correct",
            "baseName": "correct",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AnswerResource.attributeTypeMap;
    }
}

export class ApplyPaymentRequest {
    /**
    * The id of the local invoice being paid.
    */
    'invoiceId': number;
    /**
    * The encoded receipt string from Apple's services.
    */
    'receipt': string;
    /**
    * The id of the specific transaction from Apple's services.
    */
    'transactionId': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "invoiceId",
            "baseName": "invoice_id",
            "type": "number"
        },
        {
            "name": "receipt",
            "baseName": "receipt",
            "type": "string"
        },
        {
            "name": "transactionId",
            "baseName": "transaction_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApplyPaymentRequest.attributeTypeMap;
    }
}

export class ArticleResource {
    /**
    * Whether the article is active
    */
    'active': boolean;
    /**
    * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * The body of the article
    */
    'body': string;
    /**
    * The category for the article
    */
    'category': NestedCategory;
    /**
    * The date/time this resource was created in seconds since unix epoch
    */
    'createdDate': number;
    /**
    * The id of the article
    */
    'id': string;
    /**
    * The tags for the article
    */
    'tags': Array<string>;
    /**
    * An article template this article is validated against (private). May be null and no validation of additional_properties will be done
    */
    'template': string;
    /**
    * The title of the article
    */
    'title': string;
    /**
    * The date/time this resource was last updated in seconds since unix epoch
    */
    'updatedDate': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "additionalProperties",
            "baseName": "additional_properties",
            "type": "{ [key: string]: Property; }"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "NestedCategory"
        },
        {
            "name": "createdDate",
            "baseName": "created_date",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "template",
            "baseName": "template",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "updatedDate",
            "baseName": "updated_date",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ArticleResource.attributeTypeMap;
    }
}

export class ArtistResource {
    /**
    * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * YYYY/MM/DD when this artist was born
    */
    'born': string;
    /**
    * The current number of contributions the artist has made
    */
    'contributionCount': number;
    /**
    * The list of media this artist has contributed to as well as role(s) during contribution.  Use media endpoint to add contributions
    */
    'contributions': Array<ContributionResource>;
    /**
    * The date/time this resource was created in seconds since unix epoch
    */
    'createdDate': number;
    /**
    * YYYY/MM/DD when this artist died
    */
    'died': string;
    /**
    * The unique ID for that resource
    */
    'id': number;
    /**
    * The user friendly name of that resource. Defaults to blank string
    */
    'longDescription': string;
    /**
    * The user friendly name of that resource
    */
    'name': string;
    /**
    * The sort order priority ofr the artist.  Default 100
    */
    'priority': number;
    /**
    * The user friendly name of that resource. Defaults to blank string
    */
    'shortDescription': string;
    /**
    * An artist template this artist is validated against (private). May be null and no validation of additional_properties will be done
    */
    'template': string;
    /**
    * The date/time this resource was last updated in seconds since unix epoch
    */
    'updatedDate': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "additionalProperties",
            "baseName": "additional_properties",
            "type": "{ [key: string]: Property; }"
        },
        {
            "name": "born",
            "baseName": "born",
            "type": "string"
        },
        {
            "name": "contributionCount",
            "baseName": "contribution_count",
            "type": "number"
        },
        {
            "name": "contributions",
            "baseName": "contributions",
            "type": "Array<ContributionResource>"
        },
        {
            "name": "createdDate",
            "baseName": "created_date",
            "type": "number"
        },
        {
            "name": "died",
            "baseName": "died",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "longDescription",
            "baseName": "long_description",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "priority",
            "baseName": "priority",
            "type": "number"
        },
        {
            "name": "shortDescription",
            "baseName": "short_description",
            "type": "string"
        },
        {
            "name": "template",
            "baseName": "template",
            "type": "string"
        },
        {
            "name": "updatedDate",
            "baseName": "updated_date",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ArtistResource.attributeTypeMap;
    }
}

/**
* The definition of an activity parameters: ex: difficulty level
*/
export class AvailableSettingResource {
    /**
    * Whether the setting is advanced. Default: false
    */
    'advancedOption': boolean;
    /**
    * The default value of the setting (must be in options array). Ex: easy
    */
    'defaultValue': string;
    /**
    * The description of the setting: Ex: Choose the difficulty level to show more or less complicated questions (for a trivia activity)
    */
    'description': string;
    /**
    * The unique ID for the setting: Ex: difficulty
    */
    'key': string;
    /**
    * The textual name of the setting: Ex: Difficulty Level
    */
    'name': string;
    /**
    * The set of options available for this setting, Ex: easy, medium, hard
    */
    'options': Array<SettingOption>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "advancedOption",
            "baseName": "advanced_option",
            "type": "boolean"
        },
        {
            "name": "defaultValue",
            "baseName": "default_value",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "options",
            "baseName": "options",
            "type": "Array<SettingOption>"
        }    ];

    static getAttributeTypeMap() {
        return AvailableSettingResource.attributeTypeMap;
    }
}

export class BareActivityResource {
    /**
    * The date/time this resource was created in seconds since unix epoch
    */
    'createdDate': number;
    /**
    * The unique ID for that resource
    */
    'id': number;
    /**
    * Details about how to launch the activity
    */
    'launch': string;
    /**
    * The user friendly name of that resource. Defaults to blank string
    */
    'longDescription': string;
    /**
    * The user friendly name of that resource
    */
    'name': string;
    /**
    * The user friendly name of that resource. Defaults to blank string
    */
    'shortDescription': string;
    /**
    * Whether this activity is a template for other activities. Default: false
    */
    'template': boolean;
    /**
    * The type of the activity
    */
    'type': string;
    /**
    * The unique key (for static reference in code) of the activity
    */
    'uniqueKey': string;
    /**
    * The date/time this resource was last updated in seconds since unix epoch
    */
    'updatedDate': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdDate",
            "baseName": "created_date",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "launch",
            "baseName": "launch",
            "type": "string"
        },
        {
            "name": "longDescription",
            "baseName": "long_description",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "shortDescription",
            "baseName": "short_description",
            "type": "string"
        },
        {
            "name": "template",
            "baseName": "template",
            "type": "boolean"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "uniqueKey",
            "baseName": "unique_key",
            "type": "string"
        },
        {
            "name": "updatedDate",
            "baseName": "updated_date",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return BareActivityResource.attributeTypeMap;
    }
}

export class BareChallengeActivityResource {
    /**
    * The id of the activity
    */
    'activityId': number;
    /**
    * The id of the challenge
    */
    'challengeId': number;
    /**
    * The unique ID for this resource
    */
    'id': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "activityId",
            "baseName": "activity_id",
            "type": "number"
        },
        {
            "name": "challengeId",
            "baseName": "challenge_id",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return BareChallengeActivityResource.attributeTypeMap;
    }
}

export class Batch {
    /**
    * The list of batch requests
    */
    'batch': Array<BatchRequest>;
    /**
    * The amount of time before a request token is returned instead of the batch result.  Default is 60.  Range is 0-300
    */
    'timeout': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "batch",
            "baseName": "batch",
            "type": "Array<BatchRequest>"
        },
        {
            "name": "timeout",
            "baseName": "timeout",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Batch.attributeTypeMap;
    }
}

export class BatchRequest {
    /**
    * The request body as would be passed to the URI
    */
    'body': any;
    /**
    * Content type used, Ex:(application/json)
    */
    'contentType': string;
    /**
    * The HTTP method used, Ex: (GET)
    */
    'method': string;
    /**
    * Time in seconds before process will timeout.  Default is 60.  Range is 1-300
    */
    'timeout': number;
    /**
    * The oauth token only
    */
    'token': string;
    /**
    * Full URI of REST call
    */
    'uri': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "any"
        },
        {
            "name": "contentType",
            "baseName": "content_type",
            "type": "string"
        },
        {
            "name": "method",
            "baseName": "method",
            "type": "string"
        },
        {
            "name": "timeout",
            "baseName": "timeout",
            "type": "number"
        },
        {
            "name": "token",
            "baseName": "token",
            "type": "string"
        },
        {
            "name": "uri",
            "baseName": "uri",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BatchRequest.attributeTypeMap;
    }
}

export class BatchResult {
    /**
    * List of batch responses.  Returns in the order requested
    */
    'batchReturn': Array<BatchReturn>;
    /**
    * The date the batch call started processing
    */
    'createdDate': number;
    /**
    * The token to use at the /batch/{token} endpoint if the request times out
    */
    'id': string;
    /**
    * The date the batch call finished processing
    */
    'updatedDate': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "batchReturn",
            "baseName": "batch_return",
            "type": "Array<BatchReturn>"
        },
        {
            "name": "createdDate",
            "baseName": "created_date",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "updatedDate",
            "baseName": "updated_date",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return BatchResult.attributeTypeMap;
    }
}

export class BatchReturn {
    /**
    * The result body
    */
    'body': any;
    /**
    * The HTTP response code
    */
    'code': number;
    /**
    * Full URI of REST call
    */
    'uri': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "any"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "uri",
            "baseName": "uri",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BatchReturn.attributeTypeMap;
    }
}

export class Behavior {
    'description': string;
    /**
    * Used for polymorphic type recognition and thus must match an expected type with additional properties
    */
    'typeHint': string;

    static discriminator = type_hint;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "typeHint",
            "baseName": "type_hint",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Behavior.attributeTypeMap;
    }
}

export class BehaviorDefinitionResource {
    /**
    * Description of the behavior
    */
    'description': string;
    /**
    * Pre-requisite behaviors that an item must have in order to also have this behavior
    */
    'prerequisiteBehaviors': Array<Behavior>;
    /**
    * Configurable properties of the behavior
    */
    'properties': Array<PropertyFieldResource>;
    /**
    * The behavior type
    */
    'typeHint': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "prerequisiteBehaviors",
            "baseName": "prerequisite_behaviors",
            "type": "Array<Behavior>"
        },
        {
            "name": "properties",
            "baseName": "properties",
            "type": "Array<PropertyFieldResource>"
        },
        {
            "name": "typeHint",
            "baseName": "type_hint",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BehaviorDefinitionResource.attributeTypeMap;
    }
}

export class BillingReport {
    'created': number;
    'id': string;
    'lastKnownFailures': Array<string>;
    'statistics': { [key: string]: number; };

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "created",
            "baseName": "created",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "lastKnownFailures",
            "baseName": "last_known_failures",
            "type": "Array<string>"
        },
        {
            "name": "statistics",
            "baseName": "statistics",
            "type": "{ [key: string]: number; }"
        }    ];

    static getAttributeTypeMap() {
        return BillingReport.attributeTypeMap;
    }
}

export class BooleanResource {
    'value': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "value",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return BooleanResource.attributeTypeMap;
    }
}

export class BreCategoryResource {
    /**
    * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * The name of the category. Serves as the unique id
    */
    'name': string;
    /**
    * A template this BRE category is validated against (private). May be null and no validation of additional_properties will be done
    */
    'template': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "additionalProperties",
            "baseName": "additional_properties",
            "type": "{ [key: string]: Property; }"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "template",
            "baseName": "template",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BreCategoryResource.attributeTypeMap;
    }
}

export class BreEvent {
    /**
    * The event name of the trigger to be fired
    */
    'eventName': string;
    /**
    * The parameters to the event. A Map (assosiative array) with a key for each trigger parameter name and a corrosponding value.
    */
    'params': any;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "eventName",
            "baseName": "event_name",
            "type": "string"
        },
        {
            "name": "params",
            "baseName": "params",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return BreEvent.attributeTypeMap;
    }
}

export class BreEventLog {
    /**
    * The customer of the BRE event log
    */
    'customer': string;
    /**
    * The event id of the BRE event log
    */
    'eventId': string;
    /**
    * The event name of the BRE event log
    */
    'eventName': string;
    /**
    * The event start date of the BRE event log
    */
    'eventStartDate': number;
    /**
    * The id of the BRE event log
    */
    'id': string;
    /**
    * The event paramters of the BRE event log
    */
    'parameters': any;
    /**
    * The rules of the BRE event log
    */
    'rules': Array<BreRuleLog>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "customer",
            "baseName": "customer",
            "type": "string"
        },
        {
            "name": "eventId",
            "baseName": "event_id",
            "type": "string"
        },
        {
            "name": "eventName",
            "baseName": "event_name",
            "type": "string"
        },
        {
            "name": "eventStartDate",
            "baseName": "event_start_date",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "parameters",
            "baseName": "parameters",
            "type": "any"
        },
        {
            "name": "rules",
            "baseName": "rules",
            "type": "Array<BreRuleLog>"
        }    ];

    static getAttributeTypeMap() {
        return BreEventLog.attributeTypeMap;
    }
}

export class BreGlobalResource {
    /**
    * A human readable description for display in admin pages
    */
    'description': string;
    /**
    * The id of the global definition. Default is a random guid. Cannot be updated
    */
    'id': string;
    /**
    * The key for the global. Must be unique when combined with scope names. Usually a single descriptive word like 'purchases' or 'logins'
    */
    'key': string;
    /**
    * A human readable name for display in admin pages
    */
    'name': string;
    /**
    * A list of scoping parameters. Allows the global to have a different value in different context such as a count of purchases for each user (by putting a 'user' scope in this list). When using this global in a rule these scopes will need to be mapped with an expression to provide a value, similar to the parameters in an action
    */
    'scopes': Array<BreGlobalScopeDefinition>;
    /**
    * Where this global came from. System globals cannot be removed or updated
    */
    'systemGlobal': boolean;
    /**
    * The variable type the global stores. See the See Bre Variables enpoint for list
    */
    'type': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "scopes",
            "baseName": "scopes",
            "type": "Array<BreGlobalScopeDefinition>"
        },
        {
            "name": "systemGlobal",
            "baseName": "system_global",
            "type": "boolean"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BreGlobalResource.attributeTypeMap;
    }
}

export class BreGlobalScopeDefinition {
    /**
    * The name of the scoping parameter. This is used as the unique identifier of this scope
    */
    'name': string;
    /**
    * The variable type of this scoping parameter. See Bre Variables endpoint for list
    */
    'type': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BreGlobalScopeDefinition.attributeTypeMap;
    }
}

export class BreRule {
    /**
    * A list of actions to execute, and the mapping for their parameters, when the rule runs. Minimum 1
    */
    'actions': ActionResource;
    /**
    * A condition expression that must be met in a given event for the rule to run. Empty to always run
    */
    'condition': PredicateOperation;
    /**
    * The condition as a readable string. Filled in by the system from the condition
    */
    'conditionText': string;
    /**
    * The human readable description of the rule
    */
    'description': string;
    /**
    * Whether the rule is enabled to run (in conjunction with dates). Default true
    */
    'enabled': boolean;
    /**
    * The date the rule ceases to take effect, or null if never. Unix timestamp in seconds
    */
    'endDate': number;
    /**
    * The event name of the trigger this rule runs for. Affects which parameters are available
    */
    'eventName': string;
    /**
    * The id of the rule for later references. If left null a random guid will be generated. Must be unique. Cannot be changed
    */
    'id': string;
    /**
    * The human readable name of the rule
    */
    'name': string;
    /**
    * Used to sort rules to control the order they run in. Larger numbered sort values run first.  Default 500
    */
    'sort': number;
    /**
    * The date the rule begins to take effect, or null if always. Unix timestamp in seconds
    */
    'startDate': number;
    /**
    * Whether the rule is a default part of the system. System rules cannot be edited or deleted, but may be disabled
    */
    'systemRule': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "actions",
            "baseName": "actions",
            "type": "ActionResource"
        },
        {
            "name": "condition",
            "baseName": "condition",
            "type": "PredicateOperation"
        },
        {
            "name": "conditionText",
            "baseName": "condition_text",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "endDate",
            "baseName": "end_date",
            "type": "number"
        },
        {
            "name": "eventName",
            "baseName": "event_name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "number"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "number"
        },
        {
            "name": "systemRule",
            "baseName": "system_rule",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return BreRule.attributeTypeMap;
    }
}

export class BreRuleLog {
    /**
    * Whether the rule ran
    */
    'ran': boolean;
    /**
    * The reason for the rule
    */
    'reason': string;
    /**
    * The end date of the rule in seconds
    */
    'ruleEndDate': number;
    /**
    * The id of the rule
    */
    'ruleId': string;
    /**
    * The name of the rule
    */
    'ruleName': string;
    /**
    * The start date of the rule in seconds
    */
    'ruleStartDate': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ran",
            "baseName": "ran",
            "type": "boolean"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "ruleEndDate",
            "baseName": "rule_end_date",
            "type": "number"
        },
        {
            "name": "ruleId",
            "baseName": "rule_id",
            "type": "string"
        },
        {
            "name": "ruleName",
            "baseName": "rule_name",
            "type": "string"
        },
        {
            "name": "ruleStartDate",
            "baseName": "rule_start_date",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return BreRuleLog.attributeTypeMap;
    }
}

export class BreTriggerParameterDefinition {
    /**
    * The name of the parameter. This is used as the unique identifier of this parameter
    */
    'name': string;
    /**
    * Whether this parameter can be left off when firing the event. Default false
    */
    'optional': boolean;
    /**
    * The variable type of this parameter. See Bre Variables endpoint for list
    */
    'type': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "optional",
            "baseName": "optional",
            "type": "boolean"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BreTriggerParameterDefinition.attributeTypeMap;
    }
}

export class BreTriggerResource {
    /**
    * The category this trigger belongs to. See endpoints for related asset information. All new triggers are in category 'custom'
    */
    'category': BreTriggerResource.CategoryEnum;
    /**
    * The unique name for the event. This serves as the unique identifier. Cannot be changed after creation
    */
    'eventName': string;
    /**
    * A list of parameters that will be sent with the event when the trigger is fired. These must be included in the event and match the described types
    */
    'parameters': Array<BreTriggerParameterDefinition>;
    /**
    * Where this trigger came from. System triggers cannot be removed or updated
    */
    'systemTrigger': boolean;
    /**
    * A list of tags for filtering
    */
    'tags': Array<string>;
    /**
    * A description of the trigger
    */
    'triggerDescription': string;
    /**
    * A human readable name for this trigger
    */
    'triggerName': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "category",
            "baseName": "category",
            "type": "BreTriggerResource.CategoryEnum"
        },
        {
            "name": "eventName",
            "baseName": "event_name",
            "type": "string"
        },
        {
            "name": "parameters",
            "baseName": "parameters",
            "type": "Array<BreTriggerParameterDefinition>"
        },
        {
            "name": "systemTrigger",
            "baseName": "system_trigger",
            "type": "boolean"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "triggerDescription",
            "baseName": "trigger_description",
            "type": "string"
        },
        {
            "name": "triggerName",
            "baseName": "trigger_name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BreTriggerResource.attributeTypeMap;
    }
}

export namespace BreTriggerResource {
    export enum CategoryEnum {
        Achievement = <any> 'achievement',
        Behavior = <any> 'behavior',
        Comment = <any> 'comment',
        Disposition = <any> 'disposition',
        Device = <any> 'device',
        Entitlement = <any> 'entitlement',
        Friends = <any> 'friends',
        Fulfillment = <any> 'fulfillment',
        Gamification = <any> 'gamification',
        Inventory = <any> 'inventory',
        Invoice = <any> 'invoice',
        Media = <any> 'media',
        Scheduler = <any> 'scheduler',
        Store = <any> 'store',
        Subscription = <any> 'subscription',
        User = <any> 'user',
        Wallet = <any> 'wallet',
        Custom = <any> 'custom',
        Challenge = <any> 'challenge',
        Activity = <any> 'activity',
        Campaign = <any> 'campaign',
        Event = <any> 'event'
    }
}
export class BroadcastableEvent {
    'client': string;
    'customer': string;
    'doNotBroadcast': boolean;
    'section': string;
    'source': any;
    'specifics': string;
    'synchronous': boolean;
    'timestamp': number;
    /**
    * The type of the event. Used for polymorphic type recognition and thus must match an expected type
    */
    'type': string;

    static discriminator = type;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "client",
            "baseName": "client",
            "type": "string"
        },
        {
            "name": "customer",
            "baseName": "customer",
            "type": "string"
        },
        {
            "name": "doNotBroadcast",
            "baseName": "do_not_broadcast",
            "type": "boolean"
        },
        {
            "name": "section",
            "baseName": "section",
            "type": "string"
        },
        {
            "name": "source",
            "baseName": "source",
            "type": "any"
        },
        {
            "name": "specifics",
            "baseName": "specifics",
            "type": "string"
        },
        {
            "name": "synchronous",
            "baseName": "synchronous",
            "type": "boolean"
        },
        {
            "name": "timestamp",
            "baseName": "timestamp",
            "type": "number"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BroadcastableEvent.attributeTypeMap;
    }
}

export class BundledSku {
    /**
    * The amount this item will cost inside the bundle instead of its regular price
    */
    'priceOverride': number;
    /**
    * The quantity of this item within the bundle
    */
    'quantity': number;
    /**
    * The stock keeping unit (SKU) for an item included in the bundle
    */
    'sku': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "priceOverride",
            "baseName": "price_override",
            "type": "number"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "sku",
            "baseName": "sku",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BundledSku.attributeTypeMap;
    }
}

export class CampaignResource {
    /**
    * Whether the campaign is active or not.  Defaults to false
    */
    'active': boolean;
    /**
    * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * The date/time this resource was created in seconds since unix epoch
    */
    'createdDate': number;
    /**
    * The unique ID for that resource
    */
    'id': number;
    /**
    * The strategy for calculating the leaderboard. Defaults to highest score. Value MUST come from the list of available strategies from the Leaderboard Service
    */
    'leaderboardStrategy': string;
    /**
    * The user friendly name of that resource. Defaults to blank string
    */
    'longDescription': string;
    /**
    * The user friendly name of that resource
    */
    'name': string;
    /**
    * The name of the next challenge coming up
    */
    'nextChallenge': string;
    /**
    * The date/time of the next challenge coming up
    */
    'nextChallengeDate': number;
    /**
    * The rewards to give at the end of the campaign. When creating/updating only id is used. Reward set must be pre-existing
    */
    'rewardSet': RewardSetResource;
    /**
    * Indicate if the rewards have been given out already
    */
    'rewardStatus': CampaignResource.RewardStatusEnum;
    /**
    * The user friendly name of that resource. Defaults to blank string
    */
    'shortDescription': string;
    /**
    * A campaign template this campaign is validated against (private). May be null and no validation of additional_properties will be done
    */
    'template': string;
    /**
    * The date/time this resource was last updated in seconds since unix epoch
    */
    'updatedDate': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "additionalProperties",
            "baseName": "additional_properties",
            "type": "{ [key: string]: Property; }"
        },
        {
            "name": "createdDate",
            "baseName": "created_date",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "leaderboardStrategy",
            "baseName": "leaderboard_strategy",
            "type": "string"
        },
        {
            "name": "longDescription",
            "baseName": "long_description",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "nextChallenge",
            "baseName": "next_challenge",
            "type": "string"
        },
        {
            "name": "nextChallengeDate",
            "baseName": "next_challenge_date",
            "type": "number"
        },
        {
            "name": "rewardSet",
            "baseName": "reward_set",
            "type": "RewardSetResource"
        },
        {
            "name": "rewardStatus",
            "baseName": "reward_status",
            "type": "CampaignResource.RewardStatusEnum"
        },
        {
            "name": "shortDescription",
            "baseName": "short_description",
            "type": "string"
        },
        {
            "name": "template",
            "baseName": "template",
            "type": "string"
        },
        {
            "name": "updatedDate",
            "baseName": "updated_date",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CampaignResource.attributeTypeMap;
    }
}

export namespace CampaignResource {
    export enum RewardStatusEnum {
        Pending = <any> 'pending',
        Failed = <any> 'failed',
        Complete = <any> 'complete',
        Partial = <any> 'partial'
    }
}
export class Cart {
    'availableShippingOptions': Array<CartShippingOption>;
    'countryTax': number;
    'coupons': Array<CouponDefinition>;
    'created': number;
    'currencyCode': string;
    'discountTotal': number;
    'errorCode': number;
    'errorMessage': string;
    'grandTotal': number;
    'id': string;
    'invoiceId': number;
    'items': Array<CartLineItem>;
    'owner': number;
    'selectedShippingOptions': Array<CartShippingOption>;
    'shippable': boolean;
    'shippingAddress': CartShippingAddressRequest;
    'shippingCost': number;
    'stateTax': number;
    'status': Cart.StatusEnum;
    'subtotal': number;
    'updated': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "availableShippingOptions",
            "baseName": "available_shipping_options",
            "type": "Array<CartShippingOption>"
        },
        {
            "name": "countryTax",
            "baseName": "country_tax",
            "type": "number"
        },
        {
            "name": "coupons",
            "baseName": "coupons",
            "type": "Array<CouponDefinition>"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "number"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "discountTotal",
            "baseName": "discount_total",
            "type": "number"
        },
        {
            "name": "errorCode",
            "baseName": "error_code",
            "type": "number"
        },
        {
            "name": "errorMessage",
            "baseName": "error_message",
            "type": "string"
        },
        {
            "name": "grandTotal",
            "baseName": "grand_total",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "invoiceId",
            "baseName": "invoice_id",
            "type": "number"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<CartLineItem>"
        },
        {
            "name": "owner",
            "baseName": "owner",
            "type": "number"
        },
        {
            "name": "selectedShippingOptions",
            "baseName": "selected_shipping_options",
            "type": "Array<CartShippingOption>"
        },
        {
            "name": "shippable",
            "baseName": "shippable",
            "type": "boolean"
        },
        {
            "name": "shippingAddress",
            "baseName": "shipping_address",
            "type": "CartShippingAddressRequest"
        },
        {
            "name": "shippingCost",
            "baseName": "shipping_cost",
            "type": "number"
        },
        {
            "name": "stateTax",
            "baseName": "state_tax",
            "type": "number"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "Cart.StatusEnum"
        },
        {
            "name": "subtotal",
            "baseName": "subtotal",
            "type": "number"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Cart.attributeTypeMap;
    }
}

export namespace Cart {
    export enum StatusEnum {
        Active = <any> 'active',
        Processing = <any> 'processing',
        Closed = <any> 'closed',
        Onhold = <any> 'onhold'
    }
}
export class CartItemRequest {
    /**
    * The affiliate key of the item
    */
    'affiliateKey': string;
    /**
    * The catalog SKU of the item
    */
    'catalogSku': string;
    /**
    * Allows to override the price of an item, if the behavior configuration permits it
    */
    'priceOverride': number;
    /**
    * The quantity of the item
    */
    'quantity': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "affiliateKey",
            "baseName": "affiliate_key",
            "type": "string"
        },
        {
            "name": "catalogSku",
            "baseName": "catalog_sku",
            "type": "string"
        },
        {
            "name": "priceOverride",
            "baseName": "price_override",
            "type": "number"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CartItemRequest.attributeTypeMap;
    }
}

export class CartLineItem {
    'currencyCode': string;
    'description': string;
    'discount': Discount;
    'lineTotal': number;
    'name': string;
    'originalLineTotal': number;
    'originalUnitPrice': number;
    'qty': number;
    'saleName': string;
    'sku': string;
    'skuDescription': string;
    'storeItemId': number;
    'tags': Array<string>;
    'thumbUrl': string;
    'uniqueKey': string;
    'unitPrice': number;
    'vendorId': number;
    'vendorName': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "discount",
            "baseName": "discount",
            "type": "Discount"
        },
        {
            "name": "lineTotal",
            "baseName": "line_total",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "originalLineTotal",
            "baseName": "original_line_total",
            "type": "number"
        },
        {
            "name": "originalUnitPrice",
            "baseName": "original_unit_price",
            "type": "number"
        },
        {
            "name": "qty",
            "baseName": "qty",
            "type": "number"
        },
        {
            "name": "saleName",
            "baseName": "sale_name",
            "type": "string"
        },
        {
            "name": "sku",
            "baseName": "sku",
            "type": "string"
        },
        {
            "name": "skuDescription",
            "baseName": "sku_description",
            "type": "string"
        },
        {
            "name": "storeItemId",
            "baseName": "store_item_id",
            "type": "number"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "thumbUrl",
            "baseName": "thumb_url",
            "type": "string"
        },
        {
            "name": "uniqueKey",
            "baseName": "unique_key",
            "type": "string"
        },
        {
            "name": "unitPrice",
            "baseName": "unit_price",
            "type": "number"
        },
        {
            "name": "vendorId",
            "baseName": "vendor_id",
            "type": "number"
        },
        {
            "name": "vendorName",
            "baseName": "vendor_name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CartLineItem.attributeTypeMap;
    }
}

export class CartShippableResponse {
    /**
    * The id of the cart
    */
    'cartId': number;
    /**
    * Whether the item is shippable
    */
    'shippable': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cartId",
            "baseName": "cart_id",
            "type": "number"
        },
        {
            "name": "shippable",
            "baseName": "shippable",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CartShippableResponse.attributeTypeMap;
    }
}

export class CartShippingAddressRequest {
    /**
    * The city of the user
    */
    'city': string;
    /**
    * The country code of the user
    */
    'countryCodeIso3': string;
    /**
    * The email of the user
    */
    'email': string;
    /**
    * The first name of the user
    */
    'firstName': string;
    /**
    * The last name of the user
    */
    'lastName': string;
    'namePrefix': string;
    /**
    * The order notes the user
    */
    'orderNotes': string;
    /**
    * The phone number of the user
    */
    'phoneNumber': string;
    /**
    * The postal state code of the user
    */
    'postalStateCode': string;
    /**
    * The shipping address of the user, first line
    */
    'shippingAddressLine1': string;
    /**
    * The shipping address of the user, second line
    */
    'shippingAddressLine2': string;
    /**
    * The zipcode of the user
    */
    'zip': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "countryCodeIso3",
            "baseName": "country_code_iso3",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "first_name",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "last_name",
            "type": "string"
        },
        {
            "name": "namePrefix",
            "baseName": "name_prefix",
            "type": "string"
        },
        {
            "name": "orderNotes",
            "baseName": "order_notes",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phone_number",
            "type": "string"
        },
        {
            "name": "postalStateCode",
            "baseName": "postal_state_code",
            "type": "string"
        },
        {
            "name": "shippingAddressLine1",
            "baseName": "shipping_address_line1",
            "type": "string"
        },
        {
            "name": "shippingAddressLine2",
            "baseName": "shipping_address_line2",
            "type": "string"
        },
        {
            "name": "zip",
            "baseName": "zip",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CartShippingAddressRequest.attributeTypeMap;
    }
}

export class CartShippingOption {
    'currencyCode': string;
    'description': string;
    'name': string;
    'originalPrice': number;
    'price': number;
    'shippingItemId': number;
    'sku': string;
    'taxable': boolean;
    'vendorId': number;
    'vendorName': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "originalPrice",
            "baseName": "original_price",
            "type": "number"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "shippingItemId",
            "baseName": "shipping_item_id",
            "type": "number"
        },
        {
            "name": "sku",
            "baseName": "sku",
            "type": "string"
        },
        {
            "name": "taxable",
            "baseName": "taxable",
            "type": "boolean"
        },
        {
            "name": "vendorId",
            "baseName": "vendor_id",
            "type": "number"
        },
        {
            "name": "vendorName",
            "baseName": "vendor_name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CartShippingOption.attributeTypeMap;
    }
}

export class CartSummary {
    /**
    * The date/time this resource was created in seconds since unix epoch
    */
    'createdDate': number;
    /**
    * The unique id code for the currency used in the cart
    */
    'currencyCode': string;
    /**
    * The grand total for the cart
    */
    'grandTotal': number;
    /**
    * The unique ID for the cart
    */
    'id': string;
    /**
    * The ID of the invoice associated with this cart
    */
    'invoiceId': number;
    /**
    * The number of items in the cart
    */
    'itemsInCart': number;
    /**
    * The status of the cart
    */
    'status': CartSummary.StatusEnum;
    /**
    * The subtotal of all items in the cart
    */
    'subtotal': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdDate",
            "baseName": "created_date",
            "type": "number"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "grandTotal",
            "baseName": "grand_total",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "invoiceId",
            "baseName": "invoice_id",
            "type": "number"
        },
        {
            "name": "itemsInCart",
            "baseName": "items_in_cart",
            "type": "number"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "CartSummary.StatusEnum"
        },
        {
            "name": "subtotal",
            "baseName": "subtotal",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CartSummary.attributeTypeMap;
    }
}

export namespace CartSummary {
    export enum StatusEnum {
        Active = <any> 'active',
        Processing = <any> 'processing',
        Closed = <any> 'closed',
        Onhold = <any> 'onhold'
    }
}
export class CatalogSale {
    /**
    * The iso3 code for the currency for this discountValue.  The sku purchased will have to match for it this sale to apply
    */
    'currencyCode': string;
    /**
    * The way in which the price is reduced. 'value' means subtracting directly, 'percentage' means subtracting by the price times the discountValue (1.0 == 100%)
    */
    'discountType': CatalogSale.DiscountTypeEnum;
    /**
    * The amount deducted from the price, in the same currencyCode as the item
    */
    'discountValue': number;
    /**
    * The id of the sale
    */
    'id': number;
    /**
    * The id of the item this sale applies to.  Leave null to use other filters
    */
    'item': number;
    /**
    * The long description of the sale
    */
    'longDescription': string;
    /**
    * The name of the sale.  Max 40 characters
    */
    'name': string;
    /**
    * The date the sale ends, null for never.  Unix timestamp in seconds
    */
    'saleEndDate': number;
    /**
    * The date the sale begins.  Unix timestamp in seconds
    */
    'saleStartDate': number;
    /**
    * The short description of the sale.  Max 140 characters
    */
    'shortDescription': string;
    /**
    * The tag this sale applies to.  Leave null to skip this filter (applies to all tags)
    */
    'tag': string;
    /**
    * The id of the vendor this sale applies to.  Leave null to skip this filter (applies to all vendors)
    */
    'vendor': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "discountType",
            "baseName": "discount_type",
            "type": "CatalogSale.DiscountTypeEnum"
        },
        {
            "name": "discountValue",
            "baseName": "discount_value",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "item",
            "baseName": "item",
            "type": "number"
        },
        {
            "name": "longDescription",
            "baseName": "long_description",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "saleEndDate",
            "baseName": "sale_end_date",
            "type": "number"
        },
        {
            "name": "saleStartDate",
            "baseName": "sale_start_date",
            "type": "number"
        },
        {
            "name": "shortDescription",
            "baseName": "short_description",
            "type": "string"
        },
        {
            "name": "tag",
            "baseName": "tag",
            "type": "string"
        },
        {
            "name": "vendor",
            "baseName": "vendor",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CatalogSale.attributeTypeMap;
    }
}

export namespace CatalogSale {
    export enum DiscountTypeEnum {
        Value = <any> 'value',
        Percentage = <any> 'percentage'
    }
}
export class CategoryResource {
    /**
    * Whether the category is currently active. If not, it and its questions will be filtered out.
    */
    'active': boolean;
    /**
    * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * The unique ID for this category
    */
    'id': string;
    /**
    * The name of this category. Cannot be blank
    */
    'name': string;
    /**
    * A category template this category is validated against (private). May be null and no validation of additional_properties will be done
    */
    'template': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "additionalProperties",
            "baseName": "additional_properties",
            "type": "{ [key: string]: Property; }"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "template",
            "baseName": "template",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CategoryResource.attributeTypeMap;
    }
}

export class ChallengeActivityResource {
    /**
    * The id of the activity
    */
    'activityId': number;
    /**
    * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * The id of the challenge
    */
    'challengeId': number;
    /**
    * The entitlement item needed to participate in the activity as part of this event. Null indicates free entry. When creating/updating only id is used. Item must be pre-existing
    */
    'entitlement': ActivityEntitlementResource;
    /**
    * The unique ID for this resource
    */
    'id': number;
    /**
    * The rewards to give at the end of each occurence of the activity. When creating/updating only id is used. Reward set must be pre-existing
    */
    'rewardSet': RewardSetResource;
    /**
    * The list of settings and the select options
    */
    'settings': Array<SelectedSettingResource>;
    /**
    * A challenge activity template this challenge activity is validated against (private). May be null and no validation of additional_properties will be done
    */
    'template': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "activityId",
            "baseName": "activity_id",
            "type": "number"
        },
        {
            "name": "additionalProperties",
            "baseName": "additional_properties",
            "type": "{ [key: string]: Property; }"
        },
        {
            "name": "challengeId",
            "baseName": "challenge_id",
            "type": "number"
        },
        {
            "name": "entitlement",
            "baseName": "entitlement",
            "type": "ActivityEntitlementResource"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "rewardSet",
            "baseName": "reward_set",
            "type": "RewardSetResource"
        },
        {
            "name": "settings",
            "baseName": "settings",
            "type": "Array<SelectedSettingResource>"
        },
        {
            "name": "template",
            "baseName": "template",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ChallengeActivityResource.attributeTypeMap;
    }
}

export class ChallengeEventParticipantResource {
    /**
    * The email address of the user
    */
    'email': string;
    /**
    * The full name of the user
    */
    'fullname': string;
    /**
    * The user's score
    */
    'score': number;
    /**
    * The id of the user
    */
    'userId': number;
    /**
    * The username of the user
    */
    'username': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "fullname",
            "baseName": "fullname",
            "type": "string"
        },
        {
            "name": "score",
            "baseName": "score",
            "type": "number"
        },
        {
            "name": "userId",
            "baseName": "user_id",
            "type": "number"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ChallengeEventParticipantResource.attributeTypeMap;
    }
}

export class ChallengeEventResource {
    /**
    * The id of the challenge
    */
    'challengeId': number;
    /**
    * The end date in seconds
    */
    'endDate': number;
    /**
    * The id of the challenge event
    */
    'id': number;
    /**
    * Indicate if the rewards have been given out already 
    */
    'rewardStatus': ChallengeEventResource.RewardStatusEnum;
    /**
    * The start date in seconds
    */
    'startDate': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "challengeId",
            "baseName": "challenge_id",
            "type": "number"
        },
        {
            "name": "endDate",
            "baseName": "end_date",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "rewardStatus",
            "baseName": "reward_status",
            "type": "ChallengeEventResource.RewardStatusEnum"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ChallengeEventResource.attributeTypeMap;
    }
}

export namespace ChallengeEventResource {
    export enum RewardStatusEnum {
        Pending = <any> 'pending',
        Failed = <any> 'failed',
        Complete = <any> 'complete',
        Partial = <any> 'partial'
    }
}
export class ChallengeResource {
    /**
    * The number of activities allowed to this challenge
    */
    'activities': number;
    /**
    * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * The id of the campaign this challenge is a part of. The challenge must be tied to an active campaign before it will spawn events
    */
    'campaignId': number;
    /**
    * The ID of the original challenge it was copied from
    */
    'copyOf': number;
    /**
    * The date/time this resource was created in seconds since unix epoch
    */
    'createdDate': number;
    /**
    * The end date of this challenge in seconds since epoch. required if part of a campaign
    */
    'endDate': number;
    /**
    * The unique ID for that resource
    */
    'id': number;
    /**
    * The strategy for calculating the leaderboard. Defaults to highest score. Value MUST come from the list of available strategies from the Leaderboard Service.
    */
    'leaderboardStrategy': string;
    /**
    * The user friendly name of that resource. Defaults to blank string
    */
    'longDescription': string;
    /**
    * The user friendly name of that resource
    */
    'name': string;
    /**
    * The next date this challenge will be occur in seconds since epoch
    */
    'nextEventDate': number;
    /**
    * The number of minutes minimum to wait at the end of this challenge before running rewards, to allow activities to complete
    */
    'rewardLagMinutes': number;
    /**
    * The rewards to give at the end of the challenge. When creating/updating only id is used. Reward set must be pre-existing
    */
    'rewardSet': RewardSetResource;
    /**
    * The repeat schedule for the challenge
    */
    'schedule': Schedule;
    /**
    * The user friendly name of that resource. Defaults to blank string
    */
    'shortDescription': string;
    /**
    * The start date of this challenge in seconds since epoch. required if part of a campaign
    */
    'startDate': number;
    /**
    * A challenge template this challenge is validated against (private). May be null and no validation of additional_properties will be done
    */
    'template': string;
    /**
    * The date/time this resource was last updated in seconds since unix epoch
    */
    'updatedDate': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "activities",
            "baseName": "activities",
            "type": "number"
        },
        {
            "name": "additionalProperties",
            "baseName": "additional_properties",
            "type": "{ [key: string]: Property; }"
        },
        {
            "name": "campaignId",
            "baseName": "campaign_id",
            "type": "number"
        },
        {
            "name": "copyOf",
            "baseName": "copy_of",
            "type": "number"
        },
        {
            "name": "createdDate",
            "baseName": "created_date",
            "type": "number"
        },
        {
            "name": "endDate",
            "baseName": "end_date",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "leaderboardStrategy",
            "baseName": "leaderboard_strategy",
            "type": "string"
        },
        {
            "name": "longDescription",
            "baseName": "long_description",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "nextEventDate",
            "baseName": "next_event_date",
            "type": "number"
        },
        {
            "name": "rewardLagMinutes",
            "baseName": "reward_lag_minutes",
            "type": "number"
        },
        {
            "name": "rewardSet",
            "baseName": "reward_set",
            "type": "RewardSetResource"
        },
        {
            "name": "schedule",
            "baseName": "schedule",
            "type": "Schedule"
        },
        {
            "name": "shortDescription",
            "baseName": "short_description",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "number"
        },
        {
            "name": "template",
            "baseName": "template",
            "type": "string"
        },
        {
            "name": "updatedDate",
            "baseName": "updated_date",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ChallengeResource.attributeTypeMap;
    }
}

export class ClientResource {
    /**
    * The expiration time of an initial oauth token in seconds
    */
    'accessTokenValiditySeconds': number;
    /**
    * The client_id field of the oauth token request
    */
    'clientKey': string;
    /**
    * The oauth grant type as in: password (username/password auth), client_credentials (server-to-server, private clients), refresh_token (to allow clients to refresh their initial token), facebook, google, etc) See documentation for a complete list. Use dedicated endpoint PUT /grant-types to edit this list
    */
    'grantTypes': Array<string>;
    /**
    * Generated unique ID for the client
    */
    'id': number;
    /**
    * Set to true if the client is public i.e the secret key can be secured
    */
    'isPublic': boolean;
    /**
    * Used to flag system clients that are not meant to be tinkered with
    */
    'locked': boolean;
    /**
    * The friendly name of the client
    */
    'name': string;
    /**
    * A redirection URL to use when granting access to third-parties (seldomly used)
    */
    'redirectUris': Array<string>;
    /**
    * The expiration time of a refresh oauth token in seconds
    */
    'refreshTokenValiditySeconds': number;
    /**
    * The client-secret field of the oauth request when creating a private client
    */
    'secret': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accessTokenValiditySeconds",
            "baseName": "access_token_validity_seconds",
            "type": "number"
        },
        {
            "name": "clientKey",
            "baseName": "client_key",
            "type": "string"
        },
        {
            "name": "grantTypes",
            "baseName": "grant_types",
            "type": "Array<string>"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "isPublic",
            "baseName": "is_public",
            "type": "boolean"
        },
        {
            "name": "locked",
            "baseName": "locked",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "redirectUris",
            "baseName": "redirect_uris",
            "type": "Array<string>"
        },
        {
            "name": "refreshTokenValiditySeconds",
            "baseName": "refresh_token_validity_seconds",
            "type": "number"
        },
        {
            "name": "secret",
            "baseName": "secret",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ClientResource.attributeTypeMap;
    }
}

export class CollectionCountry {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CollectionCountry.attributeTypeMap;
    }
}

export class Collectionstring {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return Collectionstring.attributeTypeMap;
    }
}

export class CommentResource {
    /**
    * The comment content of that resource
    */
    'content': string;
    /**
    * The type of object this comment applies to (ex: video, article, etc). Required when passed to /comments
    */
    'context': string;
    /**
    * The id of the object this comment applies to.  Required when passed to /comments
    */
    'contextId': number;
    /**
    * The date/time this resource was created in seconds since epoch
    */
    'createdDate': number;
    /**
    * The unique ID for that resource
    */
    'id': number;
    /**
    * The summary of that resource
    */
    'summary': string;
    /**
    * The date/time this resource was last updated in seconds since epoch
    */
    'updatedDate': number;
    /**
    * The user who created the comment
    */
    'user': SimpleUserResource;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "context",
            "baseName": "context",
            "type": "string"
        },
        {
            "name": "contextId",
            "baseName": "context_id",
            "type": "number"
        },
        {
            "name": "createdDate",
            "baseName": "created_date",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "summary",
            "baseName": "summary",
            "type": "string"
        },
        {
            "name": "updatedDate",
            "baseName": "updated_date",
            "type": "number"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "SimpleUserResource"
        }    ];

    static getAttributeTypeMap() {
        return CommentResource.attributeTypeMap;
    }
}

export class CommentSearch {
    'content': string;
    'context': string;
    'contextId': number;
    'id': number;
    'ownerId': number;
    'ownerUsername': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "context",
            "baseName": "context",
            "type": "string"
        },
        {
            "name": "contextId",
            "baseName": "context_id",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "ownerId",
            "baseName": "owner_id",
            "type": "number"
        },
        {
            "name": "ownerUsername",
            "baseName": "owner_username",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CommentSearch.attributeTypeMap;
    }
}

export class Config {
    /**
    * The description of the config.  Max 140 characters
    */
    'description': string;
    /**
    * The name of the config
    */
    'name': string;
    /**
    * Whether the config is public for viewing. True means that it can be publicly viewed by all. Default: false
    */
    'publicRead': boolean;
    /**
    * The value of the config
    */
    'value': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "publicRead",
            "baseName": "public_read",
            "type": "boolean"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Config.attributeTypeMap;
    }
}

export class ConfigLookupResource {
    'lookupKey': ExpressionResource;
    'type': string;
    'valueType': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "lookupKey",
            "baseName": "lookup_key",
            "type": "ExpressionResource"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "valueType",
            "baseName": "value_type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ConfigLookupResource.attributeTypeMap;
    }
}

export class ConstantResource {
    'type': string;
    'value': any;
    'valueType': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "any"
        },
        {
            "name": "valueType",
            "baseName": "value_type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ConstantResource.attributeTypeMap;
    }
}

export class ContributionResource {
    /**
    * A reference to the contributing artist
    */
    'artist': SimpleReferenceResourcelong;
    /**
    * A reference to the media being contributed to
    */
    'media': SimpleReferenceResourcelong;
    /**
    * The nature of the contribution (role of the artist as in 'producer', 'performer', etc)
    */
    'role': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "artist",
            "baseName": "artist",
            "type": "SimpleReferenceResourcelong"
        },
        {
            "name": "media",
            "baseName": "media",
            "type": "SimpleReferenceResourcelong"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ContributionResource.attributeTypeMap;
    }
}

export class Country {
    'id': number;
    'iso2': string;
    'iso3': string;
    'name': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "iso2",
            "baseName": "iso2",
            "type": "string"
        },
        {
            "name": "iso3",
            "baseName": "iso3",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Country.attributeTypeMap;
    }
}

export class CountryResource {
    /**
    * The iso2 of the country
    */
    'iso2': string;
    /**
    * The iso3 of the country
    */
    'iso3': string;
    /**
    * The name of the country resource
    */
    'name': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "iso2",
            "baseName": "iso2",
            "type": "string"
        },
        {
            "name": "iso3",
            "baseName": "iso3",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CountryResource.attributeTypeMap;
    }
}

export class CountryTaxResource {
    /**
    * The iso3 code of the country, cannot be changed
    */
    'countryIso3': string;
    /**
    * The name of the tax
    */
    'name': string;
    /**
    * The tax rate as a percentage to a maximum of two decimal places (1.5 means 1.5%)
    */
    'rate': number;
    /**
    * Whether the tax applies to shipping costs
    */
    'taxShipping': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "countryIso3",
            "baseName": "country_iso3",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "rate",
            "baseName": "rate",
            "type": "number"
        },
        {
            "name": "taxShipping",
            "baseName": "tax_shipping",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CountryTaxResource.attributeTypeMap;
    }
}

export class CouponDefinition {
    /**
    * A unique identifier for the discount. Can be used to remove the discount, and uniqueness within the cart will be enforced.
    */
    'code': string;
    /**
    * A description for the discount.
    */
    'description': string;
    /**
    * The type of discount in terms of how it deducts price.
    */
    'discountType': CouponDefinition.DiscountTypeEnum;
    /**
    * Whether this discount is exclusive and cannot be used in conjunction with other discounts/coupons. default=false
    */
    'exclusive': boolean;
    /**
    * For coupon_cart, a minimum total price that the cart must meet to be valid.
    */
    'maxDiscount': number;
    /**
    * The maximum number of items to count this discount for (not for cart_coupon).
    */
    'maxQuantity': number;
    /**
    * For coupon_cart, a minimum total price that the cart must meet to be valid.
    */
    'minCartTotal': number;
    /**
    * A name for the discount.
    */
    'name': string;
    /**
    * Whether this coupon is exclusive to itself or not (true means cannot add two of this same coupon to the same cart).  Default = false
    */
    'selfExclusive': boolean;
    /**
    * The id of the item this discount applies to, which must be present in the cart. Applies if coupon_type_hint is coupon_single_item or coupon_voucher.
    */
    'targetItemId': number;
    /**
    * The type of discount in terms of what it applies to. coupon_cart applies to the cart as a whole, other types apply to specific items based on different criteria.
    */
    'type': CouponDefinition.TypeEnum;
    /**
    * A unique identifier string for the discount.
    */
    'uniqueKey': string;
    /**
    * Which tags this applies for (item must have at least one of them), if coupon_type is coupon_tag.
    */
    'validForTags': Array<string>;
    /**
    * The amount of the discount. If discount_type is value then this is the raw currency amount to remove. If discount_type is percentage then this will be multiplied by the cart total or item price to get the discount amount (0.5 is half price).
    */
    'value': number;
    /**
    * Which vendor this applies for, if coupon_type is coupon_vendor.
    */
    'vendorId': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "discountType",
            "baseName": "discount_type",
            "type": "CouponDefinition.DiscountTypeEnum"
        },
        {
            "name": "exclusive",
            "baseName": "exclusive",
            "type": "boolean"
        },
        {
            "name": "maxDiscount",
            "baseName": "max_discount",
            "type": "number"
        },
        {
            "name": "maxQuantity",
            "baseName": "max_quantity",
            "type": "number"
        },
        {
            "name": "minCartTotal",
            "baseName": "min_cart_total",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "selfExclusive",
            "baseName": "self_exclusive",
            "type": "boolean"
        },
        {
            "name": "targetItemId",
            "baseName": "target_item_id",
            "type": "number"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "CouponDefinition.TypeEnum"
        },
        {
            "name": "uniqueKey",
            "baseName": "unique_key",
            "type": "string"
        },
        {
            "name": "validForTags",
            "baseName": "valid_for_tags",
            "type": "Array<string>"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        },
        {
            "name": "vendorId",
            "baseName": "vendor_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CouponDefinition.attributeTypeMap;
    }
}

export namespace CouponDefinition {
    export enum DiscountTypeEnum {
        Value = <any> 'value',
        Percentage = <any> 'percentage'
    }
    export enum TypeEnum {
        Cart = <any> 'coupon_cart',
        SingleItem = <any> 'coupon_single_item',
        Voucher = <any> 'coupon_voucher',
        Vendor = <any> 'coupon_vendor',
        Tag = <any> 'coupon_tag'
    }
}
export class CreateBillingAgreementRequest {
    /**
    * The endpoint URL to which PayPal should forward the user if they cancel (do not accept) the agreement
    */
    'cancelUrl': string;
    /**
    * The endpoint URL to which PayPal should forward the user after they accept the agreement. This endpoint will receive information needed for the next step
    */
    'returnUrl': string;
    /**
    * The ID of the user. Defaults to the logged in user
    */
    'userId': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cancelUrl",
            "baseName": "cancel_url",
            "type": "string"
        },
        {
            "name": "returnUrl",
            "baseName": "return_url",
            "type": "string"
        },
        {
            "name": "userId",
            "baseName": "user_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CreateBillingAgreementRequest.attributeTypeMap;
    }
}

export class CreatePayPalPaymentRequest {
    /**
    * The endpoint URL to which PayPal should forward the user to if they cancel the checkout process
    */
    'cancelUrl': string;
    /**
    * The ID of an invoice to pay
    */
    'invoiceId': number;
    /**
    * The endpoint URL to which PayPal should forward the user after they accept. This endpoint will receive information needed for the next step
    */
    'returnUrl': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cancelUrl",
            "baseName": "cancel_url",
            "type": "string"
        },
        {
            "name": "invoiceId",
            "baseName": "invoice_id",
            "type": "number"
        },
        {
            "name": "returnUrl",
            "baseName": "return_url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreatePayPalPaymentRequest.attributeTypeMap;
    }
}

export class CurrencyResource {
    /**
    * Whether the currency is active. Default true
    */
    'active': boolean;
    /**
    * The unique id code for the currency. Maximum 5 characters
    */
    'code': string;
    /**
    * The unix timestamp in seconds the currency was added to the system
    */
    'createdDate': number;
    /**
    * The decimal to multiply the system base currency (from config 'currency') to localize to this one. Should be 1 for the base currency itself.
    */
    'factor': number;
    /**
    * The url for an icon of the currency
    */
    'icon': string;
    /**
    * The name of the currency
    */
    'name': string;
    /**
    * The type of currency. Default 'real'
    */
    'type': CurrencyResource.TypeEnum;
    /**
    * The unix timestamp in seconds the currency was last updated in the system.
    */
    'updatedDate': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "createdDate",
            "baseName": "created_date",
            "type": "number"
        },
        {
            "name": "factor",
            "baseName": "factor",
            "type": "number"
        },
        {
            "name": "icon",
            "baseName": "icon",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "CurrencyResource.TypeEnum"
        },
        {
            "name": "updatedDate",
            "baseName": "updated_date",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CurrencyResource.attributeTypeMap;
    }
}

export namespace CurrencyResource {
    export enum TypeEnum {
        Real = <any> 'real',
        Virtual = <any> 'virtual'
    }
}
export class CustomerConfig {
    'aliases': string;
    'database': DatabaseConfig;
    'io': IOConfig;
    'name': string;
    's3Config': S3Config;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "aliases",
            "baseName": "aliases",
            "type": "string"
        },
        {
            "name": "database",
            "baseName": "database",
            "type": "DatabaseConfig"
        },
        {
            "name": "io",
            "baseName": "io",
            "type": "IOConfig"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "s3Config",
            "baseName": "s3_config",
            "type": "S3Config"
        }    ];

    static getAttributeTypeMap() {
        return CustomerConfig.attributeTypeMap;
    }
}

export class DatabaseConfig {
    'mongo': MongoDatabaseConfig;
    'sql': SqlDatabaseConfig;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "mongo",
            "baseName": "mongo",
            "type": "MongoDatabaseConfig"
        },
        {
            "name": "sql",
            "baseName": "sql",
            "type": "SqlDatabaseConfig"
        }    ];

    static getAttributeTypeMap() {
        return DatabaseConfig.attributeTypeMap;
    }
}

export class DateOperationResource {
    'args': Array<ExpressionResource>;
    'op': string;
    'type': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "args",
            "baseName": "args",
            "type": "Array<ExpressionResource>"
        },
        {
            "name": "op",
            "baseName": "op",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DateOperationResource.attributeTypeMap;
    }
}

export class DeltaResource {
    /**
    * The id of the category for question
    */
    'categoryId': string;
    /**
    * The media type of the question
    */
    'mediaType': string;
    /**
    * The id of the question
    */
    'questionId': string;
    /**
    * Whether the question was updated or removed
    */
    'state': DeltaResource.StateEnum;
    /**
    * The tags for the question
    */
    'tags': Array<string>;
    /**
    * The date this question was last updated in seconds since unix epoch
    */
    'updatedDate': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "categoryId",
            "baseName": "category_id",
            "type": "string"
        },
        {
            "name": "mediaType",
            "baseName": "media_type",
            "type": "string"
        },
        {
            "name": "questionId",
            "baseName": "question_id",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "DeltaResource.StateEnum"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "updatedDate",
            "baseName": "updated_date",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return DeltaResource.attributeTypeMap;
    }
}

export namespace DeltaResource {
    export enum StateEnum {
        UPDATED = <any> 'UPDATED',
        REMOVED = <any> 'REMOVED'
    }
}
export class DeviceResource {
    /**
    * The authorization code for the device
    */
    'authorization': string;
    /**
    * The current condition of the device (New, Defective, Reconditioned)
    */
    'condition': DeviceResource.ConditionEnum;
    /**
    * The date the device log was created
    */
    'createdDate': number;
    /**
    * The key/value pairs for extended data
    */
    'data': { [key: string]: string; };
    /**
    * The description of the device
    */
    'description': string;
    /**
    * The type of the device
    */
    'deviceType': string;
    /**
    * The unique ID for this device. Cannot be changed once created
    */
    'id': number;
    /**
    * The location of the device
    */
    'location': string;
    /**
    * The MAC (media access control) address of the device
    */
    'macAddress': string;
    /**
    * The make of the device
    */
    'make': string;
    /**
    * The model of the device
    */
    'model': string;
    /**
    * The name of the device
    */
    'name': string;
    /**
    * The OS (operating system) on the device
    */
    'os': string;
    /**
    * The serial number of the device
    */
    'serial': string;
    /**
    * The current status the device (Active, Pending Active, Inactive, Repair
    */
    'status': DeviceResource.StatusEnum;
    /**
    * The date the device log was updated
    */
    'updatedDate': number;
    /**
    * The user that owns the device
    */
    'user': SimpleUserResource;
    /**
    * The users currently using the device
    */
    'users': Array<SimpleUserResource>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "authorization",
            "baseName": "authorization",
            "type": "string"
        },
        {
            "name": "condition",
            "baseName": "condition",
            "type": "DeviceResource.ConditionEnum"
        },
        {
            "name": "createdDate",
            "baseName": "created_date",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "deviceType",
            "baseName": "device_type",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "location",
            "baseName": "location",
            "type": "string"
        },
        {
            "name": "macAddress",
            "baseName": "mac_address",
            "type": "string"
        },
        {
            "name": "make",
            "baseName": "make",
            "type": "string"
        },
        {
            "name": "model",
            "baseName": "model",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "os",
            "baseName": "os",
            "type": "string"
        },
        {
            "name": "serial",
            "baseName": "serial",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "DeviceResource.StatusEnum"
        },
        {
            "name": "updatedDate",
            "baseName": "updated_date",
            "type": "number"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "SimpleUserResource"
        },
        {
            "name": "users",
            "baseName": "users",
            "type": "Array<SimpleUserResource>"
        }    ];

    static getAttributeTypeMap() {
        return DeviceResource.attributeTypeMap;
    }
}

export namespace DeviceResource {
    export enum ConditionEnum {
        New = <any> 'New',
        Defective = <any> 'Defective',
        Reconditioned = <any> 'Reconditioned'
    }
    export enum StatusEnum {
        Active = <any> 'Active',
        PendingActive = <any> 'PendingActive',
        Inactive = <any> 'Inactive',
        Repair = <any> 'Repair'
    }
}
export class Discount {
    'description': string;
    'name': string;
    'sku': string;
    'uniqueKey': string;
    'value': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "sku",
            "baseName": "sku",
            "type": "string"
        },
        {
            "name": "uniqueKey",
            "baseName": "unique_key",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Discount.attributeTypeMap;
    }
}

export class DispositionCount {
    /**
    * The number of users that have expressed this disposition
    */
    'count': number;
    /**
    * The name of the disposition this count is for
    */
    'name': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DispositionCount.attributeTypeMap;
    }
}

export class DispositionResource {
    /**
    * The context of that resource. Required when passed to /dispositions rather than context specific endpoint
    */
    'context': string;
    /**
    * The context_id of that resource. Required when passed to /dispositions rather than context specific endpoint
    */
    'contextId': string;
    /**
    * The date/time this resource was created in seconds since unix epoch
    */
    'createdDate': number;
    /**
    * The unique ID for that resource
    */
    'id': number;
    /**
    * The name of the disposition, 1-20 characters. (ex: like/dislike/favorite, etc)
    */
    'name': string;
    /**
    * The user
    */
    'user': SimpleUserResource;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "context",
            "baseName": "context",
            "type": "string"
        },
        {
            "name": "contextId",
            "baseName": "context_id",
            "type": "string"
        },
        {
            "name": "createdDate",
            "baseName": "created_date",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "SimpleUserResource"
        }    ];

    static getAttributeTypeMap() {
        return DispositionResource.attributeTypeMap;
    }
}

export class DoubleOperationResource {
    'args': Array<ExpressionResource>;
    'op': string;
    'type': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "args",
            "baseName": "args",
            "type": "Array<ExpressionResource>"
        },
        {
            "name": "op",
            "baseName": "op",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DoubleOperationResource.attributeTypeMap;
    }
}

export class EntitlementGrantRequest {
    /**
    * The ID of the entitlement item to grant
    */
    'entitlementId': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "entitlementId",
            "baseName": "entitlement_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return EntitlementGrantRequest.attributeTypeMap;
    }
}

export class ErrorResource {
    /**
    * Extra details about the error, if needed
    */
    'details': any;
    /**
    * The JSON key the message pertains to
    */
    'field': any;
    /**
    * The message explaining the error
    */
    'message': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "details",
            "baseName": "details",
            "type": "any"
        },
        {
            "name": "field",
            "baseName": "field",
            "type": "any"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ErrorResource.attributeTypeMap;
    }
}

export class EventContextResource {
    'eventName': string;
    'parameters': { [key: string]: ExpressionResource; };
    'type': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "eventName",
            "baseName": "event_name",
            "type": "string"
        },
        {
            "name": "parameters",
            "baseName": "parameters",
            "type": "{ [key: string]: ExpressionResource; }"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EventContextResource.attributeTypeMap;
    }
}

export class ExpressionResource {
    'type': string;

    static discriminator = type;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ExpressionResource.attributeTypeMap;
    }
}

export class Expressionobject {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return Expressionobject.attributeTypeMap;
    }
}

export class FacebookToken {
    /**
    * A valid access token from facebook. See facebook documention for how to obtain one.
    */
    'accessToken': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accessToken",
            "baseName": "access_token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FacebookToken.attributeTypeMap;
    }
}

export class FattMerchantPaymentMethod {
    'address1': string;
    'address2': string;
    'addressCity': string;
    'addressCountry': string;
    'addressState': string;
    'addressZip': string;
    /**
    * Last four digits of the credit card
    */
    'cardLastFour': string;
    'createdAt': string;
    /**
    * Unique FattMerchant customer ID
    */
    'customerId': string;
    'deletedAt': string;
    'id': string;
    /**
    * Nickname given to the FattMerchant payment method
    */
    'nickname': string;
    'updatedAt': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "addressCity",
            "baseName": "address_city",
            "type": "string"
        },
        {
            "name": "addressCountry",
            "baseName": "address_country",
            "type": "string"
        },
        {
            "name": "addressState",
            "baseName": "address_state",
            "type": "string"
        },
        {
            "name": "addressZip",
            "baseName": "address_zip",
            "type": "string"
        },
        {
            "name": "cardLastFour",
            "baseName": "card_last_four",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "customerId",
            "baseName": "customer_id",
            "type": "string"
        },
        {
            "name": "deletedAt",
            "baseName": "deleted_at",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "nickname",
            "baseName": "nickname",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FattMerchantPaymentMethod.attributeTypeMap;
    }
}

export class FattMerchantPaymentMethodRequest {
    /**
    * The FattMerchant payment method being created/updated
    */
    'method': FattMerchantPaymentMethod;
    /**
    * ID of the JSAPI user for whom the payment method is being created/updated. If ID is not that of the currently logged in user, FATMMERCHANT_ADMIN privilege is required. If ID is null, will use the currently logged in user's ID.
    */
    'userId': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "method",
            "baseName": "method",
            "type": "FattMerchantPaymentMethod"
        },
        {
            "name": "userId",
            "baseName": "user_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FattMerchantPaymentMethodRequest.attributeTypeMap;
    }
}

export class FinalizeBillingAgreementRequest {
    /**
    * The ID of the invoice being paid along with the creation of this agreement
    */
    'invoiceId': number;
    /**
    * Whether the new payment method created should be the user's default
    */
    'newDefault': boolean;
    /**
    * The payer ID from PayPal (passed as a parameter in the return URL). Only required if an invoice ID was included
    */
    'payerId': string;
    /**
    * The token from PayPal (passed as a parameter in the return URL)
    */
    'token': string;
    /**
    * The ID of the user. Defaults to the logged in user
    */
    'userId': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "invoiceId",
            "baseName": "invoice_id",
            "type": "number"
        },
        {
            "name": "newDefault",
            "baseName": "new_default",
            "type": "boolean"
        },
        {
            "name": "payerId",
            "baseName": "payer_id",
            "type": "string"
        },
        {
            "name": "token",
            "baseName": "token",
            "type": "string"
        },
        {
            "name": "userId",
            "baseName": "user_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FinalizeBillingAgreementRequest.attributeTypeMap;
    }
}

export class FinalizePayPalPaymentRequest {
    /**
    * The ID of the invoice that is being paid. Must match the invoice sent in originally
    */
    'invoiceId': number;
    /**
    * The ID of the payer that PayPal returned with the user at the return URL
    */
    'payerId': string;
    /**
    * The token that PayPal returned with the user in the return URL
    */
    'token': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "invoiceId",
            "baseName": "invoice_id",
            "type": "number"
        },
        {
            "name": "payerId",
            "baseName": "payer_id",
            "type": "string"
        },
        {
            "name": "token",
            "baseName": "token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FinalizePayPalPaymentRequest.attributeTypeMap;
    }
}

export class FlagReportResource {
    /**
    * The context of that resource 
    */
    'context': string;
    /**
    * The context ID of that resource
    */
    'contextId': string;
    /**
    * The date/time this resource was created in seconds since epoch
    */
    'createdDate': number;
    /**
    * The unique ID for that resource
    */
    'id': number;
    /**
    * The reason of that resource required only in case of active resolution
    */
    'reason': string;
    /**
    * The resolution of that resource
    */
    'resolution': FlagReportResource.ResolutionEnum;
    /**
    * The date/time this report was resolved in seconds since epoch. Null if not resolved yet
    */
    'resolved': number;
    /**
    * The date/time this resource was last updated in seconds since epoch
    */
    'updatedDate': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "context",
            "baseName": "context",
            "type": "string"
        },
        {
            "name": "contextId",
            "baseName": "context_id",
            "type": "string"
        },
        {
            "name": "createdDate",
            "baseName": "created_date",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "resolution",
            "baseName": "resolution",
            "type": "FlagReportResource.ResolutionEnum"
        },
        {
            "name": "resolved",
            "baseName": "resolved",
            "type": "number"
        },
        {
            "name": "updatedDate",
            "baseName": "updated_date",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FlagReportResource.attributeTypeMap;
    }
}

export namespace FlagReportResource {
    export enum ResolutionEnum {
        Banned = <any> 'banned',
        Ignored = <any> 'ignored'
    }
}
export class FlagResource {
    /**
    * The context of that resource
    */
    'context': string;
    /**
    * The context_id of that resource
    */
    'contextId': string;
    /**
    * The date/time this resource was created in seconds since epoch
    */
    'createdDate': number;
    /**
    * The unique ID for that resource
    */
    'id': number;
    /**
    * The flag reason of that resource
    */
    'reason': string;
    /**
    * The date/time this resource was last updated in seconds since epoch
    */
    'updatedDate': number;
    /**
    * The basic user resource
    */
    'user': SimpleUserResource;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "context",
            "baseName": "context",
            "type": "string"
        },
        {
            "name": "contextId",
            "baseName": "context_id",
            "type": "string"
        },
        {
            "name": "createdDate",
            "baseName": "created_date",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "updatedDate",
            "baseName": "updated_date",
            "type": "number"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "SimpleUserResource"
        }    ];

    static getAttributeTypeMap() {
        return FlagResource.attributeTypeMap;
    }
}

export class ForwardLog {
    /**
    * The end date of the forward log entry
    */
    'endDate': number;
    'errorMsg': string;
    /**
    * The http status code the forward log entry
    */
    'httpStatusCode': number;
    /**
    * The id of the forward log entry
    */
    'id': string;
    /**
    * The payload of the forward log entry
    */
    'payload': any;
    /**
    * The response string of the forward log entry
    */
    'response': string;
    /**
    * The retry count of the forward log entry
    */
    'retryCount': number;
    /**
    * The start date of the forward log entry
    */
    'startDate': number;
    /**
    * The endpoint url of the forward log entry
    */
    'url': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "endDate",
            "baseName": "end_date",
            "type": "number"
        },
        {
            "name": "errorMsg",
            "baseName": "error_msg",
            "type": "string"
        },
        {
            "name": "httpStatusCode",
            "baseName": "http_status_code",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "payload",
            "baseName": "payload",
            "type": "any"
        },
        {
            "name": "response",
            "baseName": "response",
            "type": "string"
        },
        {
            "name": "retryCount",
            "baseName": "retry_count",
            "type": "number"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "number"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ForwardLog.attributeTypeMap;
    }
}

export class FulfillmentType {
    /**
    * Whether the type is core and cannot be altered/deleted, read-only
    */
    'core': boolean;
    /**
    * A description of the type
    */
    'description': string;
    /**
    * The unique id of the type, read-only
    */
    'id': number;
    /**
    * The name of the type
    */
    'name': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "core",
            "baseName": "core",
            "type": "boolean"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FulfillmentType.attributeTypeMap;
    }
}

export class GlobalCheckAndIncrementResource {
    'checkValueResource': ExpressionResource;
    'globalResource': ExpressionResource;
    'type': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "checkValueResource",
            "baseName": "check_value_resource",
            "type": "ExpressionResource"
        },
        {
            "name": "globalResource",
            "baseName": "global_resource",
            "type": "ExpressionResource"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GlobalCheckAndIncrementResource.attributeTypeMap;
    }
}

export class GlobalResource {
    'globalDefId': string;
    'scopes': { [key: string]: ExpressionResource; };
    'type': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "globalDefId",
            "baseName": "global_def_id",
            "type": "string"
        },
        {
            "name": "scopes",
            "baseName": "scopes",
            "type": "{ [key: string]: ExpressionResource; }"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GlobalResource.attributeTypeMap;
    }
}

export class GooglePaymentRequest {
    /**
    * The json payload exactly as sent from Google
    */
    'jsonPayload': string;
    /**
    * The signature from Google to verify the payload
    */
    'signature': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "jsonPayload",
            "baseName": "json_payload",
            "type": "string"
        },
        {
            "name": "signature",
            "baseName": "signature",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GooglePaymentRequest.attributeTypeMap;
    }
}

export class GoogleToken {
    /**
    * A valid authorization code from google. See google documention for how to obtain one.
    */
    'authorizationCode': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "authorizationCode",
            "baseName": "authorization_code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GoogleToken.attributeTypeMap;
    }
}

export class GrantTypeResource {
    /**
    * The description of the grant type
    */
    'description': string;
    /**
    * The name of the grant type
    */
    'name': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GrantTypeResource.attributeTypeMap;
    }
}

export class GroupMemberResource {
    /**
    * The url of the user's avatar image
    */
    'avatarUrl': string;
    /**
    * The public username of the user
    */
    'displayName': string;
    /**
    * The id of the user
    */
    'id': number;
    /**
    * The member's access level. Default: member
    */
    'status': GroupMemberResource.StatusEnum;
    /**
    * The username of the user
    */
    'username': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "avatarUrl",
            "baseName": "avatar_url",
            "type": "string"
        },
        {
            "name": "displayName",
            "baseName": "display_name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "GroupMemberResource.StatusEnum"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GroupMemberResource.attributeTypeMap;
    }
}

export namespace GroupMemberResource {
    export enum StatusEnum {
        Moderator = <any> 'moderator',
        Member = <any> 'member'
    }
}
export class GroupResource {
    /**
    * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * A description of the group. Max 250 characters
    */
    'description': string;
    /**
    * The number of users in the group
    */
    'memberCount': number;
    /**
    * A message of the day for members of the group
    */
    'messageOfTheDay': string;
    /**
    * The name of the group. Max 50 characters
    */
    'name': string;
    /**
    * The unique name of another group that this group is a subset of
    */
    'parent': string;
    /**
    * The status which describes whether other users can freely join the group or not
    */
    'status': GroupResource.StatusEnum;
    /**
    * The number of users in child groups
    */
    'subMemberCount': number;
    /**
    * A group template this group is validated against. May be null and no validation of additional_properties will be done
    */
    'template': string;
    /**
    * Unique name used in url and references. Uppercase, lowercase, numbers and hyphens only. Max 50 characters. Cannot be altered once created
    */
    'uniqueName': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "additionalProperties",
            "baseName": "additional_properties",
            "type": "{ [key: string]: Property; }"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "memberCount",
            "baseName": "member_count",
            "type": "number"
        },
        {
            "name": "messageOfTheDay",
            "baseName": "message_of_the_day",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "parent",
            "baseName": "parent",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "GroupResource.StatusEnum"
        },
        {
            "name": "subMemberCount",
            "baseName": "sub_member_count",
            "type": "number"
        },
        {
            "name": "template",
            "baseName": "template",
            "type": "string"
        },
        {
            "name": "uniqueName",
            "baseName": "unique_name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GroupResource.attributeTypeMap;
    }
}

export namespace GroupResource {
    export enum StatusEnum {
        Open = <any> 'open',
        Closed = <any> 'closed'
    }
}
export class IOConfig {
    'customer': string;
    'enabled': boolean;
    'environment': string;
    'product': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "customer",
            "baseName": "customer",
            "type": "string"
        },
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "environment",
            "baseName": "environment",
            "type": "string"
        },
        {
            "name": "product",
            "baseName": "product",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IOConfig.attributeTypeMap;
    }
}

export class ImportJobOutputResource {
    /**
    * The description of the import job
    */
    'description': string;
    /**
    * The line number of the import job
    */
    'lineNumber': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "lineNumber",
            "baseName": "line_number",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ImportJobOutputResource.attributeTypeMap;
    }
}

export class ImportJobResource {
    /**
    * The id of the category to assign all questions in the import to
    */
    'categoryId': string;
    /**
    * The date the job was created in seconds since unix epoc
    */
    'createdDate': number;
    /**
    * The id of the job
    */
    'id': number;
    /**
    * A name for this import for later reference
    */
    'name': string;
    /**
    * Error information from validation
    */
    'output': Array<ImportJobOutputResource>;
    /**
    * The number of questions form the CSV file. Filled in after validation
    */
    'recordCount': number;
    /**
    * The status of the job
    */
    'status': ImportJobResource.StatusEnum;
    /**
    * The date the job was last updated in seconds since unix epoc
    */
    'updatedDate': number;
    /**
    * The url of a CSV file to pull trivia questions from. Cannot be changed after initial POST
    */
    'url': string;
    /**
    * The vendor who supplied this set of questions
    */
    'vendor': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "categoryId",
            "baseName": "category_id",
            "type": "string"
        },
        {
            "name": "createdDate",
            "baseName": "created_date",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "output",
            "baseName": "output",
            "type": "Array<ImportJobOutputResource>"
        },
        {
            "name": "recordCount",
            "baseName": "record_count",
            "type": "number"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "ImportJobResource.StatusEnum"
        },
        {
            "name": "updatedDate",
            "baseName": "updated_date",
            "type": "number"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "vendor",
            "baseName": "vendor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ImportJobResource.attributeTypeMap;
    }
}

export namespace ImportJobResource {
    export enum StatusEnum {
        PENDINGVALIDATION = <any> 'PENDING_VALIDATION',
        VALIDATING = <any> 'VALIDATING',
        VALID = <any> 'VALID',
        INVALID = <any> 'INVALID',
        PENDINGPROCESS = <any> 'PENDING_PROCESS',
        PROCESSING = <any> 'PROCESSING',
        PROCESSED = <any> 'PROCESSED',
        FAILED = <any> 'FAILED'
    }
}
export class IntWrapper {
    'value': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return IntWrapper.attributeTypeMap;
    }
}

export class IntegerOperationResource {
    'args': Array<ExpressionResource>;
    'op': string;
    'type': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "args",
            "baseName": "args",
            "type": "Array<ExpressionResource>"
        },
        {
            "name": "op",
            "baseName": "op",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IntegerOperationResource.attributeTypeMap;
    }
}

export class InventorySubscriptionResource {
    /**
    * The date the subscription will be billed
    */
    'billDate': number;
    /**
    * A credit of money already applied to a subscription for the next bill, or a debt if negative
    */
    'credit': number;
    /**
    * A record of past and present credit/debt changes
    */
    'creditLog': Array<SubscriptionCreditResource>;
    /**
    * The date the grace period ends
    */
    'graceEnd': number;
    /**
    * The id of the inventory
    */
    'inventoryId': number;
    /**
    * The inventory status object
    */
    'inventoryStatus': InventorySubscriptionResource.InventoryStatusEnum;
    /**
    * The id of the item
    */
    'itemId': number;
    /**
    * The payment method object
    */
    'paymentMethod': PaymentMethodResource;
    /**
    * The recurring price that has been set to override the base price. Null if not overriding
    */
    'priceOverride': number;
    /**
    * An explanation for the reason the price is being overridden
    */
    'priceOverrideReason': string;
    /**
    * The default recurring price
    */
    'recurringPrice': number;
    /**
    * The recurring sku of the subscription
    */
    'sku': string;
    /**
    * The date the subscription will start
    */
    'startDate': number;
    /**
    * The status of the subscription
    */
    'subscriptionStatus': number;
    /**
    * The user
    */
    'user': SimpleUserResource;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "billDate",
            "baseName": "bill_date",
            "type": "number"
        },
        {
            "name": "credit",
            "baseName": "credit",
            "type": "number"
        },
        {
            "name": "creditLog",
            "baseName": "credit_log",
            "type": "Array<SubscriptionCreditResource>"
        },
        {
            "name": "graceEnd",
            "baseName": "grace_end",
            "type": "number"
        },
        {
            "name": "inventoryId",
            "baseName": "inventory_id",
            "type": "number"
        },
        {
            "name": "inventoryStatus",
            "baseName": "inventory_status",
            "type": "InventorySubscriptionResource.InventoryStatusEnum"
        },
        {
            "name": "itemId",
            "baseName": "item_id",
            "type": "number"
        },
        {
            "name": "paymentMethod",
            "baseName": "payment_method",
            "type": "PaymentMethodResource"
        },
        {
            "name": "priceOverride",
            "baseName": "price_override",
            "type": "number"
        },
        {
            "name": "priceOverrideReason",
            "baseName": "price_override_reason",
            "type": "string"
        },
        {
            "name": "recurringPrice",
            "baseName": "recurring_price",
            "type": "number"
        },
        {
            "name": "sku",
            "baseName": "sku",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "number"
        },
        {
            "name": "subscriptionStatus",
            "baseName": "subscription_status",
            "type": "number"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "SimpleUserResource"
        }    ];

    static getAttributeTypeMap() {
        return InventorySubscriptionResource.attributeTypeMap;
    }
}

export namespace InventorySubscriptionResource {
    export enum InventoryStatusEnum {
        Pending = <any> 'pending',
        Active = <any> 'active',
        Inactive = <any> 'inactive'
    }
}
export class InvoiceCreateRequest {
    /**
    * The guid of a cart to create a new invoice for
    */
    'cartGuid': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cartGuid",
            "baseName": "cart_guid",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InvoiceCreateRequest.attributeTypeMap;
    }
}

export class InvoiceItemResource {
    'bundleSku': string;
    'currentFulfillmentStatus': string;
    'id': number;
    'invoiceId': number;
    'itemId': number;
    'itemName': string;
    'originalTotalPrice': number;
    'originalUnitPrice': number;
    'qty': number;
    'saleName': string;
    'sku': string;
    'skuDescription': string;
    'systemPrice': number;
    'totalPrice': number;
    'typeHint': string;
    'unitPrice': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "bundleSku",
            "baseName": "bundle_sku",
            "type": "string"
        },
        {
            "name": "currentFulfillmentStatus",
            "baseName": "current_fulfillment_status",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "invoiceId",
            "baseName": "invoice_id",
            "type": "number"
        },
        {
            "name": "itemId",
            "baseName": "item_id",
            "type": "number"
        },
        {
            "name": "itemName",
            "baseName": "item_name",
            "type": "string"
        },
        {
            "name": "originalTotalPrice",
            "baseName": "original_total_price",
            "type": "number"
        },
        {
            "name": "originalUnitPrice",
            "baseName": "original_unit_price",
            "type": "number"
        },
        {
            "name": "qty",
            "baseName": "qty",
            "type": "number"
        },
        {
            "name": "saleName",
            "baseName": "sale_name",
            "type": "string"
        },
        {
            "name": "sku",
            "baseName": "sku",
            "type": "string"
        },
        {
            "name": "skuDescription",
            "baseName": "sku_description",
            "type": "string"
        },
        {
            "name": "systemPrice",
            "baseName": "system_price",
            "type": "number"
        },
        {
            "name": "totalPrice",
            "baseName": "total_price",
            "type": "number"
        },
        {
            "name": "typeHint",
            "baseName": "type_hint",
            "type": "string"
        },
        {
            "name": "unitPrice",
            "baseName": "unit_price",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return InvoiceItemResource.attributeTypeMap;
    }
}

export class InvoiceLogEntry {
    /**
    * The date this event occurred as a unix timestamp in seconds
    */
    'date': number;
    /**
    * The ID of the invoice
    */
    'invoiceId': number;
    /**
    * A message describing the event
    */
    'message': string;
    /**
    * The type of event
    */
    'type': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "date",
            "baseName": "date",
            "type": "number"
        },
        {
            "name": "invoiceId",
            "baseName": "invoice_id",
            "type": "number"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InvoiceLogEntry.attributeTypeMap;
    }
}

export class InvoicePaymentStatusRequest {
    /**
    * If included, will set the payment method used on the invoice
    */
    'paymentMethodId': number;
    /**
    * The new status for the invoice. Additional options may be available based on configuration.  Allowable values: 'new', 'paid', 'hold', 'canceled', 'payment failed', 'partial refund', 'refund'
    */
    'status': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "paymentMethodId",
            "baseName": "payment_method_id",
            "type": "number"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InvoicePaymentStatusRequest.attributeTypeMap;
    }
}

export class InvoiceResource {
    /**
    * Line one of the customer's billing address
    */
    'billingAddress1': string;
    /**
    * Line two of the customer's billing address
    */
    'billingAddress2': string;
    /**
    * The city for the customer's billing address
    */
    'billingCityName': string;
    /**
    * The country for the customer's billing address
    */
    'billingCountryName': string;
    /**
    * The customer's name for the billing address
    */
    'billingFullName': string;
    /**
    * The postal code for the customer's billing address
    */
    'billingPostalCode': string;
    /**
    * The state for the customer's billing address
    */
    'billingStateName': string;
    /**
    * The guid of the cart this invoice came from
    */
    'cartId': string;
    /**
    * The date the invoice was created, unix timestamp in seconds
    */
    'createdDate': number;
    /**
    * The code for the currency invoice prices are in
    */
    'currency': string;
    /**
    * The fulfillment status of the invoice
    */
    'currentFulfillmentStatus': string;
    /**
    * The payment status of the invoice
    */
    'currentPaymentStatus': string;
    /**
    * The amount of money saved through coupons
    */
    'discount': number;
    /**
    * The customer's email address
    */
    'email': string;
    /**
    * An external reference to filter on
    */
    'externalRef': string;
    /**
    * The amount of federal tax added
    */
    'fedTax': number;
    /**
    * The final price of the invoice
    */
    'grandTotal': number;
    /**
    * The id of the invoice
    */
    'id': number;
    /**
    * A reference number for the invoice
    */
    'invoiceNumber': string;
    /**
    * A list of items within the invoice
    */
    'items': Array<InvoiceItemResource>;
    /**
    * The customer's name prefix
    */
    'namePrefix': string;
    /**
    * Notes about the order
    */
    'orderNotes': string;
    /**
    * The id of an invoice this is a child of
    */
    'parentInvoiceId': number;
    /**
    * The id of a saved payment method used to pay for the invoice
    */
    'paymentMethodId': number;
    /**
    * The customer's phone number
    */
    'phone': string;
    /**
    * The customer's phone number
    */
    'phoneNumber': string;
    /**
    * The shipping cost
    */
    'shipping': number;
    /**
    * Line one of the customer's shipping address
    */
    'shippingAddress1': string;
    /**
    * Line two of the customer's shipping address
    */
    'shippingAddress2': string;
    /**
    * The city for the customer's shipping address
    */
    'shippingCityName': string;
    /**
    * The country for the customer's shipping address
    */
    'shippingCountryName': string;
    /**
    * The customer's name for the shipping address
    */
    'shippingFullName': string;
    /**
    * The postal code for the customer's shipping address
    */
    'shippingPostalCode': string;
    /**
    * The state for the customer's shipping address
    */
    'shippingStateName': string;
    /**
    * A number to use in sorting items. default 500.
    */
    'sort': number;
    /**
    * The amount of state tax added
    */
    'stateTax': number;
    /**
    * The sum price of all items before shipping, coupons and tax
    */
    'subtotal': number;
    /**
    * The date the invoice was last updated, unix timestamp in seconds
    */
    'updatedDate': number;
    /**
    * The owner of the invoice
    */
    'user': SimpleUserResource;
    /**
    * The id of the vendor
    */
    'vendorId': number;
    /**
    * The name of the invoice
    */
    'vendorName': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "billingAddress1",
            "baseName": "billing_address1",
            "type": "string"
        },
        {
            "name": "billingAddress2",
            "baseName": "billing_address2",
            "type": "string"
        },
        {
            "name": "billingCityName",
            "baseName": "billing_city_name",
            "type": "string"
        },
        {
            "name": "billingCountryName",
            "baseName": "billing_country_name",
            "type": "string"
        },
        {
            "name": "billingFullName",
            "baseName": "billing_full_name",
            "type": "string"
        },
        {
            "name": "billingPostalCode",
            "baseName": "billing_postal_code",
            "type": "string"
        },
        {
            "name": "billingStateName",
            "baseName": "billing_state_name",
            "type": "string"
        },
        {
            "name": "cartId",
            "baseName": "cart_id",
            "type": "string"
        },
        {
            "name": "createdDate",
            "baseName": "created_date",
            "type": "number"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "currentFulfillmentStatus",
            "baseName": "current_fulfillment_status",
            "type": "string"
        },
        {
            "name": "currentPaymentStatus",
            "baseName": "current_payment_status",
            "type": "string"
        },
        {
            "name": "discount",
            "baseName": "discount",
            "type": "number"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "externalRef",
            "baseName": "external_ref",
            "type": "string"
        },
        {
            "name": "fedTax",
            "baseName": "fed_tax",
            "type": "number"
        },
        {
            "name": "grandTotal",
            "baseName": "grand_total",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "invoiceNumber",
            "baseName": "invoice_number",
            "type": "string"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<InvoiceItemResource>"
        },
        {
            "name": "namePrefix",
            "baseName": "name_prefix",
            "type": "string"
        },
        {
            "name": "orderNotes",
            "baseName": "order_notes",
            "type": "string"
        },
        {
            "name": "parentInvoiceId",
            "baseName": "parent_invoice_id",
            "type": "number"
        },
        {
            "name": "paymentMethodId",
            "baseName": "payment_method_id",
            "type": "number"
        },
        {
            "name": "phone",
            "baseName": "phone",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phone_number",
            "type": "string"
        },
        {
            "name": "shipping",
            "baseName": "shipping",
            "type": "number"
        },
        {
            "name": "shippingAddress1",
            "baseName": "shipping_address1",
            "type": "string"
        },
        {
            "name": "shippingAddress2",
            "baseName": "shipping_address2",
            "type": "string"
        },
        {
            "name": "shippingCityName",
            "baseName": "shipping_city_name",
            "type": "string"
        },
        {
            "name": "shippingCountryName",
            "baseName": "shipping_country_name",
            "type": "string"
        },
        {
            "name": "shippingFullName",
            "baseName": "shipping_full_name",
            "type": "string"
        },
        {
            "name": "shippingPostalCode",
            "baseName": "shipping_postal_code",
            "type": "string"
        },
        {
            "name": "shippingStateName",
            "baseName": "shipping_state_name",
            "type": "string"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "number"
        },
        {
            "name": "stateTax",
            "baseName": "state_tax",
            "type": "number"
        },
        {
            "name": "subtotal",
            "baseName": "subtotal",
            "type": "number"
        },
        {
            "name": "updatedDate",
            "baseName": "updated_date",
            "type": "number"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "SimpleUserResource"
        },
        {
            "name": "vendorId",
            "baseName": "vendor_id",
            "type": "number"
        },
        {
            "name": "vendorName",
            "baseName": "vendor_name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InvoiceResource.attributeTypeMap;
    }
}

export class Item {
    /**
    * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type, or be an extra not from the template
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * The behaviors linked to the item, describing various options and interactions. May not be included in item lists
    */
    'behaviors': Array<Behavior>;
    /**
    * A category for filtering items
    */
    'category': string;
    /**
    * The date the item was created, unix timestamp in seconds
    */
    'createdDate': number;
    /**
    * The id of the item
    */
    'id': number;
    /**
    * A long description of the item
    */
    'longDescription': string;
    /**
    * The name of the item
    */
    'name': string;
    /**
    * A short description of the item, max 255 chars
    */
    'shortDescription': string;
    /**
    * A number to use in sorting items.  Default 500
    */
    'sort': number;
    /**
    * List of tags used for filtering items
    */
    'tags': Array<string>;
    /**
    * An item template this item is validated against.  May be null and no validation of additional_properties will be done.  Default = null
    */
    'template': string;
    /**
    * The type of the item
    */
    'typeHint': string;
    /**
    * The unique key for the item
    */
    'uniqueKey': string;
    /**
    * The date the item was last updated, unix timestamp in seconds
    */
    'updatedDate': number;

    static discriminator = type_hint;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "additionalProperties",
            "baseName": "additional_properties",
            "type": "{ [key: string]: Property; }"
        },
        {
            "name": "behaviors",
            "baseName": "behaviors",
            "type": "Array<Behavior>"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "string"
        },
        {
            "name": "createdDate",
            "baseName": "created_date",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "longDescription",
            "baseName": "long_description",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "shortDescription",
            "baseName": "short_description",
            "type": "string"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "number"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "template",
            "baseName": "template",
            "type": "string"
        },
        {
            "name": "typeHint",
            "baseName": "type_hint",
            "type": "string"
        },
        {
            "name": "uniqueKey",
            "baseName": "unique_key",
            "type": "string"
        },
        {
            "name": "updatedDate",
            "baseName": "updated_date",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Item.attributeTypeMap;
    }
}

export class ItemBehaviorDefinitionResource {
    /**
    * The default version of the behavior
    */
    'behavior': Behavior;
    /**
    * Whether the behavior's values can be modified
    */
    'modifiable': boolean;
    /**
    * Whether the behavior can be removed
    */
    'required': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "behavior",
            "baseName": "behavior",
            "type": "Behavior"
        },
        {
            "name": "modifiable",
            "baseName": "modifiable",
            "type": "boolean"
        },
        {
            "name": "required",
            "baseName": "required",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ItemBehaviorDefinitionResource.attributeTypeMap;
    }
}

export class ItemTemplateResource {
    /**
    * The customized behaviors that are required or default for this type of item
    */
    'behaviors': Array<ItemBehaviorDefinitionResource>;
    /**
    * The date/time this resource was created in seconds since unix epoch
    */
    'createdDate': number;
    /**
    * The id of the template
    */
    'id': string;
    /**
    * The name of the template
    */
    'name': string;
    /**
    * The customized properties that are present
    */
    'properties': Array<PropertyDefinitionResource>;
    /**
    * The date/time this resource was last updated in seconds since unix epoch
    */
    'updatedDate': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "behaviors",
            "baseName": "behaviors",
            "type": "Array<ItemBehaviorDefinitionResource>"
        },
        {
            "name": "createdDate",
            "baseName": "created_date",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "properties",
            "baseName": "properties",
            "type": "Array<PropertyDefinitionResource>"
        },
        {
            "name": "updatedDate",
            "baseName": "updated_date",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ItemTemplateResource.attributeTypeMap;
    }
}

export class KeyValuePairstringstring {
    'key': string;
    'value': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return KeyValuePairstringstring.attributeTypeMap;
    }
}

export class LeaderboardEntryResource {
    /**
    * The position of the user in the leaderboard. Null means non-compete or disqualification
    */
    'rank': number;
    /**
    * The raw score in this leaderboard. Null means non-compete or disqualification
    */
    'score': number;
    /**
    * The date this score was recorded or updated. Unix timestamp in seconds
    */
    'updatedDate': number;
    /**
    * The player for this entry
    */
    'user': SimpleUserResource;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "rank",
            "baseName": "rank",
            "type": "number"
        },
        {
            "name": "score",
            "baseName": "score",
            "type": "number"
        },
        {
            "name": "updatedDate",
            "baseName": "updated_date",
            "type": "number"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "SimpleUserResource"
        }    ];

    static getAttributeTypeMap() {
        return LeaderboardEntryResource.attributeTypeMap;
    }
}

export class LeaderboardResource {
    /**
    * The paginated list of user results, in order from best to worst
    */
    'entries': Array<LeaderboardEntryResource>;
    /**
    * The id of the leaderboard
    */
    'id': number;
    /**
    * The name of the strategy that defines how entries are stored and compared
    */
    'strategy': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "entries",
            "baseName": "entries",
            "type": "Array<LeaderboardEntryResource>"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "strategy",
            "baseName": "strategy",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LeaderboardResource.attributeTypeMap;
    }
}

export class LevelingResource {
    /**
    * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * The date the leveling schema was created
    */
    'createdDate': number;
    /**
    * The description of the leveling schema
    */
    'description': string;
    /**
    * The name of the leveling schema.  IMMUTABLE
    */
    'name': string;
    /**
    * A set of tiers that contain experience boundaries
    */
    'tiers': Array<TierResource>;
    /**
    * The date the leveling schema was updated
    */
    'updatedDate': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "additionalProperties",
            "baseName": "additional_properties",
            "type": "{ [key: string]: Property; }"
        },
        {
            "name": "createdDate",
            "baseName": "created_date",
            "type": "number"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "tiers",
            "baseName": "tiers",
            "type": "Array<TierResource>"
        },
        {
            "name": "updatedDate",
            "baseName": "updated_date",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return LevelingResource.attributeTypeMap;
    }
}

export class LimitedGettableGroup {
    /**
    * Whether to get active items only
    */
    'activeOnly': boolean;
    /**
    * The name of the group. Multiple items with the same group name will be limited together, leave null to be assigned a random unique name. It is typical that owned_limit and active_only will be the same for all, but this is not enforced and the item being recieved will use its settings.
    */
    'name': string;
    /**
    * The max number of items that can be purchased
    */
    'ownedLimit': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "activeOnly",
            "baseName": "active_only",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "ownedLimit",
            "baseName": "owned_limit",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return LimitedGettableGroup.attributeTypeMap;
    }
}

export class Localizer {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return Localizer.attributeTypeMap;
    }
}

export class LocationLogResource {
    'country': string;
    'ip': string;
    'time': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "ip",
            "baseName": "ip",
            "type": "string"
        },
        {
            "name": "time",
            "baseName": "time",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return LocationLogResource.attributeTypeMap;
    }
}

export class LookupResource {
    'lookupKey': ExpressionResource;
    'type': string;
    'valueType': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "lookupKey",
            "baseName": "lookup_key",
            "type": "ExpressionResource"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "valueType",
            "baseName": "value_type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LookupResource.attributeTypeMap;
    }
}

export class LookupTypeResource {
    /**
    * The description of the expression type
    */
    'description': string;
    /**
    * The variable type the key expression must be, or null if it's dependent (see description for explanation in this case)
    */
    'keyType': string;
    /**
    * The name of the expression type
    */
    'name': string;
    /**
    * The variable type of the value this expression returns, or null if it's dependent (see description for explanation in this case)
    */
    'valueType': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "keyType",
            "baseName": "key_type",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "valueType",
            "baseName": "value_type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LookupTypeResource.attributeTypeMap;
    }
}

export class Maintenance {
    /**
    * Whether access to the system has been locked
    */
    'accessLocked': boolean;
    /**
    * A simple object of any schema for client side use and processing
    */
    'details': any;
    /**
    * User displayable message about the maintenance
    */
    'message': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accessLocked",
            "baseName": "access_locked",
            "type": "boolean"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "any"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Maintenance.attributeTypeMap;
    }
}

export class MapResource {
    'map': { [key: string]: ExpressionResource; };
    'type': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "map",
            "baseName": "map",
            "type": "{ [key: string]: ExpressionResource; }"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MapResource.attributeTypeMap;
    }
}

export class Mapstringobject extends null<String, any> {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Mapstringobject.attributeTypeMap);
    }
}

export class MetricResource {
    /**
    * The id of the activity occurence where this score/metric occurred
    */
    'activityOccurenceId': number;
    /**
    * Any tags for the metric. Each unique tag will translate into a unique leaderboard. Maximum 5 tags and 50 characters each
    */
    'tags': Array<string>;
    /**
    * The value/score of the metric
    */
    'value': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "activityOccurenceId",
            "baseName": "activity_occurence_id",
            "type": "number"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return MetricResource.attributeTypeMap;
    }
}

export class MongoDatabaseConfig {
    'dbName': string;
    'options': string;
    'password': string;
    'servers': string;
    'username': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "dbName",
            "baseName": "db_name",
            "type": "string"
        },
        {
            "name": "options",
            "baseName": "options",
            "type": "string"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        },
        {
            "name": "servers",
            "baseName": "servers",
            "type": "string"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MongoDatabaseConfig.attributeTypeMap;
    }
}

export class NestedCategory {
    /**
    * Whether the category is active
    */
    'active': boolean;
    /**
    * The id of the category
    */
    'id': string;
    /**
    * The name of the category
    */
    'name': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NestedCategory.attributeTypeMap;
    }
}

export class NewPasswordRequest {
    /**
    * The new password in plain text
    */
    'password': string;
    /**
    * The secret provided after the password reset
    */
    'secret': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        },
        {
            "name": "secret",
            "baseName": "secret",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NewPasswordRequest.attributeTypeMap;
    }
}

export class OAuth2Resource {
    /**
    * The access token issued by the authorization server
    */
    'accessToken': string;
    /**
    * The lifetime in seconds of the access token
    */
    'expiresIn': string;
    /**
    * The scope of the access token. Currently these values can be ignored, as security defaults to roles and permissions
    */
    'scope': string;
    /**
    * The type of the token issued
    */
    'tokenType': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accessToken",
            "baseName": "access_token",
            "type": "string"
        },
        {
            "name": "expiresIn",
            "baseName": "expires_in",
            "type": "string"
        },
        {
            "name": "scope",
            "baseName": "scope",
            "type": "string"
        },
        {
            "name": "tokenType",
            "baseName": "token_type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OAuth2Resource.attributeTypeMap;
    }
}

export class OauthAccessTokenResource {
    /**
    * The key of the client assosciated with the token
    */
    'clientId': string;
    /**
    * The token.  Not shown in list view
    */
    'token': string;
    /**
    * The username of the user associated with the token
    */
    'username': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientId",
            "baseName": "client_id",
            "type": "string"
        },
        {
            "name": "token",
            "baseName": "token",
            "type": "string"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OauthAccessTokenResource.attributeTypeMap;
    }
}

export class Operator {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return Operator.attributeTypeMap;
    }
}

export class OptimalPaymentRequest {
    /**
    * The email address of the user
    */
    'email': string;
    /**
    * The first name of the user
    */
    'firstName': string;
    /**
    * The id of the invoice to pay
    */
    'invoiceId': number;
    /**
    * The last name of the user
    */
    'lastName': string;
    /**
    * The url to redirect the user to after declining payment
    */
    'onDecline': string;
    /**
    * The url to redirect the user to after an error in payment
    */
    'onError': string;
    /**
    * The url to redirect the user to after successful payment
    */
    'onSuccess': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "first_name",
            "type": "string"
        },
        {
            "name": "invoiceId",
            "baseName": "invoice_id",
            "type": "number"
        },
        {
            "name": "lastName",
            "baseName": "last_name",
            "type": "string"
        },
        {
            "name": "onDecline",
            "baseName": "on_decline",
            "type": "string"
        },
        {
            "name": "onError",
            "baseName": "on_error",
            "type": "string"
        },
        {
            "name": "onSuccess",
            "baseName": "on_success",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OptimalPaymentRequest.attributeTypeMap;
    }
}

export class Order {
    'ascending': boolean;
    'descending': boolean;
    'direction': Order.DirectionEnum;
    'ignoreCase': boolean;
    'nullHandling': Order.NullHandlingEnum;
    'property': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ascending",
            "baseName": "ascending",
            "type": "boolean"
        },
        {
            "name": "descending",
            "baseName": "descending",
            "type": "boolean"
        },
        {
            "name": "direction",
            "baseName": "direction",
            "type": "Order.DirectionEnum"
        },
        {
            "name": "ignoreCase",
            "baseName": "ignore_case",
            "type": "boolean"
        },
        {
            "name": "nullHandling",
            "baseName": "null_handling",
            "type": "Order.NullHandlingEnum"
        },
        {
            "name": "property",
            "baseName": "property",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Order.attributeTypeMap;
    }
}

export namespace Order {
    export enum DirectionEnum {
        ASC = <any> 'ASC',
        DESC = <any> 'DESC'
    }
    export enum NullHandlingEnum {
        NATIVE = <any> 'NATIVE',
        NULLSFIRST = <any> 'NULLS_FIRST',
        NULLSLAST = <any> 'NULLS_LAST'
    }
}
export class PageResourceAchievementDefinitionResource {
    'content': Array<AchievementDefinitionResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<AchievementDefinitionResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceAchievementDefinitionResource.attributeTypeMap;
    }
}

export class PageResourceAggregateCountResource {
    'content': Array<AggregateCountResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<AggregateCountResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceAggregateCountResource.attributeTypeMap;
    }
}

export class PageResourceAggregateInvoiceReportResource {
    'content': Array<AggregateInvoiceReportResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<AggregateInvoiceReportResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceAggregateInvoiceReportResource.attributeTypeMap;
    }
}

export class PageResourceArticleResource {
    'content': Array<ArticleResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<ArticleResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceArticleResource.attributeTypeMap;
    }
}

export class PageResourceArtistResource {
    'content': Array<ArtistResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<ArtistResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceArtistResource.attributeTypeMap;
    }
}

export class PageResourceBareActivityResource {
    'content': Array<BareActivityResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<BareActivityResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceBareActivityResource.attributeTypeMap;
    }
}

export class PageResourceBareChallengeActivityResource {
    'content': Array<BareChallengeActivityResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<BareChallengeActivityResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceBareChallengeActivityResource.attributeTypeMap;
    }
}

export class PageResourceBillingReport {
    'content': Array<BillingReport>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<BillingReport>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceBillingReport.attributeTypeMap;
    }
}

export class PageResourceBreCategoryResource {
    'content': Array<BreCategoryResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<BreCategoryResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceBreCategoryResource.attributeTypeMap;
    }
}

export class PageResourceBreEventLog {
    'content': Array<BreEventLog>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<BreEventLog>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceBreEventLog.attributeTypeMap;
    }
}

export class PageResourceBreGlobalResource {
    'content': Array<BreGlobalResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<BreGlobalResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceBreGlobalResource.attributeTypeMap;
    }
}

export class PageResourceBreRule {
    'content': Array<BreRule>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<BreRule>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceBreRule.attributeTypeMap;
    }
}

export class PageResourceBreTriggerResource {
    'content': Array<BreTriggerResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<BreTriggerResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceBreTriggerResource.attributeTypeMap;
    }
}

export class PageResourceCampaignResource {
    'content': Array<CampaignResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<CampaignResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceCampaignResource.attributeTypeMap;
    }
}

export class PageResourceCartSummary {
    'content': Array<CartSummary>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<CartSummary>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceCartSummary.attributeTypeMap;
    }
}

export class PageResourceCatalogSale {
    'content': Array<CatalogSale>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<CatalogSale>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceCatalogSale.attributeTypeMap;
    }
}

export class PageResourceCategoryResource {
    'content': Array<CategoryResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<CategoryResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceCategoryResource.attributeTypeMap;
    }
}

export class PageResourceChallengeEventParticipantResource {
    'content': Array<ChallengeEventParticipantResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<ChallengeEventParticipantResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceChallengeEventParticipantResource.attributeTypeMap;
    }
}

export class PageResourceChallengeEventResource {
    'content': Array<ChallengeEventResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<ChallengeEventResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceChallengeEventResource.attributeTypeMap;
    }
}

export class PageResourceChallengeResource {
    'content': Array<ChallengeResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<ChallengeResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceChallengeResource.attributeTypeMap;
    }
}

export class PageResourceClientResource {
    'content': Array<ClientResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<ClientResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceClientResource.attributeTypeMap;
    }
}

export class PageResourceCommentResource {
    'content': Array<CommentResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<CommentResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceCommentResource.attributeTypeMap;
    }
}

export class PageResourceConfig {
    'content': Array<Config>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<Config>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceConfig.attributeTypeMap;
    }
}

export class PageResourceCountryTaxResource {
    'content': Array<CountryTaxResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<CountryTaxResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceCountryTaxResource.attributeTypeMap;
    }
}

export class PageResourceCurrencyResource {
    'content': Array<CurrencyResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<CurrencyResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceCurrencyResource.attributeTypeMap;
    }
}

export class PageResourceDeviceResource {
    'content': Array<DeviceResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<DeviceResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceDeviceResource.attributeTypeMap;
    }
}

export class PageResourceDispositionResource {
    'content': Array<DispositionResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<DispositionResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceDispositionResource.attributeTypeMap;
    }
}

export class PageResourceEntitlementItem {
    'content': Array<EntitlementItem>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<EntitlementItem>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceEntitlementItem.attributeTypeMap;
    }
}

export class PageResourceFlagReportResource {
    'content': Array<FlagReportResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<FlagReportResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceFlagReportResource.attributeTypeMap;
    }
}

export class PageResourceForwardLog {
    'content': Array<ForwardLog>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<ForwardLog>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceForwardLog.attributeTypeMap;
    }
}

export class PageResourceFulfillmentType {
    'content': Array<FulfillmentType>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<FulfillmentType>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceFulfillmentType.attributeTypeMap;
    }
}

export class PageResourceGroupMemberResource {
    'content': Array<GroupMemberResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<GroupMemberResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceGroupMemberResource.attributeTypeMap;
    }
}

export class PageResourceGroupResource {
    'content': Array<GroupResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<GroupResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceGroupResource.attributeTypeMap;
    }
}

export class PageResourceImportJobResource {
    'content': Array<ImportJobResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<ImportJobResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceImportJobResource.attributeTypeMap;
    }
}

export class PageResourceInvoiceLogEntry {
    'content': Array<InvoiceLogEntry>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<InvoiceLogEntry>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceInvoiceLogEntry.attributeTypeMap;
    }
}

export class PageResourceInvoiceResource {
    'content': Array<InvoiceResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<InvoiceResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceInvoiceResource.attributeTypeMap;
    }
}

export class PageResourceItemTemplateResource {
    'content': Array<ItemTemplateResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<ItemTemplateResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceItemTemplateResource.attributeTypeMap;
    }
}

export class PageResourceLevelingResource {
    'content': Array<LevelingResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<LevelingResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceLevelingResource.attributeTypeMap;
    }
}

export class PageResourceLocationLogResource {
    'content': Array<LocationLogResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<LocationLogResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceLocationLogResource.attributeTypeMap;
    }
}

export class PageResourceMapstringobject {
    'content': Array<Mapstringobject>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<Mapstringobject>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceMapstringobject.attributeTypeMap;
    }
}

export class PageResourceOauthAccessTokenResource {
    'content': Array<OauthAccessTokenResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<OauthAccessTokenResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceOauthAccessTokenResource.attributeTypeMap;
    }
}

export class PageResourcePermissionResource {
    'content': Array<PermissionResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<PermissionResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourcePermissionResource.attributeTypeMap;
    }
}

export class PageResourcePollResource {
    'content': Array<PollResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<PollResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourcePollResource.attributeTypeMap;
    }
}

export class PageResourceQuestionResource {
    'content': Array<QuestionResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<QuestionResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceQuestionResource.attributeTypeMap;
    }
}

export class PageResourceQuestionTemplateResource {
    'content': Array<QuestionTemplateResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<QuestionTemplateResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceQuestionTemplateResource.attributeTypeMap;
    }
}

export class PageResourceRevenueCountryReportResource {
    'content': Array<RevenueCountryReportResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<RevenueCountryReportResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceRevenueCountryReportResource.attributeTypeMap;
    }
}

export class PageResourceRevenueProductReportResource {
    'content': Array<RevenueProductReportResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<RevenueProductReportResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceRevenueProductReportResource.attributeTypeMap;
    }
}

export class PageResourceRewardSetResource {
    'content': Array<RewardSetResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<RewardSetResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceRewardSetResource.attributeTypeMap;
    }
}

export class PageResourceRoleResource {
    'content': Array<RoleResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<RoleResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceRoleResource.attributeTypeMap;
    }
}

export class PageResourceSavedAddressResource {
    'content': Array<SavedAddressResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<SavedAddressResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceSavedAddressResource.attributeTypeMap;
    }
}

export class PageResourceSimpleReferenceResourceobject {
    'content': Array<SimpleReferenceResourceobject>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<SimpleReferenceResourceobject>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceSimpleReferenceResourceobject.attributeTypeMap;
    }
}

export class PageResourceSimpleUserResource {
    'content': Array<SimpleUserResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<SimpleUserResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceSimpleUserResource.attributeTypeMap;
    }
}

export class PageResourceSimpleWallet {
    'content': Array<SimpleWallet>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<SimpleWallet>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceSimpleWallet.attributeTypeMap;
    }
}

export class PageResourceStateTaxResource {
    'content': Array<StateTaxResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<StateTaxResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceStateTaxResource.attributeTypeMap;
    }
}

export class PageResourceStoreItem {
    'content': Array<StoreItem>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<StoreItem>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceStoreItem.attributeTypeMap;
    }
}

export class PageResourceStoreItemTemplateResource {
    'content': Array<StoreItemTemplateResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<StoreItemTemplateResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceStoreItemTemplateResource.attributeTypeMap;
    }
}

export class PageResourceSubscriptionResource {
    'content': Array<SubscriptionResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<SubscriptionResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceSubscriptionResource.attributeTypeMap;
    }
}

export class PageResourceSubscriptionTemplateResource {
    'content': Array<SubscriptionTemplateResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<SubscriptionTemplateResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceSubscriptionTemplateResource.attributeTypeMap;
    }
}

export class PageResourceTemplateResource {
    'content': Array<TemplateResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<TemplateResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceTemplateResource.attributeTypeMap;
    }
}

export class PageResourceTransactionResource {
    'content': Array<TransactionResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<TransactionResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceTransactionResource.attributeTypeMap;
    }
}

export class PageResourceUsageInfo {
    'content': Array<UsageInfo>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<UsageInfo>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceUsageInfo.attributeTypeMap;
    }
}

export class PageResourceUserAchievementGroupResource {
    'content': Array<UserAchievementGroupResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<UserAchievementGroupResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceUserAchievementGroupResource.attributeTypeMap;
    }
}

export class PageResourceUserActionLog {
    'content': Array<UserActionLog>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<UserActionLog>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceUserActionLog.attributeTypeMap;
    }
}

export class PageResourceUserBaseResource {
    'content': Array<UserBaseResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<UserBaseResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceUserBaseResource.attributeTypeMap;
    }
}

export class PageResourceUserInventoryResource {
    'content': Array<UserInventoryResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<UserInventoryResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceUserInventoryResource.attributeTypeMap;
    }
}

export class PageResourceUserItemLogResource {
    'content': Array<UserItemLogResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<UserItemLogResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceUserItemLogResource.attributeTypeMap;
    }
}

export class PageResourceUserLevelingResource {
    'content': Array<UserLevelingResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<UserLevelingResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceUserLevelingResource.attributeTypeMap;
    }
}

export class PageResourceUserRelationshipResource {
    'content': Array<UserRelationshipResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<UserRelationshipResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceUserRelationshipResource.attributeTypeMap;
    }
}

export class PageResourceVendorResource {
    'content': Array<VendorResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<VendorResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceVendorResource.attributeTypeMap;
    }
}

export class PageResourceVideoRelationshipResource {
    'content': Array<VideoRelationshipResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<VideoRelationshipResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceVideoRelationshipResource.attributeTypeMap;
    }
}

export class PageResourceVideoResource {
    'content': Array<VideoResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<VideoResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceVideoResource.attributeTypeMap;
    }
}

export class PageResourceWalletTotalResponse {
    'content': Array<WalletTotalResponse>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<WalletTotalResponse>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceWalletTotalResponse.attributeTypeMap;
    }
}

export class PageResourceWalletTransactionResource {
    'content': Array<WalletTransactionResource>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<WalletTransactionResource>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourceWalletTransactionResource.attributeTypeMap;
    }
}

export class PageResourcestring {
    'content': Array<string>;
    'first': boolean;
    'last': boolean;
    'number': number;
    'numberOfElements': number;
    'size': number;
    'sort': Array<Order>;
    'totalElements': number;
    'totalPages': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<string>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "number_of_elements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<Order>"
        },
        {
            "name": "totalElements",
            "baseName": "total_elements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageResourcestring.attributeTypeMap;
    }
}

export class ParameterResource {
    'of': string;
    'type': string;
    'value': any;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "of",
            "baseName": "of",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return ParameterResource.attributeTypeMap;
    }
}

/**
* A request to reset a user's password by using a known user property
*/
export class PasswordResetRequest {
    /**
    * The user's email address
    */
    'email': string;
    /**
    * The user's mobile phone number
    */
    'mobileNumber': string;
    /**
    * The user's username
    */
    'username': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "mobileNumber",
            "baseName": "mobile_number",
            "type": "string"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PasswordResetRequest.attributeTypeMap;
    }
}

export class PayBySavedMethodRequest {
    /**
    * The id of the payment method to use. Must belong to the caller, be public or have PAYMENTS_ADMIN permission
    */
    'paymentMethod': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "paymentMethod",
            "baseName": "payment_method",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PayBySavedMethodRequest.attributeTypeMap;
    }
}

export class PaymentAuthorizationResource {
    /**
    * Whether this authorization has been captured
    */
    'captured': boolean;
    /**
    * The date this authorization was received, unix timestamp in seconds
    */
    'created': number;
    /**
    * The details for this authorization. Format dependent on payment provider
    */
    'details': any;
    /**
    * The id of the authorization
    */
    'id': number;
    /**
    * The invoice this authorization is intended to pay
    */
    'invoice': number;
    /**
    * The payment type (which provider) this payment is through
    */
    'paymentType': SimpleReferenceResourceint;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "captured",
            "baseName": "captured",
            "type": "boolean"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "number"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "any"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "invoice",
            "baseName": "invoice",
            "type": "number"
        },
        {
            "name": "paymentType",
            "baseName": "payment_type",
            "type": "SimpleReferenceResourceint"
        }    ];

    static getAttributeTypeMap() {
        return PaymentAuthorizationResource.attributeTypeMap;
    }
}

export class PaymentMethodDetails {
    'default': boolean;
    /**
    * The expiration date for the payment method, expressed as seconds since epoch. Typically used for credit card payment methods
    */
    'expirationDate': number;
    /**
    * The expiration month (1 - 12) for the payment method. Typically used for credit card payment methods
    */
    'expirationMonth': number;
    /**
    * The expiration year for the payment method. Typically used for credit card payment methods
    */
    'expirationYear': number;
    /**
    * The last 4 digits of the account number for the payment method. Typically used for credit card payment methods
    */
    'last4': string;
    /**
    * The sort value for the payment method
    */
    'sort': number;
    /**
    * An optional unique identifier
    */
    'uniqueKey': string;
    'verified': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "default",
            "baseName": "default",
            "type": "boolean"
        },
        {
            "name": "expirationDate",
            "baseName": "expiration_date",
            "type": "number"
        },
        {
            "name": "expirationMonth",
            "baseName": "expiration_month",
            "type": "number"
        },
        {
            "name": "expirationYear",
            "baseName": "expiration_year",
            "type": "number"
        },
        {
            "name": "last4",
            "baseName": "last4",
            "type": "string"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "number"
        },
        {
            "name": "uniqueKey",
            "baseName": "unique_key",
            "type": "string"
        },
        {
            "name": "verified",
            "baseName": "verified",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return PaymentMethodDetails.attributeTypeMap;
    }
}

export class PaymentMethodResource {
    /**
    * The date/time this resource was created in seconds since unix epoch
    */
    'createdDate': number;
    'default': boolean;
    /**
    * Whether this payment method is disabled or not
    */
    'disabled': boolean;
    /**
    * The expiration date for the payment method, expressed as seconds since epoch. Typically used for credit card payment methods
    */
    'expirationDate': number;
    /**
    * The expiration month (1 - 12) for the payment method. Typically used for credit card payment methods
    */
    'expirationMonth': number;
    /**
    * The expiration year for the payment method. Typically used for credit card payment methods
    */
    'expirationYear': number;
    /**
    * The unique ID of the resource
    */
    'id': number;
    /**
    * The last 4 digits of the account number for the payment method. Typically used for credit card payment methods
    */
    'last4': string;
    /**
    * The user friendly name of the resource
    */
    'name': string;
    /**
    * The type of payment method. Must be a pre-existing value
    */
    'paymentMethodType': PaymentMethodTypeResource;
    /**
    * The generic payment type. Default is card
    */
    'paymentType': PaymentMethodResource.PaymentTypeEnum;
    /**
    * The sort value for the payment method
    */
    'sort': number;
    /**
    * The unique token for the payment method
    */
    'token': string;
    /**
    * An optional unique identifier
    */
    'uniqueKey': string;
    /**
    * The date/time this resource was last updated in seconds since unix epoch
    */
    'updatedDate': number;
    /**
    * The user's id. If null, indicates a shared payment method that any user can use (i.e., 'wallet')
    */
    'userId': number;
    'verified': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdDate",
            "baseName": "created_date",
            "type": "number"
        },
        {
            "name": "default",
            "baseName": "default",
            "type": "boolean"
        },
        {
            "name": "disabled",
            "baseName": "disabled",
            "type": "boolean"
        },
        {
            "name": "expirationDate",
            "baseName": "expiration_date",
            "type": "number"
        },
        {
            "name": "expirationMonth",
            "baseName": "expiration_month",
            "type": "number"
        },
        {
            "name": "expirationYear",
            "baseName": "expiration_year",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "last4",
            "baseName": "last4",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "paymentMethodType",
            "baseName": "payment_method_type",
            "type": "PaymentMethodTypeResource"
        },
        {
            "name": "paymentType",
            "baseName": "payment_type",
            "type": "PaymentMethodResource.PaymentTypeEnum"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "number"
        },
        {
            "name": "token",
            "baseName": "token",
            "type": "string"
        },
        {
            "name": "uniqueKey",
            "baseName": "unique_key",
            "type": "string"
        },
        {
            "name": "updatedDate",
            "baseName": "updated_date",
            "type": "number"
        },
        {
            "name": "userId",
            "baseName": "user_id",
            "type": "number"
        },
        {
            "name": "verified",
            "baseName": "verified",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return PaymentMethodResource.attributeTypeMap;
    }
}

export namespace PaymentMethodResource {
    export enum PaymentTypeEnum {
        Card = <any> 'card',
        BankAccount = <any> 'bank_account'
    }
}
export class PaymentMethodTypeResource {
    /**
    * The id of the payment method type
    */
    'id': number;
    /**
    * The name of the payment method type
    */
    'name': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PaymentMethodTypeResource.attributeTypeMap;
    }
}

export class PermissionResource {
    /**
    * The date the permission was added. Unix timestamp in seconds
    */
    'createdDate': number;
    /**
    * The description of the permission
    */
    'description': string;
    /**
    * Whether a permission is locked from being deleted
    */
    'locked': boolean;
    /**
    * The name of the permission used for display purposes
    */
    'name': string;
    /**
    * The name of the parent of the permission
    */
    'parent': string;
    /**
    * The keyword that defines the permission
    */
    'permission': string;
    /**
    * The date the permission was updated. Unix timestamp in seconds
    */
    'updatedDate': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdDate",
            "baseName": "created_date",
            "type": "number"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "locked",
            "baseName": "locked",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "parent",
            "baseName": "parent",
            "type": "string"
        },
        {
            "name": "permission",
            "baseName": "permission",
            "type": "string"
        },
        {
            "name": "updatedDate",
            "baseName": "updated_date",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PermissionResource.attributeTypeMap;
    }
}

export class PollAnswerResource {
    /**
    * The number of users that selected this answer
    */
    'count': number;
    /**
    * The key to the answer (for code reference)
    */
    'key': string;
    /**
    * The text of the answer (for user display)
    */
    'text': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "text",
            "baseName": "text",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PollAnswerResource.attributeTypeMap;
    }
}

export class PollResource {
    /**
    * Whether the poll is active
    */
    'active': boolean;
    /**
    * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * The answers to the poll
    */
    'answers': Array<PollAnswerResource>;
    /**
    * The category for the poll
    */
    'category': NestedCategory;
    /**
    * The date/time this resource was created in seconds since unix epoch
    */
    'createdDate': number;
    /**
    * The id of the poll
    */
    'id': string;
    /**
    * The tags for the poll
    */
    'tags': Array<string>;
    /**
    * A poll template this poll is validated against (private). May be null and no validation of additional_properties will be done
    */
    'template': string;
    /**
    * The text of the poll
    */
    'text': string;
    /**
    * The media type of the poll
    */
    'type': PollResource.TypeEnum;
    /**
    * The date/time this resource was last updated in seconds since unix epoch
    */
    'updatedDate': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "additionalProperties",
            "baseName": "additional_properties",
            "type": "{ [key: string]: Property; }"
        },
        {
            "name": "answers",
            "baseName": "answers",
            "type": "Array<PollAnswerResource>"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "NestedCategory"
        },
        {
            "name": "createdDate",
            "baseName": "created_date",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "template",
            "baseName": "template",
            "type": "string"
        },
        {
            "name": "text",
            "baseName": "text",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "PollResource.TypeEnum"
        },
        {
            "name": "updatedDate",
            "baseName": "updated_date",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PollResource.attributeTypeMap;
    }
}

export namespace PollResource {
    export enum TypeEnum {
        TEXT = <any> 'TEXT',
        IMAGE = <any> 'IMAGE',
        VIDEO = <any> 'VIDEO',
        AUDIO = <any> 'AUDIO'
    }
}
export class PollResponseResource {
    /**
    * The answer to the poll
    */
    'answer': string;
    /**
    * The date the poll was answered, in seconds since unix epoc
    */
    'answeredDate': number;
    /**
    * The id of the poll response
    */
    'id': string;
    /**
    * The id of the poll
    */
    'pollId': string;
    /**
    * The user
    */
    'user': SimpleUserResource;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "answer",
            "baseName": "answer",
            "type": "string"
        },
        {
            "name": "answeredDate",
            "baseName": "answered_date",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "pollId",
            "baseName": "poll_id",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "SimpleUserResource"
        }    ];

    static getAttributeTypeMap() {
        return PollResponseResource.attributeTypeMap;
    }
}

export class PredicateOperation {
    'args': Array<Expressionobject>;
    'operator': Operator;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "args",
            "baseName": "args",
            "type": "Array<Expressionobject>"
        },
        {
            "name": "operator",
            "baseName": "operator",
            "type": "Operator"
        }    ];

    static getAttributeTypeMap() {
        return PredicateOperation.attributeTypeMap;
    }
}

export class PredicateResource {
    /**
    * The arguments the operator apply to. See notes for details.
    */
    'args': Array<ExpressionResource>;
    /**
    * The operator to be used in this predicate. See notes for details.
    */
    'op': string;
    'type': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "args",
            "baseName": "args",
            "type": "Array<ExpressionResource>"
        },
        {
            "name": "op",
            "baseName": "op",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PredicateResource.attributeTypeMap;
    }
}

export class Property {
    /**
    * The type of the property. Used for polymorphic type recognition and thus must match an expected type with additional properties.
    */
    'type': string;

    static discriminator = type;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Property.attributeTypeMap;
    }
}

export class PropertyDefinitionResource {
    /**
    * A list of the fields on both the property definition and property of this type
    */
    'fieldList': PropertyFieldListResource;
    /**
    * The name of the property
    */
    'name': string;
    /**
    * Whether the property is required
    */
    'required': boolean;
    /**
    * The type of the property. Used for polymorphic type recognition and thus must match an expected type with additional properties.
    */
    'type': string;

    static discriminator = type;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fieldList",
            "baseName": "field_list",
            "type": "PropertyFieldListResource"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "required",
            "baseName": "required",
            "type": "boolean"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PropertyDefinitionResource.attributeTypeMap;
    }
}

export class PropertyFieldListResource {
    /**
    * A list of fields for the property definition.
    */
    'propertyDefinitionFields': Array<PropertyFieldResource>;
    /**
    * A list of fields for the property.
    */
    'propertyFields': Array<PropertyFieldResource>;
    /**
    * The type for the property this describes.
    */
    'propertyType': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "propertyDefinitionFields",
            "baseName": "property_definition_fields",
            "type": "Array<PropertyFieldResource>"
        },
        {
            "name": "propertyFields",
            "baseName": "property_fields",
            "type": "Array<PropertyFieldResource>"
        },
        {
            "name": "propertyType",
            "baseName": "property_type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PropertyFieldListResource.attributeTypeMap;
    }
}

export class PropertyFieldResource {
    /**
    * A description of the field
    */
    'description': string;
    /**
    * The type of values within a 'list' type field
    */
    'innerType': PropertyFieldResource.InnerTypeEnum;
    /**
    * A description of fields within objects within a 'list' type field, when inner_type is 'object'
    */
    'innerTypeFields': Array<PropertyFieldResource>;
    /**
    * The name of the field
    */
    'name': string;
    /**
    * Whether the field is required
    */
    'required': boolean;
    /**
    * The type of the field
    */
    'type': PropertyFieldResource.TypeEnum;
    /**
    * A list of valid values for 'enum' type fields
    */
    'validValues': Array<string>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "innerType",
            "baseName": "inner_type",
            "type": "PropertyFieldResource.InnerTypeEnum"
        },
        {
            "name": "innerTypeFields",
            "baseName": "inner_type_fields",
            "type": "Array<PropertyFieldResource>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "required",
            "baseName": "required",
            "type": "boolean"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "PropertyFieldResource.TypeEnum"
        },
        {
            "name": "validValues",
            "baseName": "valid_values",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return PropertyFieldResource.attributeTypeMap;
    }
}

export namespace PropertyFieldResource {
    export enum InnerTypeEnum {
        Integer = <any> 'integer',
        Number = <any> 'number',
        Bool = <any> 'bool',
        String = <any> 'string',
        Enumeration = <any> 'enumeration',
        List = <any> 'list',
        Object = <any> 'object'
    }
    export enum TypeEnum {
        Integer = <any> 'integer',
        Number = <any> 'number',
        Bool = <any> 'bool',
        String = <any> 'string',
        Enumeration = <any> 'enumeration',
        List = <any> 'list',
        Object = <any> 'object'
    }
}
export class QuestionResource {
    /**
    * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * The list of available answers
    */
    'answers': Array<AnswerResource>;
    /**
    * The category for the question
    */
    'category': NestedCategory;
    /**
    * The date/time this resource was created in seconds since unix epoch
    */
    'createdDate': number;
    /**
    * The difficulty of the question
    */
    'difficulty': number;
    /**
    * The unique ID for that resource
    */
    'id': string;
    /**
    * The id of the import job that created the question, or null if not from an import
    */
    'importId': number;
    /**
    * When the question becomes available, null for never, in seconds since epoch
    */
    'publishedDate': number;
    /**
    * The question. Different 'type' values indicate different structures as the question may be test, image, etc. See information on additional properties for the list and their structures
    */
    'question': Property;
    /**
    * The first source of the question
    */
    'source1': string;
    /**
    * The second source of the question
    */
    'source2': string;
    /**
    * The list of tags
    */
    'tags': Array<string>;
    /**
    * A question template this question is validated against (private). May be null and no validation of additional_properties will be done
    */
    'template': string;
    /**
    * The date/time this resource was last updated in seconds since unix epoch
    */
    'updatedDate': number;
    /**
    * The supplier of the question
    */
    'vendor': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "additionalProperties",
            "baseName": "additional_properties",
            "type": "{ [key: string]: Property; }"
        },
        {
            "name": "answers",
            "baseName": "answers",
            "type": "Array<AnswerResource>"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "NestedCategory"
        },
        {
            "name": "createdDate",
            "baseName": "created_date",
            "type": "number"
        },
        {
            "name": "difficulty",
            "baseName": "difficulty",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "importId",
            "baseName": "import_id",
            "type": "number"
        },
        {
            "name": "publishedDate",
            "baseName": "published_date",
            "type": "number"
        },
        {
            "name": "question",
            "baseName": "question",
            "type": "Property"
        },
        {
            "name": "source1",
            "baseName": "source1",
            "type": "string"
        },
        {
            "name": "source2",
            "baseName": "source2",
            "type": "string"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "template",
            "baseName": "template",
            "type": "string"
        },
        {
            "name": "updatedDate",
            "baseName": "updated_date",
            "type": "number"
        },
        {
            "name": "vendor",
            "baseName": "vendor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return QuestionResource.attributeTypeMap;
    }
}

export class QuestionTemplateResource {
    /**
    * A property definition for all answers. If included each answer must match this definition's type and be valid
    */
    'answerProperty': PropertyDefinitionResource;
    /**
    * The date/time this resource was created in seconds since unix epoch
    */
    'createdDate': number;
    /**
    * The id of the template
    */
    'id': string;
    /**
    * The name of the template
    */
    'name': string;
    /**
    * The customized properties that are present
    */
    'properties': Array<PropertyDefinitionResource>;
    /**
    * A property definition for the question itself. If included the answer must match this definition's type and be valid
    */
    'questionProperty': PropertyDefinitionResource;
    /**
    * The date/time this resource was last updated in seconds since unix epoch
    */
    'updatedDate': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "answerProperty",
            "baseName": "answer_property",
            "type": "PropertyDefinitionResource"
        },
        {
            "name": "createdDate",
            "baseName": "created_date",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "properties",
            "baseName": "properties",
            "type": "Array<PropertyDefinitionResource>"
        },
        {
            "name": "questionProperty",
            "baseName": "question_property",
            "type": "PropertyDefinitionResource"
        },
        {
            "name": "updatedDate",
            "baseName": "updated_date",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return QuestionTemplateResource.attributeTypeMap;
    }
}

export class QuickBuyRequest {
    /**
    * SKU of item being purchased
    */
    'sku': string;
    /**
    * ID of the user making the purchase. If null, currently logged in user will be used.
    */
    'userId': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sku",
            "baseName": "sku",
            "type": "string"
        },
        {
            "name": "userId",
            "baseName": "user_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return QuickBuyRequest.attributeTypeMap;
    }
}

export class RawEmailResource {
    /**
    * The body of the outgoing message.
    */
    'body': string;
    /**
    * Address to attribute the outgoing message to. Optional if the config email.out_address is set.
    */
    'from': string;
    /**
    * Whether the body is to be treated as html. Default false.
    */
    'html': boolean;
    /**
    * A list of user ids to send the message to.
    */
    'recipients': Array<number>;
    /**
    * The subject of the outgoing message.
    */
    'subject': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "from",
            "baseName": "from",
            "type": "string"
        },
        {
            "name": "html",
            "baseName": "html",
            "type": "boolean"
        },
        {
            "name": "recipients",
            "baseName": "recipients",
            "type": "Array<number>"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RawEmailResource.attributeTypeMap;
    }
}

export class RawSMSResource {
    /**
    * The phone number to attribute the outgoing message to. Optional if the config text.out_number is set.
    */
    'from': string;
    /**
    * A list of user ids to send the message to.
    */
    'recipients': Array<number>;
    /**
    * The body of the outgoing text message.
    */
    'text': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "from",
            "baseName": "from",
            "type": "string"
        },
        {
            "name": "recipients",
            "baseName": "recipients",
            "type": "Array<number>"
        },
        {
            "name": "text",
            "baseName": "text",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RawSMSResource.attributeTypeMap;
    }
}

export class ReactivateSubscriptionRequest {
    /**
    * The inventory to reactivate. Only required if using the deprecated subscriptions service
    */
    'inventoryId': number;
    /**
    * Whether to add the additional reactivation fee in addition to the recurring fee
    */
    'reactivationFee': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "inventoryId",
            "baseName": "inventory_id",
            "type": "number"
        },
        {
            "name": "reactivationFee",
            "baseName": "reactivation_fee",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ReactivateSubscriptionRequest.attributeTypeMap;
    }
}

export class RefundRequest {
    /**
    * The amount to refund. If left off, will refund the remaining balance of the transaction or specific item balance (if SKU provided), whichever is less.
    */
    'amount': number;
    /**
    * The SKU of a bundle item from the invoice that the target item is within.
    */
    'bundleSku': string;
    /**
    * Notes about or reason for the refund
    */
    'notes': string;
    /**
    * The SKU of a specific item from the invoice to refund. Affects the maximum refund amount (not to exceed the price of this item times quantity on invoice). Transaction must be tied to an invoice if used.
    */
    'sku': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "bundleSku",
            "baseName": "bundle_sku",
            "type": "string"
        },
        {
            "name": "notes",
            "baseName": "notes",
            "type": "string"
        },
        {
            "name": "sku",
            "baseName": "sku",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RefundRequest.attributeTypeMap;
    }
}

export class RefundResource {
    /**
    * The amount refunded
    */
    'amount': number;
    /**
    * The id of the refund transaction
    */
    'refundTransactionId': number;
    /**
    * The id of the original transaction
    */
    'transactionId': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "refundTransactionId",
            "baseName": "refund_transaction_id",
            "type": "number"
        },
        {
            "name": "transactionId",
            "baseName": "transaction_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RefundResource.attributeTypeMap;
    }
}

export class Result {
    /**
    * The JSAPI error code
    */
    'code': number;
    /**
    * The id used for debugging lookup
    */
    'requestId': string;
    /**
    * The error object
    */
    'result': Array<ErrorResource>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "requestId",
            "baseName": "request_id",
            "type": "string"
        },
        {
            "name": "result",
            "baseName": "result",
            "type": "Array<ErrorResource>"
        }    ];

    static getAttributeTypeMap() {
        return Result.attributeTypeMap;
    }
}

export class RevenueCountryReportResource {
    'country': string;
    'revenue': number;
    'volume': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "revenue",
            "baseName": "revenue",
            "type": "number"
        },
        {
            "name": "volume",
            "baseName": "volume",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RevenueCountryReportResource.attributeTypeMap;
    }
}

export class RevenueProductReportResource {
    'itemId': number;
    'itemName': string;
    'revenue': number;
    'volume': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "itemId",
            "baseName": "item_id",
            "type": "number"
        },
        {
            "name": "itemName",
            "baseName": "item_name",
            "type": "string"
        },
        {
            "name": "revenue",
            "baseName": "revenue",
            "type": "number"
        },
        {
            "name": "volume",
            "baseName": "volume",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RevenueProductReportResource.attributeTypeMap;
    }
}

export class RevenueReportResource {
    'customerCount': number;
    'saleCount': number;
    'salesAverage': number;
    'salesTotal': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "customerCount",
            "baseName": "customer_count",
            "type": "number"
        },
        {
            "name": "saleCount",
            "baseName": "sale_count",
            "type": "number"
        },
        {
            "name": "salesAverage",
            "baseName": "sales_average",
            "type": "number"
        },
        {
            "name": "salesTotal",
            "baseName": "sales_total",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RevenueReportResource.attributeTypeMap;
    }
}

export class RewardCurrencyResource {
    /**
    * The code of the currency type to give
    */
    'currencyCode': string;
    /**
    * The name of the currency reward to give.  Set by currency_code)
    */
    'currencyName': string;
    /**
    * The highest number (worst) rank to give the reward to. Must be greater than or equal to minRank
    */
    'maxRank': number;
    /**
    * The lowest number (best) rank to give the reward to. Must be greater than zero
    */
    'minRank': number;
    /**
    * True if the value is actually a percentage of the intake
    */
    'percent': boolean;
    /**
    * The amount of currency to give. For percentage values, 0.5 is 50%
    */
    'value': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "currencyName",
            "baseName": "currency_name",
            "type": "string"
        },
        {
            "name": "maxRank",
            "baseName": "max_rank",
            "type": "number"
        },
        {
            "name": "minRank",
            "baseName": "min_rank",
            "type": "number"
        },
        {
            "name": "percent",
            "baseName": "percent",
            "type": "boolean"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RewardCurrencyResource.attributeTypeMap;
    }
}

export class RewardItemResource {
    /**
    * The id of the item to reward
    */
    'itemId': number;
    /**
    * The name of the item to reward (read only, set by id)
    */
    'itemName': string;
    /**
    * The highest number (worst) rank to give the reward to. Must be greater than or equal to minRank
    */
    'maxRank': number;
    /**
    * The lowest number (best) rank to give the reward to. Must be greater than zero
    */
    'minRank': number;
    /**
    * How many copies to give
    */
    'quantity': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "itemId",
            "baseName": "item_id",
            "type": "number"
        },
        {
            "name": "itemName",
            "baseName": "item_name",
            "type": "string"
        },
        {
            "name": "maxRank",
            "baseName": "max_rank",
            "type": "number"
        },
        {
            "name": "minRank",
            "baseName": "min_rank",
            "type": "number"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RewardItemResource.attributeTypeMap;
    }
}

export class RewardSetResource {
    /**
    * The date/time this resource was created in seconds since unix epoch
    */
    'createdDate': number;
    /**
    * The currency to give as rewards
    */
    'currencyRewards': Array<RewardCurrencyResource>;
    /**
    * The assigned unique ID for this reward set
    */
    'id': number;
    /**
    * The items to give as rewards
    */
    'itemRewards': Array<RewardItemResource>;
    /**
    * A longer describe the reward set, usually included in details
    */
    'longDescription': string;
    /**
    * The maximum placing that will receive a reward
    */
    'maxPlacing': number;
    /**
    * The user friendly name for this reward set
    */
    'name': string;
    /**
    * A short paragraph to describe the reward set, usually included in listings.  Max 255 characters
    */
    'shortDescription': string;
    /**
    * A provided unique key for this reward set
    */
    'uniqueKey': string;
    /**
    * The date/time this resource was last updated in seconds since unix epoch
    */
    'updatedDate': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdDate",
            "baseName": "created_date",
            "type": "number"
        },
        {
            "name": "currencyRewards",
            "baseName": "currency_rewards",
            "type": "Array<RewardCurrencyResource>"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "itemRewards",
            "baseName": "item_rewards",
            "type": "Array<RewardItemResource>"
        },
        {
            "name": "longDescription",
            "baseName": "long_description",
            "type": "string"
        },
        {
            "name": "maxPlacing",
            "baseName": "max_placing",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "shortDescription",
            "baseName": "short_description",
            "type": "string"
        },
        {
            "name": "uniqueKey",
            "baseName": "unique_key",
            "type": "string"
        },
        {
            "name": "updatedDate",
            "baseName": "updated_date",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RewardSetResource.attributeTypeMap;
    }
}

export class RoleResource {
    /**
    * The number of clients this role is assigned to
    */
    'clientCount': number;
    /**
    * The date the role was added. Unix timestamp in seconds
    */
    'createdDate': number;
    /**
    * Whether a role is locked from being deleted
    */
    'locked': boolean;
    /**
    * The name of the role used for display purposes
    */
    'name': string;
    /**
    * The keyword that defines the role
    */
    'role': string;
    /**
    * The list of permissions this role has
    */
    'rolePermission': Array<PermissionResource>;
    /**
    * The number of users this role is assigned to
    */
    'userCount': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientCount",
            "baseName": "client_count",
            "type": "number"
        },
        {
            "name": "createdDate",
            "baseName": "created_date",
            "type": "number"
        },
        {
            "name": "locked",
            "baseName": "locked",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "string"
        },
        {
            "name": "rolePermission",
            "baseName": "role_permission",
            "type": "Array<PermissionResource>"
        },
        {
            "name": "userCount",
            "baseName": "user_count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RoleResource.attributeTypeMap;
    }
}

export class S3Config {
    'bucketName': string;
    'cdnUrl': string;
    'region': string;
    'uploadPrefix': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "bucketName",
            "baseName": "bucket_name",
            "type": "string"
        },
        {
            "name": "cdnUrl",
            "baseName": "cdn_url",
            "type": "string"
        },
        {
            "name": "region",
            "baseName": "region",
            "type": "string"
        },
        {
            "name": "uploadPrefix",
            "baseName": "upload_prefix",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return S3Config.attributeTypeMap;
    }
}

export class SampleCountriesResponse {
    'vendorId1': Array<Country>;
    'vendorId2': Array<Country>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "vendorId1",
            "baseName": "vendor_id1",
            "type": "Array<Country>"
        },
        {
            "name": "vendorId2",
            "baseName": "vendor_id2",
            "type": "Array<Country>"
        }    ];

    static getAttributeTypeMap() {
        return SampleCountriesResponse.attributeTypeMap;
    }
}

export class SavedAddressResource {
    /**
    * The first line of the address
    */
    'address1': string;
    /**
    * A second line of the address
    */
    'address2': string;
    /**
    * The city
    */
    'city': string;
    /**
    * The iso3 code for the country
    */
    'countryCode': string;
    'default': boolean;
    /**
    * The first name of the user
    */
    'firstName': string;
    /**
    * The id of the address
    */
    'id': number;
    /**
    * The last name of the user
    */
    'lastName': string;
    /**
    * The name of the address
    */
    'name': string;
    /**
    * The first phone number of the user
    */
    'phone1': string;
    /**
    * The second phone number of the user
    */
    'phone2': string;
    /**
    * The postal code
    */
    'postalCode': string;
    /**
    * The code for the state. Required if the country has states/provinces/equivalent
    */
    'stateCode': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "countryCode",
            "baseName": "country_code",
            "type": "string"
        },
        {
            "name": "default",
            "baseName": "default",
            "type": "boolean"
        },
        {
            "name": "firstName",
            "baseName": "first_name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "lastName",
            "baseName": "last_name",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "phone1",
            "baseName": "phone1",
            "type": "string"
        },
        {
            "name": "phone2",
            "baseName": "phone2",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postal_code",
            "type": "string"
        },
        {
            "name": "stateCode",
            "baseName": "state_code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SavedAddressResource.attributeTypeMap;
    }
}

export class Schedule {
    /**
    * The duration of the repeatable events
    */
    'duration': number;
    /**
    * The unit of time for the duration field
    */
    'durationUnit': Schedule.DurationUnitEnum;
    /**
    * How often the event is scheduled
    */
    'repeat': Schedule.RepeatEnum;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "duration",
            "baseName": "duration",
            "type": "number"
        },
        {
            "name": "durationUnit",
            "baseName": "duration_unit",
            "type": "Schedule.DurationUnitEnum"
        },
        {
            "name": "repeat",
            "baseName": "repeat",
            "type": "Schedule.RepeatEnum"
        }    ];

    static getAttributeTypeMap() {
        return Schedule.attributeTypeMap;
    }
}

export namespace Schedule {
    export enum DurationUnitEnum {
        Millisecond = <any> 'millisecond',
        Second = <any> 'second',
        Minute = <any> 'minute',
        Hour = <any> 'hour',
        Day = <any> 'day',
        Week = <any> 'week',
        Month = <any> 'month',
        Year = <any> 'year'
    }
    export enum RepeatEnum {
        DAILY = <any> 'DAILY',
        WEEKLY = <any> 'WEEKLY'
    }
}
export class SearchReferenceMapping {
    /**
    * Unique identifier for the mapping to protect against duplicates
    */
    'id': string;
    /**
    * The field within the type that contains the id from the refType
    */
    'refIdField': string;
    /**
    * The index type that the mapping pulls data from
    */
    'refType': string;
    /**
    * A map whose keys are the field names in the refType and values are the field name in the type
    */
    'sourceFieldToDestinationField': { [key: string]: string; };
    /**
    * The index type that the mapping is for
    */
    'type': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "refIdField",
            "baseName": "ref_id_field",
            "type": "string"
        },
        {
            "name": "refType",
            "baseName": "ref_type",
            "type": "string"
        },
        {
            "name": "sourceFieldToDestinationField",
            "baseName": "source_field_to_destination_field",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SearchReferenceMapping.attributeTypeMap;
    }
}

export class SelectedSettingResource {
    /**
    * The unique ID for the setting
    */
    'key': string;
    /**
    * The textual name of the setting
    */
    'keyName': string;
    /**
    * The unique ID for the option. Must match one of the options from this setting in the activity, if not part of a challenge
    */
    'value': string;
    /**
    * The textual name of the option
    */
    'valueName': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "keyName",
            "baseName": "key_name",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "valueName",
            "baseName": "value_name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SelectedSettingResource.attributeTypeMap;
    }
}

export class SettingOption {
    /**
    * The textual name of the option: Ex: Hard (level 10)
    */
    'name': string;
    /**
    * The unique ID for the option. Ex: 10
    */
    'value': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SettingOption.attributeTypeMap;
    }
}

export class SimpleReferenceResourceint {
    /**
    * The id of the referenced object
    */
    'id': number;
    /**
    * The name of the referenced object
    */
    'name': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SimpleReferenceResourceint.attributeTypeMap;
    }
}

export class SimpleReferenceResourcelong {
    /**
    * The id of the referenced object
    */
    'id': number;
    /**
    * The name of the referenced object
    */
    'name': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SimpleReferenceResourcelong.attributeTypeMap;
    }
}

export class SimpleReferenceResourceobject {
    /**
    * The id of the referenced object
    */
    'id': any;
    /**
    * The name of the referenced object
    */
    'name': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "any"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SimpleReferenceResourceobject.attributeTypeMap;
    }
}

export class SimpleReferenceResourcestring {
    /**
    * The id of the referenced object
    */
    'id': string;
    /**
    * The name of the referenced object
    */
    'name': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SimpleReferenceResourcestring.attributeTypeMap;
    }
}

export class SimpleUserResource {
    /**
    * The url of the user's avatar image
    */
    'avatarUrl': string;
    /**
    * The public username of the user
    */
    'displayName': string;
    /**
    * The id of the user
    */
    'id': number;
    /**
    * The username of the user
    */
    'username': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "avatarUrl",
            "baseName": "avatar_url",
            "type": "string"
        },
        {
            "name": "displayName",
            "baseName": "display_name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SimpleUserResource.attributeTypeMap;
    }
}

export class SimpleWallet {
    /**
    * The current balance of the wallet
    */
    'balance': number;
    /**
    * The ISO currency code for the wallet
    */
    'code': string;
    /**
    * The name of the currency stored in the wallet
    */
    'currencyName': string;
    /**
    * The unique ID of the wallet
    */
    'id': number;
    /**
    * The ID of the user to whom the wallet belongs
    */
    'userId': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "balance",
            "baseName": "balance",
            "type": "number"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "currencyName",
            "baseName": "currency_name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "userId",
            "baseName": "user_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return SimpleWallet.attributeTypeMap;
    }
}

export class Sku {
    /**
    * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type, or be an extra not from the template
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * The currency code for the SKU, a three letter string (ISO3)
    */
    'currencyCode': string;
    /**
    * The friendly name of the SKU as it will appear on invoices and reports. Typically represents the option name like red, large, etc
    */
    'description': string;
    /**
    * The number of SKUs currently in stock
    */
    'inventory': number;
    /**
    * Alerts vendor when SKU inventory drops below this value
    */
    'minInventoryThreshold': number;
    /**
    * The base price before any sale
    */
    'originalPrice': number;
    /**
    * The current price of the SKU with sales, if any. Set original_price for the base
    */
    'price': number;
    /**
    * Whether or not the SKU is currently published
    */
    'published': boolean;
    /**
    * The id of a sale affecting the price, if any
    */
    'saleId': number;
    /**
    * The name of a sale affecting the price, if any
    */
    'saleName': string;
    /**
    * The stock keeping unit (SKU), a unique identifier for a given product.  Max 40 characters
    */
    'sku': string;
    /**
    * The date the sku becomes available, unix timestamp in seconds.  If set to null, sku will become available immediately
    */
    'startDate': number;
    /**
    * The date the sku becomes unavailable, unix timestamp in seconds.  If set to null, sku is always available
    */
    'stopDate': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "additionalProperties",
            "baseName": "additional_properties",
            "type": "{ [key: string]: Property; }"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "inventory",
            "baseName": "inventory",
            "type": "number"
        },
        {
            "name": "minInventoryThreshold",
            "baseName": "min_inventory_threshold",
            "type": "number"
        },
        {
            "name": "originalPrice",
            "baseName": "original_price",
            "type": "number"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "published",
            "baseName": "published",
            "type": "boolean"
        },
        {
            "name": "saleId",
            "baseName": "sale_id",
            "type": "number"
        },
        {
            "name": "saleName",
            "baseName": "sale_name",
            "type": "string"
        },
        {
            "name": "sku",
            "baseName": "sku",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "number"
        },
        {
            "name": "stopDate",
            "baseName": "stop_date",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Sku.attributeTypeMap;
    }
}

export class SkuRequest {
    /**
    * SKU code of the item
    */
    'sku': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sku",
            "baseName": "sku",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SkuRequest.attributeTypeMap;
    }
}

export class SqlDatabaseConfig {
    'connectionPoolSize': number;
    'dbName': string;
    'hostname': string;
    'password': string;
    'port': number;
    'username': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "connectionPoolSize",
            "baseName": "connection_pool_size",
            "type": "number"
        },
        {
            "name": "dbName",
            "baseName": "db_name",
            "type": "string"
        },
        {
            "name": "hostname",
            "baseName": "hostname",
            "type": "string"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        },
        {
            "name": "port",
            "baseName": "port",
            "type": "number"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SqlDatabaseConfig.attributeTypeMap;
    }
}

export class StateResource {
    /**
    * The code of the state
    */
    'code': string;
    /**
    * The iso3 of the country this state is in
    */
    'countryCodeIso3': string;
    /**
    * The unique ID for the state
    */
    'id': number;
    /**
    * The name of the state
    */
    'name': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "countryCodeIso3",
            "baseName": "country_code_iso3",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StateResource.attributeTypeMap;
    }
}

export class StateTaxResource {
    /**
    * The iso3 code of the country, cannot be changed
    */
    'countryIso3': string;
    /**
    * Whether the state is exempt from paying the country tax
    */
    'federallyExempt': boolean;
    /**
    * The name of the tax
    */
    'name': string;
    /**
    * The tax rate as a percentage to a maximum of two decimal places (1.5 means 1.5%)
    */
    'rate': number;
    /**
    * The code of the state, cannot be changed
    */
    'stateCode': string;
    /**
    * Whether the tax applies to shipping costs
    */
    'taxShipping': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "countryIso3",
            "baseName": "country_iso3",
            "type": "string"
        },
        {
            "name": "federallyExempt",
            "baseName": "federally_exempt",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "rate",
            "baseName": "rate",
            "type": "number"
        },
        {
            "name": "stateCode",
            "baseName": "state_code",
            "type": "string"
        },
        {
            "name": "taxShipping",
            "baseName": "tax_shipping",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return StateTaxResource.attributeTypeMap;
    }
}

export class StoreItemTemplateResource {
    /**
    * The customized behaviors that are required or default for this type of item
    */
    'behaviors': Array<ItemBehaviorDefinitionResource>;
    /**
    * The date/time this resource was created in seconds since unix epoch
    */
    'createdDate': number;
    /**
    * The id of the template
    */
    'id': string;
    /**
    * The name of the template
    */
    'name': string;
    /**
    * The customized properties that are present
    */
    'properties': Array<PropertyDefinitionResource>;
    /**
    * A template to apply to all skus on an item using this template
    */
    'skuTemplate': TemplateResource;
    /**
    * The date/time this resource was last updated in seconds since unix epoch
    */
    'updatedDate': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "behaviors",
            "baseName": "behaviors",
            "type": "Array<ItemBehaviorDefinitionResource>"
        },
        {
            "name": "createdDate",
            "baseName": "created_date",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "properties",
            "baseName": "properties",
            "type": "Array<PropertyDefinitionResource>"
        },
        {
            "name": "skuTemplate",
            "baseName": "sku_template",
            "type": "TemplateResource"
        },
        {
            "name": "updatedDate",
            "baseName": "updated_date",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StoreItemTemplateResource.attributeTypeMap;
    }
}

export class StringOperationResource {
    'args': Array<ExpressionResource>;
    'op': string;
    'type': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "args",
            "baseName": "args",
            "type": "Array<ExpressionResource>"
        },
        {
            "name": "op",
            "baseName": "op",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StringOperationResource.attributeTypeMap;
    }
}

export class StringWrapper {
    'value': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StringWrapper.attributeTypeMap;
    }
}

export class StripeCreatePaymentMethod {
    /**
    * Additional optional details to store on the payment method. If included, all fields in the details will override any defaults
    */
    'details': PaymentMethodDetails;
    /**
    * A token from Stripe to identify payment info to be tied to the customer
    */
    'token': string;
    /**
    * The id of the user, if null the logged in user is used. Admin privilege need to specify other users
    */
    'userId': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "details",
            "baseName": "details",
            "type": "PaymentMethodDetails"
        },
        {
            "name": "token",
            "baseName": "token",
            "type": "string"
        },
        {
            "name": "userId",
            "baseName": "user_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StripeCreatePaymentMethod.attributeTypeMap;
    }
}

export class StripePaymentRequest {
    /**
    * The id of the invoice to pay
    */
    'invoiceId': number;
    /**
    * A token from Stripe to identify payment info to be tied to the customer
    */
    'token': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "invoiceId",
            "baseName": "invoice_id",
            "type": "number"
        },
        {
            "name": "token",
            "baseName": "token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StripePaymentRequest.attributeTypeMap;
    }
}

export class SubscriptionCreditResource {
    /**
    * The amount of the credit, negative for debt
    */
    'amount': number;
    /**
    * The date this credit was added, unix timestamp in seconds
    */
    'createdDate': number;
    /**
    * The id of the credit record
    */
    'id': number;
    /**
    * The id of the subscription inventory entry
    */
    'inventoryId': number;
    /**
    * The reason for the subscription credit
    */
    'reason': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "createdDate",
            "baseName": "created_date",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "inventoryId",
            "baseName": "inventory_id",
            "type": "number"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SubscriptionCreditResource.attributeTypeMap;
    }
}

export class SubscriptionPlan {
    'additionalProperties': { [key: string]: Property; };
    'availability': SubscriptionPlan.AvailabilityEnum;
    'billGraceDays': number;
    'consolidated': boolean;
    'firstBill': number;
    'firstBillUnitOfTime': SubscriptionPlan.FirstBillUnitOfTimeEnum;
    'id': string;
    'latePaymentSku': string;
    'locked': boolean;
    'maxAutoRenew': number;
    'maxBillAttempts': number;
    'migrationPlan': string;
    'minimumTerm': number;
    'name': string;
    'primarySku': string;
    'reactivationSku': string;
    'recurringSku': string;
    'renewPeriod': number;
    'renewPeriodUnitOfTime': SubscriptionPlan.RenewPeriodUnitOfTimeEnum;
    'subscriptionId': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "additionalProperties",
            "baseName": "additional_properties",
            "type": "{ [key: string]: Property; }"
        },
        {
            "name": "availability",
            "baseName": "availability",
            "type": "SubscriptionPlan.AvailabilityEnum"
        },
        {
            "name": "billGraceDays",
            "baseName": "bill_grace_days",
            "type": "number"
        },
        {
            "name": "consolidated",
            "baseName": "consolidated",
            "type": "boolean"
        },
        {
            "name": "firstBill",
            "baseName": "first_bill",
            "type": "number"
        },
        {
            "name": "firstBillUnitOfTime",
            "baseName": "first_bill_unit_of_time",
            "type": "SubscriptionPlan.FirstBillUnitOfTimeEnum"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "latePaymentSku",
            "baseName": "late_payment_sku",
            "type": "string"
        },
        {
            "name": "locked",
            "baseName": "locked",
            "type": "boolean"
        },
        {
            "name": "maxAutoRenew",
            "baseName": "max_auto_renew",
            "type": "number"
        },
        {
            "name": "maxBillAttempts",
            "baseName": "max_bill_attempts",
            "type": "number"
        },
        {
            "name": "migrationPlan",
            "baseName": "migration_plan",
            "type": "string"
        },
        {
            "name": "minimumTerm",
            "baseName": "minimum_term",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "primarySku",
            "baseName": "primary_sku",
            "type": "string"
        },
        {
            "name": "reactivationSku",
            "baseName": "reactivation_sku",
            "type": "string"
        },
        {
            "name": "recurringSku",
            "baseName": "recurring_sku",
            "type": "string"
        },
        {
            "name": "renewPeriod",
            "baseName": "renew_period",
            "type": "number"
        },
        {
            "name": "renewPeriodUnitOfTime",
            "baseName": "renew_period_unit_of_time",
            "type": "SubscriptionPlan.RenewPeriodUnitOfTimeEnum"
        },
        {
            "name": "subscriptionId",
            "baseName": "subscription_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return SubscriptionPlan.attributeTypeMap;
    }
}

export namespace SubscriptionPlan {
    export enum AvailabilityEnum {
        All = <any> 'all',
        NewSubscribers = <any> 'new_subscribers'
    }
    export enum FirstBillUnitOfTimeEnum {
        Millisecond = <any> 'millisecond',
        Second = <any> 'second',
        Minute = <any> 'minute',
        Hour = <any> 'hour',
        Day = <any> 'day',
        Week = <any> 'week',
        Month = <any> 'month',
        Year = <any> 'year'
    }
    export enum RenewPeriodUnitOfTimeEnum {
        Millisecond = <any> 'millisecond',
        Second = <any> 'second',
        Minute = <any> 'minute',
        Hour = <any> 'hour',
        Day = <any> 'day',
        Week = <any> 'week',
        Month = <any> 'month',
        Year = <any> 'year'
    }
}
export class SubscriptionPlanResource {
    /**
    * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this subscription
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * The length of the billing cycle in number of billing cycle unit
    */
    'billingCycleLength': number;
    /**
    * The time period unit to apply to the length of billing cycles
    */
    'billingCycleUnit': SubscriptionPlanResource.BillingCycleUnitEnum;
    /**
    * Whether this plan will be renewed on the consolidated billing cycle
    */
    'consolidated': boolean;
    /**
    * The ISO3 currency code to use for the fees
    */
    'currencyCode': string;
    /**
    * Used to schedule plan availability end date
    */
    'endDate': number;
    /**
    * Optional override for the length of the first billing cycle before the first recurring billing
    */
    'firstBillingCycleLength': number;
    /**
    * The time period unit to apply to the length of the first billing cycle. Required when first_billing_cycle_length is specified
    */
    'firstBillingCycleUnit': SubscriptionPlanResource.FirstBillingCycleUnitEnum;
    /**
    * The number of late payment days before a subscription is canceled
    */
    'gracePeriod': number;
    /**
    * The id of the plan used to generate the SKUs
    */
    'id': string;
    /**
    * The fee charged when the subscription is purchased
    */
    'initialFee': number;
    /**
    * The SKU to be used when purchasing the subscription through the cart
    */
    'initialSku': string;
    /**
    * The fee to add to the bill when an invoice has gone unpaid passed the grace period
    */
    'latePaymentFee': number;
    /**
    * The SKU that will show on the invoice when the subscription is delinquent
    */
    'latePaymentSku': string;
    /**
    * Whether this plan is locked because it has been purchased by at least one user.  When locked, a number of properties can no longer be changed
    */
    'locked': boolean;
    /**
    * The number of charge attempts before the subscription becomes delinquent
    */
    'maxBillAttempts': number;
    /**
    * Maximum number of renewals. If a migration plan is provided, the subscription will automatically switch to it when this limit is reached
    */
    'maxCycles': number;
    /**
    * Automatically migrate to the specified plan when the subscription is first renewed
    */
    'migrateToPlan': string;
    /**
    * The minimum number of renewals to charge for
    */
    'minCycles': number;
    /**
    * The name of the plan used to generate the SKUs
    */
    'name': string;
    /**
    * Whether this plan is currently available
    */
    'published': boolean;
    /**
    * The fee to charge when a suspended subscription is to be re-activated
    */
    'reactivationFee': number;
    /**
    * The SKU that will show on the invoice when the subscription is re-activated after a suspension
    */
    'reactivationSku': string;
    /**
    * The recurring fee to charge for each renewal
    */
    'recurringFee': number;
    /**
    * The SKU that will show on the invoice when the subscription is activated
    */
    'recurringSku': string;
    /**
    * Used to schedule plan availability start date
    */
    'startDate': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "additionalProperties",
            "baseName": "additional_properties",
            "type": "{ [key: string]: Property; }"
        },
        {
            "name": "billingCycleLength",
            "baseName": "billing_cycle_length",
            "type": "number"
        },
        {
            "name": "billingCycleUnit",
            "baseName": "billing_cycle_unit",
            "type": "SubscriptionPlanResource.BillingCycleUnitEnum"
        },
        {
            "name": "consolidated",
            "baseName": "consolidated",
            "type": "boolean"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "endDate",
            "baseName": "end_date",
            "type": "number"
        },
        {
            "name": "firstBillingCycleLength",
            "baseName": "first_billing_cycle_length",
            "type": "number"
        },
        {
            "name": "firstBillingCycleUnit",
            "baseName": "first_billing_cycle_unit",
            "type": "SubscriptionPlanResource.FirstBillingCycleUnitEnum"
        },
        {
            "name": "gracePeriod",
            "baseName": "grace_period",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "initialFee",
            "baseName": "initial_fee",
            "type": "number"
        },
        {
            "name": "initialSku",
            "baseName": "initial_sku",
            "type": "string"
        },
        {
            "name": "latePaymentFee",
            "baseName": "late_payment_fee",
            "type": "number"
        },
        {
            "name": "latePaymentSku",
            "baseName": "late_payment_sku",
            "type": "string"
        },
        {
            "name": "locked",
            "baseName": "locked",
            "type": "boolean"
        },
        {
            "name": "maxBillAttempts",
            "baseName": "max_bill_attempts",
            "type": "number"
        },
        {
            "name": "maxCycles",
            "baseName": "max_cycles",
            "type": "number"
        },
        {
            "name": "migrateToPlan",
            "baseName": "migrate_to_plan",
            "type": "string"
        },
        {
            "name": "minCycles",
            "baseName": "min_cycles",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "published",
            "baseName": "published",
            "type": "boolean"
        },
        {
            "name": "reactivationFee",
            "baseName": "reactivation_fee",
            "type": "number"
        },
        {
            "name": "reactivationSku",
            "baseName": "reactivation_sku",
            "type": "string"
        },
        {
            "name": "recurringFee",
            "baseName": "recurring_fee",
            "type": "number"
        },
        {
            "name": "recurringSku",
            "baseName": "recurring_sku",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return SubscriptionPlanResource.attributeTypeMap;
    }
}

export namespace SubscriptionPlanResource {
    export enum BillingCycleUnitEnum {
        Millisecond = <any> 'millisecond',
        Second = <any> 'second',
        Minute = <any> 'minute',
        Hour = <any> 'hour',
        Day = <any> 'day',
        Week = <any> 'week',
        Month = <any> 'month',
        Year = <any> 'year'
    }
    export enum FirstBillingCycleUnitEnum {
        Millisecond = <any> 'millisecond',
        Second = <any> 'second',
        Minute = <any> 'minute',
        Hour = <any> 'hour',
        Day = <any> 'day',
        Week = <any> 'week',
        Month = <any> 'month',
        Year = <any> 'year'
    }
}
export class SubscriptionPriceOverrideRequest {
    /**
    * The recurring price that has been set to override the base price. Null if not overriding
    */
    'newPrice': number;
    /**
    * An explanation for the reason the price is being overridden
    */
    'reason': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "newPrice",
            "baseName": "new_price",
            "type": "number"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SubscriptionPriceOverrideRequest.attributeTypeMap;
    }
}

export class SubscriptionResource {
    /**
    * A map of item additional properties, keyed on the property name. Must match the names and types defined in the template for this item type.
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * Who can purchase this subscription
    */
    'availability': SubscriptionResource.AvailabilityEnum;
    /**
    * A category for filtering items
    */
    'category': string;
    /**
    * The day of the month 1..31 this subscription will renew
    */
    'consolidationDayOfMonth': number;
    /**
    * The date the item was created, unix timestamp in seconds
    */
    'createdDate': number;
    /**
    * A list of country iso3 codes to include in the blacklist/whitelist geo policy
    */
    'geoCountryList': Array<string>;
    /**
    * Whether to use the geo_country_list as a black list or white list for item geographical availability
    */
    'geoPolicyType': SubscriptionResource.GeoPolicyTypeEnum;
    /**
    * The id of the item
    */
    'id': number;
    /**
    * A long description of the subscription
    */
    'longDescription': string;
    /**
    * The name of the item
    */
    'name': string;
    /**
    * The billing options for this subscription
    */
    'plans': Array<SubscriptionPlanResource>;
    /**
    * A short description of the subscription.  Max 255 characters
    */
    'shortDescription': string;
    /**
    * A number to use in sorting items.  Default 500
    */
    'sort': number;
    /**
    * Used to schedule removal from store.  Null means the subscription will never be removed
    */
    'storeEnd': number;
    /**
    * Used to schedule appearance in store.  Null means the subscription will appear now
    */
    'storeStart': number;
    /**
    * List of tags used for filtering items
    */
    'tags': Array<string>;
    /**
    * An item template this item is validated against. May be null and no validation of additional properties will be done.
    */
    'template': string;
    /**
    * The unique key for the item
    */
    'uniqueKey': string;
    /**
    * The date the item was last updated
    */
    'updatedDate': number;
    /**
    * The vendor who provides the item
    */
    'vendorId': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "additionalProperties",
            "baseName": "additional_properties",
            "type": "{ [key: string]: Property; }"
        },
        {
            "name": "availability",
            "baseName": "availability",
            "type": "SubscriptionResource.AvailabilityEnum"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "string"
        },
        {
            "name": "consolidationDayOfMonth",
            "baseName": "consolidation_day_of_month",
            "type": "number"
        },
        {
            "name": "createdDate",
            "baseName": "created_date",
            "type": "number"
        },
        {
            "name": "geoCountryList",
            "baseName": "geo_country_list",
            "type": "Array<string>"
        },
        {
            "name": "geoPolicyType",
            "baseName": "geo_policy_type",
            "type": "SubscriptionResource.GeoPolicyTypeEnum"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "longDescription",
            "baseName": "long_description",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "plans",
            "baseName": "plans",
            "type": "Array<SubscriptionPlanResource>"
        },
        {
            "name": "shortDescription",
            "baseName": "short_description",
            "type": "string"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "number"
        },
        {
            "name": "storeEnd",
            "baseName": "store_end",
            "type": "number"
        },
        {
            "name": "storeStart",
            "baseName": "store_start",
            "type": "number"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "template",
            "baseName": "template",
            "type": "string"
        },
        {
            "name": "uniqueKey",
            "baseName": "unique_key",
            "type": "string"
        },
        {
            "name": "updatedDate",
            "baseName": "updated_date",
            "type": "number"
        },
        {
            "name": "vendorId",
            "baseName": "vendor_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return SubscriptionResource.attributeTypeMap;
    }
}

export namespace SubscriptionResource {
    export enum AvailabilityEnum {
        All = <any> 'all',
        NewSubscribers = <any> 'new_subscribers'
    }
    export enum GeoPolicyTypeEnum {
        Whitelist = <any> 'whitelist',
        Blacklist = <any> 'blacklist'
    }
}
export class SubscriptionTemplateResource {
    /**
    * The date/time this resource was created in seconds since unix epoch
    */
    'createdDate': number;
    /**
    * The id of the template
    */
    'id': string;
    /**
    * The name of the template
    */
    'name': string;
    /**
    * A template to apply to all plans on a subscription using this template
    */
    'planTemplate': TemplateResource;
    /**
    * The customized properties that are present
    */
    'properties': Array<PropertyDefinitionResource>;
    /**
    * The date/time this resource was last updated in seconds since unix epoch
    */
    'updatedDate': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdDate",
            "baseName": "created_date",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "planTemplate",
            "baseName": "plan_template",
            "type": "TemplateResource"
        },
        {
            "name": "properties",
            "baseName": "properties",
            "type": "Array<PropertyDefinitionResource>"
        },
        {
            "name": "updatedDate",
            "baseName": "updated_date",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return SubscriptionTemplateResource.attributeTypeMap;
    }
}

export class TemplateEmailResource {
    /**
    * Address to attribute the outgoing message to. Optional if the config email.out_address is set.
    */
    'from': string;
    /**
    * A list of user ids to send the message to.
    */
    'recipients': Array<number>;
    /**
    * The key for the template
    */
    'templateKey': string;
    /**
    * A list of variables to fill in the template
    */
    'templateVars': Array<KeyValuePairstringstring>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "from",
            "baseName": "from",
            "type": "string"
        },
        {
            "name": "recipients",
            "baseName": "recipients",
            "type": "Array<number>"
        },
        {
            "name": "templateKey",
            "baseName": "template_key",
            "type": "string"
        },
        {
            "name": "templateVars",
            "baseName": "template_vars",
            "type": "Array<KeyValuePairstringstring>"
        }    ];

    static getAttributeTypeMap() {
        return TemplateEmailResource.attributeTypeMap;
    }
}

export class TemplateResource {
    /**
    * The date/time this resource was created in seconds since unix epoch
    */
    'createdDate': number;
    /**
    * The id of the template
    */
    'id': string;
    /**
    * The name of the template
    */
    'name': string;
    /**
    * The customized properties that are present
    */
    'properties': Array<PropertyDefinitionResource>;
    /**
    * The date/time this resource was last updated in seconds since unix epoch
    */
    'updatedDate': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdDate",
            "baseName": "created_date",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "properties",
            "baseName": "properties",
            "type": "Array<PropertyDefinitionResource>"
        },
        {
            "name": "updatedDate",
            "baseName": "updated_date",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TemplateResource.attributeTypeMap;
    }
}

export class TemplateSMSResource {
    /**
    * The phone number to attribute the outgoing message to. Optional if the config text.out_number is set.
    */
    'from': string;
    'localizer': Localizer;
    /**
    * A list of user ids to send the message to.
    */
    'recipients': Array<number>;
    /**
    * The key for the template.
    */
    'templateKey': string;
    /**
    * A list of values to fill in the template. Order matters.
    */
    'templateVars': Array<string>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "from",
            "baseName": "from",
            "type": "string"
        },
        {
            "name": "localizer",
            "baseName": "localizer",
            "type": "Localizer"
        },
        {
            "name": "recipients",
            "baseName": "recipients",
            "type": "Array<number>"
        },
        {
            "name": "templateKey",
            "baseName": "template_key",
            "type": "string"
        },
        {
            "name": "templateVars",
            "baseName": "template_vars",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return TemplateSMSResource.attributeTypeMap;
    }
}

export class TierResource {
    /**
    * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * The name of the tier
    */
    'name': string;
    /**
    * The required progress for the tier
    */
    'requiredProgress': number;
    /**
    * The name of the triggered event
    */
    'triggerEventName': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "additionalProperties",
            "baseName": "additional_properties",
            "type": "{ [key: string]: Property; }"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "requiredProgress",
            "baseName": "required_progress",
            "type": "number"
        },
        {
            "name": "triggerEventName",
            "baseName": "trigger_event_name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TierResource.attributeTypeMap;
    }
}

export class TokenDetailsResource {
    'clientId': string;
    'roles': Array<string>;
    'userId': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientId",
            "baseName": "client_id",
            "type": "string"
        },
        {
            "name": "roles",
            "baseName": "roles",
            "type": "Array<string>"
        },
        {
            "name": "userId",
            "baseName": "user_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TokenDetailsResource.attributeTypeMap;
    }
}

export class TransactionResource {
    /**
    * The unix timestamp in seconds of the transaction
    */
    'createDate': number;
    /**
    * The code of the currency for the transaction
    */
    'currencyCode': string;
    /**
    * The specific details of the transaction, such as a message from the admin that created it
    */
    'details': string;
    /**
    * The id of the transaction
    */
    'id': number;
    /**
    * The id of the invoice that spawned the transaction, if any
    */
    'invoiceId': number;
    /**
    * Whether the transaction has been refunded
    */
    'isRefunded': boolean;
    /**
    * The response
    */
    'response': string;
    /**
    * The root source of the transaction
    */
    'source': TransactionResource.SourceEnum;
    /**
    * If the transaction was successful
    */
    'successful': boolean;
    /**
    * The payment gateway (external) transaction ID
    */
    'transactionId': string;
    /**
    * The general type of the transaction
    */
    'type': string;
    /**
    * The table name of the subclass
    */
    'typeHint': string;
    /**
    * The amount of the transaction, positive if a gain, negative if an expenditure
    */
    'value': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createDate",
            "baseName": "create_date",
            "type": "number"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "invoiceId",
            "baseName": "invoice_id",
            "type": "number"
        },
        {
            "name": "isRefunded",
            "baseName": "is_refunded",
            "type": "boolean"
        },
        {
            "name": "response",
            "baseName": "response",
            "type": "string"
        },
        {
            "name": "source",
            "baseName": "source",
            "type": "TransactionResource.SourceEnum"
        },
        {
            "name": "successful",
            "baseName": "successful",
            "type": "boolean"
        },
        {
            "name": "transactionId",
            "baseName": "transaction_id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "typeHint",
            "baseName": "type_hint",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TransactionResource.attributeTypeMap;
    }
}

export namespace TransactionResource {
    export enum SourceEnum {
        Digital = <any> 'digital',
        Physical = <any> 'physical'
    }
}
export class TypeHintLookupResource {
    'lookupKey': ExpressionResource;
    'type': string;
    'valueType': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "lookupKey",
            "baseName": "lookup_key",
            "type": "ExpressionResource"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "valueType",
            "baseName": "value_type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TypeHintLookupResource.attributeTypeMap;
    }
}

export class UsageInfo {
    /**
    * The number of requests within the range
    */
    'count': number;
    /**
    * The date at the start of the range (see granularity)
    */
    'date': number;
    /**
    * The http method
    */
    'method': string;
    /**
    * The url path
    */
    'url': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "number"
        },
        {
            "name": "method",
            "baseName": "method",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UsageInfo.attributeTypeMap;
    }
}

export class UserAchievementGroupResource {
    /**
    * The list of achievements associated with the group
    */
    'achievements': Array<UserAchievementResource>;
    /**
    * The name of the group.  If used by Leveling, this will represent the level name
    */
    'groupName': string;
    /**
    * The id of the achievement progress
    */
    'id': string;
    /**
    * The current progress of the user on the group
    */
    'progress': number;
    /**
    * The id of the user whose progress is being tracked
    */
    'userId': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "achievements",
            "baseName": "achievements",
            "type": "Array<UserAchievementResource>"
        },
        {
            "name": "groupName",
            "baseName": "group_name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "progress",
            "baseName": "progress",
            "type": "number"
        },
        {
            "name": "userId",
            "baseName": "user_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return UserAchievementGroupResource.attributeTypeMap;
    }
}

export class UserAchievementResource {
    /**
    * Flag indicating whether the user has earned the achievement
    */
    'achieved': boolean;
    /**
    * The achievement being tracked.  If used for Leveling, this represents the tier name
    */
    'achievementName': string;
    /**
    * The date/time this resource was created in seconds since unix epoch
    */
    'createdDate': number;
    /**
    * The date/time the achievement was earned as a unix timestamp in seconds
    */
    'earnedDate': number;
    /**
    * The date/time this resource was last updated in seconds since unix epoch
    */
    'updatedDate': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "achieved",
            "baseName": "achieved",
            "type": "boolean"
        },
        {
            "name": "achievementName",
            "baseName": "achievement_name",
            "type": "string"
        },
        {
            "name": "createdDate",
            "baseName": "created_date",
            "type": "number"
        },
        {
            "name": "earnedDate",
            "baseName": "earned_date",
            "type": "number"
        },
        {
            "name": "updatedDate",
            "baseName": "updated_date",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return UserAchievementResource.attributeTypeMap;
    }
}

export class UserActionLog {
    /**
    * A description of the action taken
    */
    'actionDescription': string;
    /**
    * The name of the action taken
    */
    'actionName': string;
    /**
    * The date of the action, unix timestamp in seconds
    */
    'createdDate': number;
    /**
    * A map of additional details such as the target of the action
    */
    'details': { [key: string]: string; };
    /**
    * The id of the log entry
    */
    'id': string;
    /**
    * The id of the api request that spawned the action, if generated internally
    */
    'requestId': string;
    /**
    * The id of the user that took the action, if any. Read-only if not posting with LOGS_ADMIN
    */
    'userId': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "actionDescription",
            "baseName": "action_description",
            "type": "string"
        },
        {
            "name": "actionName",
            "baseName": "action_name",
            "type": "string"
        },
        {
            "name": "createdDate",
            "baseName": "created_date",
            "type": "number"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "requestId",
            "baseName": "request_id",
            "type": "string"
        },
        {
            "name": "userId",
            "baseName": "user_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return UserActionLog.attributeTypeMap;
    }
}

export class UserActivityResults {
    /**
    * Any currency rewarded to this user
    */
    'currencyRewards': Array<RewardCurrencyResource>;
    /**
    * Any items rewarded to this user
    */
    'itemRewards': Array<RewardItemResource>;
    /**
    * The position of the user in the leaderboard. Null means non-compete or disqualification
    */
    'rank': number;
    /**
    * The raw score in this leaderboard. Null means non-compete or disqualification
    */
    'score': number;
    /**
    * Any tags for the metric. Each unique tag will translate into a unique leaderboard. Maximum 5 tags and 50 characters each
    */
    'tags': Array<string>;
    /**
    * The number of users tied at this rank, including this user. 1 means no tie
    */
    'ties': number;
    /**
    * The date this score was recorded or updated. Unix timestamp in seconds
    */
    'updatedDate': number;
    /**
    * The player for this entry
    */
    'user': SimpleUserResource;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currencyRewards",
            "baseName": "currency_rewards",
            "type": "Array<RewardCurrencyResource>"
        },
        {
            "name": "itemRewards",
            "baseName": "item_rewards",
            "type": "Array<RewardItemResource>"
        },
        {
            "name": "rank",
            "baseName": "rank",
            "type": "number"
        },
        {
            "name": "score",
            "baseName": "score",
            "type": "number"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "ties",
            "baseName": "ties",
            "type": "number"
        },
        {
            "name": "updatedDate",
            "baseName": "updated_date",
            "type": "number"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "SimpleUserResource"
        }    ];

    static getAttributeTypeMap() {
        return UserActivityResults.attributeTypeMap;
    }
}

export class UserActivityResultsResource {
    /**
    * The raw score. Null means non-compete or disqualification
    */
    'score': number;
    /**
    * Any tags for the metric. Each unique tag will translate into a unique leaderboard. Maximum 5 tags and 50 characters each
    */
    'tags': Array<string>;
    /**
    * The id of the player
    */
    'userId': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "score",
            "baseName": "score",
            "type": "number"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "userId",
            "baseName": "user_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return UserActivityResultsResource.attributeTypeMap;
    }
}

export class UserBaseResource {
    /**
    * The url of the user's avatar image
    */
    'avatarUrl': string;
    /**
    * The chosen display name of the user, defaults to username if not present
    */
    'displayName': string;
    /**
    * The user's email address (private). May be required and/or unique depending on system configuration (both on by default). Must match standard email requirements if provided (RFC 2822)
    */
    'email': string;
    /**
    * The user's full name (private)
    */
    'fullname': string;
    /**
    * The id of the user
    */
    'id': number;
    /**
    * The date the user last interacted with the API (private)
    */
    'lastActivity': number;
    /**
    * The date the user's info was last updated as a unix timestamp
    */
    'lastUpdated': number;
    /**
    * The user's date of registration as a unix timestamp
    */
    'memberSince': number;
    /**
    * The login username for the user (private). May be set to match email if system does not require usernames separately.
    */
    'username': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "avatarUrl",
            "baseName": "avatar_url",
            "type": "string"
        },
        {
            "name": "displayName",
            "baseName": "display_name",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "fullname",
            "baseName": "fullname",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "lastActivity",
            "baseName": "last_activity",
            "type": "number"
        },
        {
            "name": "lastUpdated",
            "baseName": "last_updated",
            "type": "number"
        },
        {
            "name": "memberSince",
            "baseName": "member_since",
            "type": "number"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserBaseResource.attributeTypeMap;
    }
}

export class UserInventoryAddRequest {
    /**
    * A note to be passed to the invoice or transaction
    */
    'note': string;
    /**
    * A list of behaviors to ignore explicitely.  Ex: 'limited_gettable'
    */
    'overrides': Array<string>;
    /**
    * If set to true will cause the endpoint to skip creation of cart and invoice to track the inventory change
    */
    'skipInvoice': boolean;
    /**
    * The specific SKU of the item to be added to the inventory
    */
    'sku': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "note",
            "baseName": "note",
            "type": "string"
        },
        {
            "name": "overrides",
            "baseName": "overrides",
            "type": "Array<string>"
        },
        {
            "name": "skipInvoice",
            "baseName": "skip_invoice",
            "type": "boolean"
        },
        {
            "name": "sku",
            "baseName": "sku",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserInventoryAddRequest.attributeTypeMap;
    }
}

export class UserInventoryResource {
    /**
    * A map of data for behaviors
    */
    'behaviorData': any;
    /**
    * The date/time this resource was created in seconds since epoch
    */
    'createdDate': number;
    /**
    * The date/time this resource exires in seconds since epoch. Null for no expiration. For subscriptions, this is the end of the 'grace period' if left unpaid
    */
    'expires': number;
    /**
    * The id of the inventory
    */
    'id': number;
    /**
    * The id of the invoice that resulted in this inventory, if any
    */
    'invoiceId': number;
    /**
    * The id of the item
    */
    'itemId': number;
    /**
    * The name of the item
    */
    'itemName': string;
    /**
    * The type hint of the item
    */
    'itemTypeHint': string;
    /**
    * The status of the inventory. Pending inventory is not yet ready for use. Inactive inventory has expired or been used up
    */
    'status': UserInventoryResource.StatusEnum;
    /**
    * The date/time this resource was last updated in seconds since epoch
    */
    'updatedDate': number;
    /**
    * The id of the user this inventory belongs to
    */
    'user': SimpleUserResource;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "behaviorData",
            "baseName": "behavior_data",
            "type": "any"
        },
        {
            "name": "createdDate",
            "baseName": "created_date",
            "type": "number"
        },
        {
            "name": "expires",
            "baseName": "expires",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "invoiceId",
            "baseName": "invoice_id",
            "type": "number"
        },
        {
            "name": "itemId",
            "baseName": "item_id",
            "type": "number"
        },
        {
            "name": "itemName",
            "baseName": "item_name",
            "type": "string"
        },
        {
            "name": "itemTypeHint",
            "baseName": "item_type_hint",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "UserInventoryResource.StatusEnum"
        },
        {
            "name": "updatedDate",
            "baseName": "updated_date",
            "type": "number"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "SimpleUserResource"
        }    ];

    static getAttributeTypeMap() {
        return UserInventoryResource.attributeTypeMap;
    }
}

export namespace UserInventoryResource {
    export enum StatusEnum {
        Pending = <any> 'pending',
        Active = <any> 'active',
        Inactive = <any> 'inactive'
    }
}
export class UserItemLogResource {
    /**
    * The log entry id
    */
    'id': number;
    /**
    * Additional information defined by the type
    */
    'info': string;
    /**
    * The item interacted with
    */
    'item': SimpleReferenceResourceint;
    /**
    * The date/time this event occurred in seconds since epoch
    */
    'logDate': number;
    /**
    * The type of event
    */
    'type': string;
    /**
    * The user making the interaction
    */
    'user': SimpleUserResource;
    /**
    * The id of the inventory entry this event is related to, if any
    */
    'userInventory': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "info",
            "baseName": "info",
            "type": "string"
        },
        {
            "name": "item",
            "baseName": "item",
            "type": "SimpleReferenceResourceint"
        },
        {
            "name": "logDate",
            "baseName": "log_date",
            "type": "number"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "SimpleUserResource"
        },
        {
            "name": "userInventory",
            "baseName": "user_inventory",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return UserItemLogResource.attributeTypeMap;
    }
}

export class UserLevelingResource {
    /**
    * The name of the last tier the user has qualified for
    */
    'lastTierName': string;
    /**
    * The progress level of the last tier the user has qualified for
    */
    'lastTierProgress': number;
    /**
    * The name of the level schema
    */
    'levelName': string;
    /**
    * The name of the next tier the user can qualify for
    */
    'nextTierName': string;
    /**
    * The progress needed to qualify for the next tier
    */
    'nextTierProgress': number;
    /**
    * The amount of progress the user has
    */
    'progress': number;
    /**
    * The names of the tiers the user has qualified for
    */
    'tierNames': Array<string>;
    /**
    * The ID of the user
    */
    'userId': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "lastTierName",
            "baseName": "last_tier_name",
            "type": "string"
        },
        {
            "name": "lastTierProgress",
            "baseName": "last_tier_progress",
            "type": "number"
        },
        {
            "name": "levelName",
            "baseName": "level_name",
            "type": "string"
        },
        {
            "name": "nextTierName",
            "baseName": "next_tier_name",
            "type": "string"
        },
        {
            "name": "nextTierProgress",
            "baseName": "next_tier_progress",
            "type": "number"
        },
        {
            "name": "progress",
            "baseName": "progress",
            "type": "number"
        },
        {
            "name": "tierNames",
            "baseName": "tier_names",
            "type": "Array<string>"
        },
        {
            "name": "userId",
            "baseName": "user_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return UserLevelingResource.attributeTypeMap;
    }
}

export class UserRelationshipReferenceResource {
    /**
    * The url of the user's avatar image
    */
    'avatarUrl': string;
    /**
    * The context of the relationship
    */
    'context': string;
    /**
    * The public username of the user
    */
    'displayName': string;
    /**
    * The id of the user
    */
    'id': number;
    /**
    * The id of the relationship
    */
    'relationshipId': number;
    /**
    * The username of the user
    */
    'username': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "avatarUrl",
            "baseName": "avatar_url",
            "type": "string"
        },
        {
            "name": "context",
            "baseName": "context",
            "type": "string"
        },
        {
            "name": "displayName",
            "baseName": "display_name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "relationshipId",
            "baseName": "relationship_id",
            "type": "number"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserRelationshipReferenceResource.attributeTypeMap;
    }
}

export class UserRelationshipResource {
    /**
    * The child in the relationship
    */
    'child': SimpleUserResource;
    /**
    * Context about the relationship or its type
    */
    'context': string;
    /**
    * A generated unique id. Read-Only
    */
    'id': number;
    /**
    * The parent in the relationship
    */
    'parent': SimpleUserResource;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "child",
            "baseName": "child",
            "type": "SimpleUserResource"
        },
        {
            "name": "context",
            "baseName": "context",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "parent",
            "baseName": "parent",
            "type": "SimpleUserResource"
        }    ];

    static getAttributeTypeMap() {
        return UserRelationshipResource.attributeTypeMap;
    }
}

export class UserResource {
    /**
    * A map of additional properties, keyed on the property name (private). Must match the names and types defined in the template for this user type, or be an extra not from the template
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * The first line of the user's address (private)
    */
    'address': string;
    /**
    * The second line of user's address (private)
    */
    'address2': string;
    /**
    * The url of the user's avatar image
    */
    'avatarUrl': string;
    /**
    * Relationships where this user is the parent. Read-Only, manage through separate endpoints
    */
    'children': Array<UserRelationshipReferenceResource>;
    /**
    * The user's city (private)
    */
    'city': string;
    /**
    * The ISO3 code for the country from the user's address (private). Will be filled in based on GeoIP country at registration if not provided.
    */
    'countryCode': string;
    /**
    * The code for the user's real money currency (private)
    */
    'currencyCode': string;
    /**
    * The user's date of birth (private) as a unix timestamp
    */
    'dateOfBirth': number;
    /**
    * The user's self description (private)
    */
    'description': string;
    /**
    * The chosen display name of the user, defaults to username if not present
    */
    'displayName': string;
    /**
    * The user's email address (private). May be required and/or unique depending on system configuration (both on by default). Must match standard email requirements if provided (RFC 2822)
    */
    'email': string;
    /**
    * The user's first name (private)
    */
    'firstName': string;
    /**
    * The user's full name (private)
    */
    'fullname': string;
    /**
    * The user's gender (private)
    */
    'gender': string;
    /**
    * The id of the user
    */
    'id': number;
    /**
    * The ISO3 code for the user's currency (private)
    */
    'languageCode': string;
    /**
    * The date the user last interacted with the API (private)
    */
    'lastActivity': number;
    /**
    * The user's last name (private)
    */
    'lastName': string;
    /**
    * The date the user's info was last updated as a unix timestamp
    */
    'lastUpdated': number;
    /**
    * The user's date of registration as a unix timestamp
    */
    'memberSince': number;
    /**
    * The user's mobile phone number (private)
    */
    'mobileNumber': string;
    /**
    * Relationships where this user is the child. Read-Only, manage through separate endpoints
    */
    'parents': Array<UserRelationshipReferenceResource>;
    /**
    * The plain text password for the new user account. Required for registration; ignored on profile update.  Use password specific endpoints for editing
    */
    'password': string;
    /**
    * The user's postal code (private)
    */
    'postalCode': string;
    /**
    * The user's state (private)
    */
    'state': string;
    /**
    * Tags on the user. Can only be set by admin. Max length per tag is 64 characters
    */
    'tags': Array<string>;
    /**
    * A user template this user is validated against (private). May be null and no validation of properties will be done
    */
    'template': string;
    /**
    * The code for the user's timezone (private)
    */
    'timezoneCode': string;
    /**
    * The login username for the user (private). May be set to match email if system does not require usernames separately.
    */
    'username': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "additionalProperties",
            "baseName": "additional_properties",
            "type": "{ [key: string]: Property; }"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "avatarUrl",
            "baseName": "avatar_url",
            "type": "string"
        },
        {
            "name": "children",
            "baseName": "children",
            "type": "Array<UserRelationshipReferenceResource>"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "countryCode",
            "baseName": "country_code",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "dateOfBirth",
            "baseName": "date_of_birth",
            "type": "number"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "displayName",
            "baseName": "display_name",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "first_name",
            "type": "string"
        },
        {
            "name": "fullname",
            "baseName": "fullname",
            "type": "string"
        },
        {
            "name": "gender",
            "baseName": "gender",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "languageCode",
            "baseName": "language_code",
            "type": "string"
        },
        {
            "name": "lastActivity",
            "baseName": "last_activity",
            "type": "number"
        },
        {
            "name": "lastName",
            "baseName": "last_name",
            "type": "string"
        },
        {
            "name": "lastUpdated",
            "baseName": "last_updated",
            "type": "number"
        },
        {
            "name": "memberSince",
            "baseName": "member_since",
            "type": "number"
        },
        {
            "name": "mobileNumber",
            "baseName": "mobile_number",
            "type": "string"
        },
        {
            "name": "parents",
            "baseName": "parents",
            "type": "Array<UserRelationshipReferenceResource>"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postal_code",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "template",
            "baseName": "template",
            "type": "string"
        },
        {
            "name": "timezoneCode",
            "baseName": "timezone_code",
            "type": "string"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserResource.attributeTypeMap;
    }
}

export class UsernameLookupResource {
    'lookupKey': ExpressionResource;
    'type': string;
    'valueType': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "lookupKey",
            "baseName": "lookup_key",
            "type": "ExpressionResource"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "valueType",
            "baseName": "value_type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UsernameLookupResource.attributeTypeMap;
    }
}

export class VariableTypeResource {
    /**
    * The base class of the type
    */
    'base': VariableTypeResource.BaseEnum;
    /**
    * Whether the type comes from a set of valid values that the system can provided (such as users)
    */
    'enumerable': boolean;
    /**
    * The name of the variable type. Used as the unique id
    */
    'name': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "base",
            "baseName": "base",
            "type": "VariableTypeResource.BaseEnum"
        },
        {
            "name": "enumerable",
            "baseName": "enumerable",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return VariableTypeResource.attributeTypeMap;
    }
}

export namespace VariableTypeResource {
    export enum BaseEnum {
        NUMBER = <any> 'NUMBER',
        INTEGER = <any> 'INTEGER',
        STRING = <any> 'STRING',
        DATE = <any> 'DATE',
        BOOLEAN = <any> 'BOOLEAN'
    }
}
export class VendorEmailLookupResource {
    'lookupKey': ExpressionResource;
    'type': string;
    'valueType': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "lookupKey",
            "baseName": "lookup_key",
            "type": "ExpressionResource"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "valueType",
            "baseName": "value_type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return VendorEmailLookupResource.attributeTypeMap;
    }
}

export class VendorResource {
    /**
    * Whether the vendor is active.  Default = true
    */
    'active': boolean;
    /**
    * A map of additional properties, keyed on the property name (private). Must match the names and types defined in the template for this user type, or be an extra not from the template
    */
    'additionalProperties': { [key: string]: Property; };
    /**
    * The date the vendor was added. Unix timestamp in seconds
    */
    'createDate': number;
    /**
    * A description of the vendor
    */
    'description': string;
    /**
    * The id of the vendor
    */
    'id': number;
    /**
    * The url of an image for the vendor
    */
    'imageUrl': string;
    /**
    * Whether the vendor needs to manually approve invoices before they are paid.  A separate checkout flow is required in this case.  Default: false
    */
    'manualApproval': boolean;
    /**
    * The name of the vendor
    */
    'name': string;
    /**
    * The primary email address for the vendor
    */
    'primaryContactEmail': string;
    /**
    * The name of the primary contact for the vendor
    */
    'primaryContactName': string;
    /**
    * The primary phone number for the vendor
    */
    'primaryContactPhone': string;
    /**
    * The email address for sale inquiries for the vendor
    */
    'salesEmail': string;
    /**
    * The email address for support inquiries for the vendor
    */
    'supportEmail': string;
    /**
    * A user template this user is validated against (private). May be null and no validation of properties will be done
    */
    'template': string;
    /**
    * The date the vendor was last updated. Unix timestamp in seconds
    */
    'updateDate': number;
    /**
    * The url for the vendor's site
    */
    'url': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "additionalProperties",
            "baseName": "additional_properties",
            "type": "{ [key: string]: Property; }"
        },
        {
            "name": "createDate",
            "baseName": "create_date",
            "type": "number"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "imageUrl",
            "baseName": "image_url",
            "type": "string"
        },
        {
            "name": "manualApproval",
            "baseName": "manual_approval",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "primaryContactEmail",
            "baseName": "primary_contact_email",
            "type": "string"
        },
        {
            "name": "primaryContactName",
            "baseName": "primary_contact_name",
            "type": "string"
        },
        {
            "name": "primaryContactPhone",
            "baseName": "primary_contact_phone",
            "type": "string"
        },
        {
            "name": "salesEmail",
            "baseName": "sales_email",
            "type": "string"
        },
        {
            "name": "supportEmail",
            "baseName": "support_email",
            "type": "string"
        },
        {
            "name": "template",
            "baseName": "template",
            "type": "string"
        },
        {
            "name": "updateDate",
            "baseName": "update_date",
            "type": "number"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return VendorResource.attributeTypeMap;
    }
}

export class Version {
    'version': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "version",
            "baseName": "version",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Version.attributeTypeMap;
    }
}

export class VideoRelationshipResource {
    /**
    * The owner of the relationship
    */
    'from': SimpleReferenceResourcelong;
    /**
    * The id of the relationship
    */
    'id': number;
    /**
    * Details about the relationship such as type or other information. Max length 10 characters
    */
    'relationshipDetails': string;
    /**
    * The target of the relationship.
    */
    'to': SimpleReferenceResourcelong;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "from",
            "baseName": "from",
            "type": "SimpleReferenceResourcelong"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "relationshipDetails",
            "baseName": "relationship_details",
            "type": "string"
        },
        {
            "name": "to",
            "baseName": "to",
            "type": "SimpleReferenceResourcelong"
        }    ];

    static getAttributeTypeMap() {
        return VideoRelationshipResource.attributeTypeMap;
    }
}

export class VideoResource {
    /**
    * Whether the video is available, based on various factors
    */
    'active': boolean;
    /**
    * The original artist of the media
    */
    'author': SimpleReferenceResourcelong;
    /**
    * The date the media was created as a unix timestamp in seconds
    */
    'authored': number;
    /**
    * Whether the video has been banned or not
    */
    'banned': boolean;
    /**
    * The category of the video
    */
    'category': SimpleReferenceResourcestring;
    /**
    * The comments of the video
    */
    'comments': Array<CommentResource>;
    /**
    * Artists that contributed to the creation. See separate endpoint to add to list
    */
    'contributors': Array<ContributionResource>;
    /**
    * The date/time this resource was created in seconds since unix epoch
    */
    'createdDate': number;
    /**
    * The country of an embedable version
    */
    'embed': string;
    /**
    * The file extension of the media file. 1-5 characters
    */
    'extension': string;
    /**
    * The height of the video in px
    */
    'height': number;
    /**
    * The unique ID for that resource
    */
    'id': number;
    /**
    * The length of the video in seconds
    */
    'length': number;
    /**
    * The country of the media. Typically a url. Cannot be blank
    */
    'location': string;
    /**
    * The user friendly name of that resource. Defaults to blank string
    */
    'longDescription': string;
    /**
    * The mime-type of the media
    */
    'mimeType': string;
    /**
    * The user friendly name of that resource
    */
    'name': string;
    /**
    * The sort order of the video. default: 100
    */
    'priority': number;
    /**
    * The privacy setting. default: private
    */
    'privacy': VideoResource.PrivacyEnum;
    /**
    * Whether the video has been made public. Default true
    */
    'published': boolean;
    /**
    * The user friendly name of that resource. Defaults to blank string
    */
    'shortDescription': string;
    /**
    * The size of the media. Minimum 0 if supplied
    */
    'size': number;
    /**
    * The tags for the video
    */
    'tags': Array<string>;
    /**
    * The country of a thumbnail version. Typically a url
    */
    'thumbnail': string;
    /**
    * The date/time this resource was last updated in seconds since unix epoch
    */
    'updatedDate': number;
    /**
    * The user the media was uploaded by. May be null for system uploaded media. May only be set to a user other than the current caller if VIDEOS_ADMIN permission. Null will mean the caller is the uploader unless the caller has VIDEOS_ADMIN permission, in which case it will be set to null
    */
    'uploader': SimpleUserResource;
    /**
    * The view count of the video
    */
    'views': number;
    /**
    * The width of the video in px
    */
    'width': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "author",
            "baseName": "author",
            "type": "SimpleReferenceResourcelong"
        },
        {
            "name": "authored",
            "baseName": "authored",
            "type": "number"
        },
        {
            "name": "banned",
            "baseName": "banned",
            "type": "boolean"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "SimpleReferenceResourcestring"
        },
        {
            "name": "comments",
            "baseName": "comments",
            "type": "Array<CommentResource>"
        },
        {
            "name": "contributors",
            "baseName": "contributors",
            "type": "Array<ContributionResource>"
        },
        {
            "name": "createdDate",
            "baseName": "created_date",
            "type": "number"
        },
        {
            "name": "embed",
            "baseName": "embed",
            "type": "string"
        },
        {
            "name": "extension",
            "baseName": "extension",
            "type": "string"
        },
        {
            "name": "height",
            "baseName": "height",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "length",
            "baseName": "length",
            "type": "number"
        },
        {
            "name": "location",
            "baseName": "location",
            "type": "string"
        },
        {
            "name": "longDescription",
            "baseName": "long_description",
            "type": "string"
        },
        {
            "name": "mimeType",
            "baseName": "mime_type",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "priority",
            "baseName": "priority",
            "type": "number"
        },
        {
            "name": "privacy",
            "baseName": "privacy",
            "type": "VideoResource.PrivacyEnum"
        },
        {
            "name": "published",
            "baseName": "published",
            "type": "boolean"
        },
        {
            "name": "shortDescription",
            "baseName": "short_description",
            "type": "string"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "thumbnail",
            "baseName": "thumbnail",
            "type": "string"
        },
        {
            "name": "updatedDate",
            "baseName": "updated_date",
            "type": "number"
        },
        {
            "name": "uploader",
            "baseName": "uploader",
            "type": "SimpleUserResource"
        },
        {
            "name": "views",
            "baseName": "views",
            "type": "number"
        },
        {
            "name": "width",
            "baseName": "width",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return VideoResource.attributeTypeMap;
    }
}

export namespace VideoResource {
    export enum PrivacyEnum {
        Private = <any> 'private',
        Friends = <any> 'friends',
        Public = <any> 'public'
    }
}
export class WalletAlterRequest {
    /**
    * The amount of currency to add/remove. positive to add, negative to remove
    */
    'delta': number;
    /**
    * The id of an invoice to attribute the transaction to
    */
    'invoiceId': number;
    /**
    * The admin entered or system generated reason
    */
    'reason': string;
    /**
    * The transaction type to allow for search/etc
    */
    'type': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "delta",
            "baseName": "delta",
            "type": "number"
        },
        {
            "name": "invoiceId",
            "baseName": "invoice_id",
            "type": "number"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WalletAlterRequest.attributeTypeMap;
    }
}

export class WalletTotalResponse {
    /**
    * The currency code
    */
    'currencyCode': string;
    /**
    * The sum of all wallets in the system for this currency
    */
    'total': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return WalletTotalResponse.attributeTypeMap;
    }
}

export class WalletTransactionResource {
    /**
    * The new balance of the wallet after the transaction
    */
    'balance': number;
    /**
    * The unix timestamp in seconds of the transaction
    */
    'createDate': number;
    /**
    * The code of the currency for the transaction
    */
    'currencyCode': string;
    /**
    * The specific details of the transaction, such as a message from the admin that created it
    */
    'details': string;
    /**
    * The id of the transaction
    */
    'id': number;
    /**
    * The id of the invoice that spawned the transaction, if any
    */
    'invoiceId': number;
    /**
    * Whether the transaction has been refunded
    */
    'isRefunded': boolean;
    /**
    * The response
    */
    'response': string;
    /**
    * The root source of the transaction
    */
    'source': WalletTransactionResource.SourceEnum;
    /**
    * If the transaction was successful
    */
    'successful': boolean;
    /**
    * The payment gateway (external) transaction ID
    */
    'transactionId': string;
    /**
    * The general type of the transaction
    */
    'type': string;
    /**
    * The table name of the subclass
    */
    'typeHint': string;
    /**
    * The owner of the wallet
    */
    'user': SimpleUserResource;
    /**
    * The amount of the transaction, positive if a gain, negative if an expenditure
    */
    'value': number;
    /**
    * The id of the wallet this transaction affected
    */
    'walletId': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "balance",
            "baseName": "balance",
            "type": "number"
        },
        {
            "name": "createDate",
            "baseName": "create_date",
            "type": "number"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "invoiceId",
            "baseName": "invoice_id",
            "type": "number"
        },
        {
            "name": "isRefunded",
            "baseName": "is_refunded",
            "type": "boolean"
        },
        {
            "name": "response",
            "baseName": "response",
            "type": "string"
        },
        {
            "name": "source",
            "baseName": "source",
            "type": "WalletTransactionResource.SourceEnum"
        },
        {
            "name": "successful",
            "baseName": "successful",
            "type": "boolean"
        },
        {
            "name": "transactionId",
            "baseName": "transaction_id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "typeHint",
            "baseName": "type_hint",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "SimpleUserResource"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        },
        {
            "name": "walletId",
            "baseName": "wallet_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return WalletTransactionResource.attributeTypeMap;
    }
}

export namespace WalletTransactionResource {
    export enum SourceEnum {
        Digital = <any> 'digital',
        Physical = <any> 'physical'
    }
}
export class XsollaPaymentRequest {
    /**
    * The id of an invoice to pay
    */
    'invoiceId': number;
    /**
    * The endpoint URL xsolla should forward the user to after they pay
    */
    'returnUrl': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "invoiceId",
            "baseName": "invoice_id",
            "type": "number"
        },
        {
            "name": "returnUrl",
            "baseName": "return_url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return XsollaPaymentRequest.attributeTypeMap;
    }
}

export class AudioPropertyDefinitionResource extends PropertyDefinitionResource {
    /**
    * If provided, a file type the property must match
    */
    'fileType': string;
    /**
    * If provided, the maximum length of the audio
    */
    'maxLength': number;
    /**
    * If provided, the minimum length of the audio
    */
    'minLength': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fileType",
            "baseName": "file_type",
            "type": "string"
        },
        {
            "name": "maxLength",
            "baseName": "max_length",
            "type": "number"
        },
        {
            "name": "minLength",
            "baseName": "min_length",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(AudioPropertyDefinitionResource.attributeTypeMap);
    }
}

export class BooleanProperty extends Property {
    /**
    * The value
    */
    'value': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "value",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(BooleanProperty.attributeTypeMap);
    }
}

export class BooleanPropertyDefinitionResource extends PropertyDefinitionResource {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(BooleanPropertyDefinitionResource.attributeTypeMap);
    }
}

export class CacheClearEvent extends BroadcastableEvent {
    'customerSetup': boolean;
    'customerTeardown': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "customerSetup",
            "baseName": "customer_setup",
            "type": "boolean"
        },
        {
            "name": "customerTeardown",
            "baseName": "customer_teardown",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CacheClearEvent.attributeTypeMap);
    }
}

export class Consumable extends Behavior {
    /**
    * The maximum number of times an item can be used
    */
    'maxUse': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "maxUse",
            "baseName": "max_use",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Consumable.attributeTypeMap);
    }
}

export class DateProperty extends Property {
    /**
    * The value
    */
    'value': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(DateProperty.attributeTypeMap);
    }
}

export class DatePropertyDefinitionResource extends PropertyDefinitionResource {
    /**
    * If provided, the maximum value
    */
    'max': number;
    /**
    * If provided, the minimum value
    */
    'min': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "max",
            "baseName": "max",
            "type": "number"
        },
        {
            "name": "min",
            "baseName": "min",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(DatePropertyDefinitionResource.attributeTypeMap);
    }
}

export class DoubleProperty extends Property {
    /**
    * The value
    */
    'value': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(DoubleProperty.attributeTypeMap);
    }
}

export class DoublePropertyDefinitionResource extends PropertyDefinitionResource {
    /**
    * If provided, the maximum value
    */
    'max': number;
    /**
    * If provided, the minimum value
    */
    'min': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "max",
            "baseName": "max",
            "type": "number"
        },
        {
            "name": "min",
            "baseName": "min",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(DoublePropertyDefinitionResource.attributeTypeMap);
    }
}

export class EntitlementItem extends Item {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(EntitlementItem.attributeTypeMap);
    }
}

export class Expirable extends Behavior {
    /**
    * The length of time
    */
    'timeLength': number;
    /**
    * The unit of time
    */
    'unitOfTime': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "timeLength",
            "baseName": "time_length",
            "type": "number"
        },
        {
            "name": "unitOfTime",
            "baseName": "unit_of_time",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Expirable.attributeTypeMap);
    }
}

export class FileGroupProperty extends Property {
    /**
    * The list of files
    */
    'files': Array<FileProperty>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "files",
            "baseName": "files",
            "type": "Array<FileProperty>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(FileGroupProperty.attributeTypeMap);
    }
}

export class FileGroupPropertyDefinitionResource extends PropertyDefinitionResource {
    /**
    * If provided, a file type that the property must match
    */
    'fileType': string;
    /**
    * If provided, the maximum number of files in the group
    */
    'maxCount': number;
    /**
    * If provided, the maximum allowed size per file in bytes
    */
    'maxFileSize': number;
    /**
    * If provided, the minimum number of files in the group
    */
    'minCount': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fileType",
            "baseName": "file_type",
            "type": "string"
        },
        {
            "name": "maxCount",
            "baseName": "max_count",
            "type": "number"
        },
        {
            "name": "maxFileSize",
            "baseName": "max_file_size",
            "type": "number"
        },
        {
            "name": "minCount",
            "baseName": "min_count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(FileGroupPropertyDefinitionResource.attributeTypeMap);
    }
}

export class FileProperty extends Property {
    /**
    * A crc value for file integrity verification
    */
    'crc': string;
    /**
    * A description of the file
    */
    'description': string;
    /**
    * The type of file such as txt, mp3, mov or csv
    */
    'fileType': string;
    /**
    * The url of the file
    */
    'url': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "crc",
            "baseName": "crc",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "fileType",
            "baseName": "file_type",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(FileProperty.attributeTypeMap);
    }
}

export class FilePropertyDefinitionResource extends PropertyDefinitionResource {
    /**
    * If provided, a file type that the property must match
    */
    'fileType': string;
    /**
    * If provided, the maximum allowed file size in bytes
    */
    'maxFileSize': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fileType",
            "baseName": "file_type",
            "type": "string"
        },
        {
            "name": "maxFileSize",
            "baseName": "max_file_size",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(FilePropertyDefinitionResource.attributeTypeMap);
    }
}

export class FormattedTextProperty extends Property {
    /**
    * The value
    */
    'value': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(FormattedTextProperty.attributeTypeMap);
    }
}

export class FormattedTextPropertyDefinitionResource extends PropertyDefinitionResource {
    /**
    * If provided, the maximum length of the text
    */
    'maxLength': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "maxLength",
            "baseName": "max_length",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(FormattedTextPropertyDefinitionResource.attributeTypeMap);
    }
}

export class Fulfillable extends Behavior {
    /**
    * The name of the fulfillment type that describes how the item should be fulfilled.  Examples: inventory, wallet, amazon
    */
    'typeName': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "typeName",
            "baseName": "type_name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Fulfillable.attributeTypeMap);
    }
}

export class GuestPlayable extends Behavior {
    /**
    * Whether guests are allowed to use items
    */
    'allowed': boolean;
    /**
    * Whether guests are allowed on the leaderboard
    */
    'leaderboard': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "allowed",
            "baseName": "allowed",
            "type": "boolean"
        },
        {
            "name": "leaderboard",
            "baseName": "leaderboard",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(GuestPlayable.attributeTypeMap);
    }
}

export class ImagePropertyDefinitionResource extends PropertyDefinitionResource {
    /**
    * If provided, a file type that the property must match
    */
    'fileType': string;
    /**
    * If provided, the maximum height of the image
    */
    'maxHeight': number;
    /**
    * If provided, the maximum width of the image
    */
    'maxWidth': number;
    /**
    * If provided, the minimum height of the image
    */
    'minHeight': number;
    /**
    * If provided, the minimum width of the image
    */
    'minWidth': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fileType",
            "baseName": "file_type",
            "type": "string"
        },
        {
            "name": "maxHeight",
            "baseName": "max_height",
            "type": "number"
        },
        {
            "name": "maxWidth",
            "baseName": "max_width",
            "type": "number"
        },
        {
            "name": "minHeight",
            "baseName": "min_height",
            "type": "number"
        },
        {
            "name": "minWidth",
            "baseName": "min_width",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ImagePropertyDefinitionResource.attributeTypeMap);
    }
}

export class IntegerProperty extends Property {
    /**
    * The value
    */
    'value': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(IntegerProperty.attributeTypeMap);
    }
}

export class IntegerPropertyDefinitionResource extends PropertyDefinitionResource {
    /**
    * If provided, the maximum value
    */
    'max': number;
    /**
    * If provided, the minimum value
    */
    'min': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "max",
            "baseName": "max",
            "type": "number"
        },
        {
            "name": "min",
            "baseName": "min",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(IntegerPropertyDefinitionResource.attributeTypeMap);
    }
}

export class LimitedGettable extends Behavior {
    'group': LimitedGettableGroup;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "group",
            "baseName": "group",
            "type": "LimitedGettableGroup"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(LimitedGettable.attributeTypeMap);
    }
}

export class LogLevelEvent extends BroadcastableEvent {
    'level': string;
    'name': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "level",
            "baseName": "level",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(LogLevelEvent.attributeTypeMap);
    }
}

export class LongProperty extends Property {
    /**
    * The value
    */
    'value': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(LongProperty.attributeTypeMap);
    }
}

export class LongPropertyDefinitionResource extends PropertyDefinitionResource {
    /**
    * If provided, the maximum value
    */
    'max': number;
    /**
    * If provided, the minimum value
    */
    'min': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "max",
            "baseName": "max",
            "type": "number"
        },
        {
            "name": "min",
            "baseName": "min",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(LongPropertyDefinitionResource.attributeTypeMap);
    }
}

export class NewCustomerEvent extends BroadcastableEvent {
    'customerConfig': CustomerConfig;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "customerConfig",
            "baseName": "customer_config",
            "type": "CustomerConfig"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(NewCustomerEvent.attributeTypeMap);
    }
}

export class PreReqEntitlement extends Behavior {
    /**
    * The item ids that must already be in the user's inventory
    */
    'itemIds': Array<number>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "itemIds",
            "baseName": "item_ids",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PreReqEntitlement.attributeTypeMap);
    }
}

export class PriceOverridable extends Behavior {
    /**
    * The maximum price allowed
    */
    'maxPrice': number;
    /**
    * The minimum price allowed
    */
    'minPrice': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "maxPrice",
            "baseName": "max_price",
            "type": "number"
        },
        {
            "name": "minPrice",
            "baseName": "min_price",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PriceOverridable.attributeTypeMap);
    }
}

export class RemoveCustomerEvent extends BroadcastableEvent {
    'customerConfig': CustomerConfig;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "customerConfig",
            "baseName": "customer_config",
            "type": "CustomerConfig"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(RemoveCustomerEvent.attributeTypeMap);
    }
}

export class Spendable extends Behavior {
    /**
    * The code of the currency
    */
    'currencyCode': string;
    /**
    * The spendable value
    */
    'value': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Spendable.attributeTypeMap);
    }
}

export class StoreItem extends Item {
    /**
    * Whether or not the item is currently displayable.  Default = true
    */
    'displayable': boolean;
    /**
    * A list of country ID to include in the blacklist/whitelist geo policy
    */
    'geoCountryList': Array<string>;
    /**
    * Whether to use the geo_country_list as a black list or white list for item geographical availability
    */
    'geoPolicyType': StoreItem.GeoPolicyTypeEnum;
    /**
    * Provides the abstract shipping needs if this item is physical and can be shipped.  A value of zero means no shipping needed.  Default = 0
    */
    'shippingTier': number;
    /**
    * The skus for the item. Each defines a unique configuration for the item to be purchased (Large-Blue, Small-Green, etc). These are what is ultimately selected in the store and added to the cart
    */
    'skus': Array<Sku>;
    /**
    * The date the item will leave the store, unix timestamp in seconds.  If set to null, item will never leave the store
    */
    'storeEnd': number;
    /**
    * The date the item will appear in the store, unix timestamp in seconds.  If set to null, item will appear in store immediately
    */
    'storeStart': number;
    /**
    * The vendor who provides the item
    */
    'vendorId': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "displayable",
            "baseName": "displayable",
            "type": "boolean"
        },
        {
            "name": "geoCountryList",
            "baseName": "geo_country_list",
            "type": "Array<string>"
        },
        {
            "name": "geoPolicyType",
            "baseName": "geo_policy_type",
            "type": "StoreItem.GeoPolicyTypeEnum"
        },
        {
            "name": "shippingTier",
            "baseName": "shipping_tier",
            "type": "number"
        },
        {
            "name": "skus",
            "baseName": "skus",
            "type": "Array<Sku>"
        },
        {
            "name": "storeEnd",
            "baseName": "store_end",
            "type": "number"
        },
        {
            "name": "storeStart",
            "baseName": "store_start",
            "type": "number"
        },
        {
            "name": "vendorId",
            "baseName": "vendor_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(StoreItem.attributeTypeMap);
    }
}

export namespace StoreItem {
    export enum GeoPolicyTypeEnum {
        Whitelist = <any> 'whitelist',
        Blacklist = <any> 'blacklist'
    }
}
export class TextProperty extends Property {
    /**
    * The value
    */
    'value': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TextProperty.attributeTypeMap);
    }
}

export class TextPropertyDefinitionResource extends PropertyDefinitionResource {
    /**
    * If provided, the maximum length of the text
    */
    'maxLength': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "maxLength",
            "baseName": "max_length",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TextPropertyDefinitionResource.attributeTypeMap);
    }
}

export class TimePeriodGettable extends Behavior {
    /**
    * The time period limit
    */
    'getLimit': number;
    /**
    * The name of a group of items. Multiple items with the same group name will be limited together, leave null to be assigned a random unique name. It is typical that the other properties here will be the same for all, but this is not enforced and the item being recieved will use its settings.
    */
    'groupName': string;
    /**
    * The length of time
    */
    'timeLength': number;
    /**
    * The unit of time
    */
    'unitOfTime': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "getLimit",
            "baseName": "get_limit",
            "type": "number"
        },
        {
            "name": "groupName",
            "baseName": "group_name",
            "type": "string"
        },
        {
            "name": "timeLength",
            "baseName": "time_length",
            "type": "number"
        },
        {
            "name": "unitOfTime",
            "baseName": "unit_of_time",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TimePeriodGettable.attributeTypeMap);
    }
}

export class TimePeriodUsable extends Behavior {
    /**
    * The amount of times it can be used
    */
    'maxUse': number;
    /**
    * The length of time
    */
    'timeLength': number;
    /**
    * The unit of time
    */
    'unitOfTime': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "maxUse",
            "baseName": "max_use",
            "type": "number"
        },
        {
            "name": "timeLength",
            "baseName": "time_length",
            "type": "number"
        },
        {
            "name": "unitOfTime",
            "baseName": "unit_of_time",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TimePeriodUsable.attributeTypeMap);
    }
}

export class VideoPropertyDefinitionResource extends PropertyDefinitionResource {
    /**
    * If provided, a file type that teh property must match
    */
    'fileType': string;
    /**
    * If provided, the maximum height of the video
    */
    'maxHeight': number;
    /**
    * If provided, the maximum length of the video
    */
    'maxLength': number;
    /**
    * If provided, the maximum width of the video
    */
    'maxWidth': number;
    /**
    * If provided, the minimum height of the video
    */
    'minHeight': number;
    /**
    * If provided, the minimum length of the video
    */
    'minLength': number;
    /**
    * If provided, the minimum width of the video
    */
    'minWidth': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fileType",
            "baseName": "file_type",
            "type": "string"
        },
        {
            "name": "maxHeight",
            "baseName": "max_height",
            "type": "number"
        },
        {
            "name": "maxLength",
            "baseName": "max_length",
            "type": "number"
        },
        {
            "name": "maxWidth",
            "baseName": "max_width",
            "type": "number"
        },
        {
            "name": "minHeight",
            "baseName": "min_height",
            "type": "number"
        },
        {
            "name": "minLength",
            "baseName": "min_length",
            "type": "number"
        },
        {
            "name": "minWidth",
            "baseName": "min_width",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(VideoPropertyDefinitionResource.attributeTypeMap);
    }
}

export class AudioGroupProperty extends FileGroupProperty {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(AudioGroupProperty.attributeTypeMap);
    }
}

export class AudioGroupPropertyDefinitionResource extends FileGroupPropertyDefinitionResource {
    /**
    * If provided, the maximum length of the audio
    */
    'maxLength': number;
    /**
    * If provided, the minimum length of the audio
    */
    'minLength': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "maxLength",
            "baseName": "max_length",
            "type": "number"
        },
        {
            "name": "minLength",
            "baseName": "min_length",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(AudioGroupPropertyDefinitionResource.attributeTypeMap);
    }
}

export class AudioProperty extends FileProperty {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(AudioProperty.attributeTypeMap);
    }
}

export class BundleItem extends StoreItem {
    /**
    * The skus of items to be included in this bundle, and how they influence the bundle total price.  Must have at least one SKU
    */
    'bundledSkus': Array<BundledSku>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "bundledSkus",
            "baseName": "bundled_skus",
            "type": "Array<BundledSku>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(BundleItem.attributeTypeMap);
    }
}

export namespace BundleItem {
}
export class CouponItem extends StoreItem {
    /**
    * The type of coupon
    */
    'couponTypeHint': CouponItem.CouponTypeHintEnum;
    /**
    * The amount this coupon is maxed out at.  Applies if coupon_type_hint is coupon_cart
    */
    'discountMax': number;
    /**
    * The minimium amount needed in the cart for the coupon to apply.  Applies if coupon_type_hint is coupon_cart
    */
    'discountMinCartValue': number;
    /**
    * The type of discount in terms of how it deducts price. Value based discount not available for coupon_cart type coupons
    */
    'discountType': CouponItem.DiscountTypeEnum;
    /**
    * The amount the coupon will discount the item. If discount_type is 'value' this will be a flat amount of currency. If discount type is 'percentage' this will be a fraction (0.2 for 20% off) multiplied by the price of the matching item or items.
    */
    'discountValue': number;
    /**
    * Whether this coupon is exclusive or not (true means cannot be in same cart as another).  Default = false
    */
    'exclusive': boolean;
    /**
    * The id of the item the coupon is applied to.  Applies if coupon_type_hint is coupon_single_item or coupon_voucher
    */
    'itemId': number;
    /**
    * The maximum quantity of items the coupon can apply to, null if no limit and minimum 1 otherwise.  Applies if coupon_type_hint is coupon_single_item or coupon_voucher
    */
    'maxQuantity': number;
    /**
    * Whether this coupon is exclusive to itself or not (true means cannot add two of this same coupon to the same cart).  Default = false
    */
    'selfExclusive': boolean;
    /**
    * A list of tags for a coupon.  The coupon can only apply to an item that has at least one of these tags.  Applies if coupon_type_hint is coupon_tag
    */
    'validForTags': Array<string>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "couponTypeHint",
            "baseName": "coupon_type_hint",
            "type": "CouponItem.CouponTypeHintEnum"
        },
        {
            "name": "discountMax",
            "baseName": "discount_max",
            "type": "number"
        },
        {
            "name": "discountMinCartValue",
            "baseName": "discount_min_cart_value",
            "type": "number"
        },
        {
            "name": "discountType",
            "baseName": "discount_type",
            "type": "CouponItem.DiscountTypeEnum"
        },
        {
            "name": "discountValue",
            "baseName": "discount_value",
            "type": "number"
        },
        {
            "name": "exclusive",
            "baseName": "exclusive",
            "type": "boolean"
        },
        {
            "name": "itemId",
            "baseName": "item_id",
            "type": "number"
        },
        {
            "name": "maxQuantity",
            "baseName": "max_quantity",
            "type": "number"
        },
        {
            "name": "selfExclusive",
            "baseName": "self_exclusive",
            "type": "boolean"
        },
        {
            "name": "validForTags",
            "baseName": "valid_for_tags",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CouponItem.attributeTypeMap);
    }
}

export namespace CouponItem {
    export enum CouponTypeHintEnum {
        Cart = <any> 'coupon_cart',
        SingleItem = <any> 'coupon_single_item',
        Voucher = <any> 'coupon_voucher',
        Vendor = <any> 'coupon_vendor',
        Tag = <any> 'coupon_tag'
    }
    export enum DiscountTypeEnum {
        Value = <any> 'value',
        Percentage = <any> 'percentage'
    }
}
export class ImageGroupProperty extends FileGroupProperty {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ImageGroupProperty.attributeTypeMap);
    }
}

export class ImageGroupPropertyDefinitionResource extends FileGroupPropertyDefinitionResource {
    /**
    * If provided, the maximum height of each image
    */
    'maxHeight': number;
    /**
    * If provided, the maximum width of each image
    */
    'maxWidth': number;
    /**
    * If provided, the minimum height of each image
    */
    'minHeight': number;
    /**
    * If provided, the minumum width of each image
    */
    'minWidth': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "maxHeight",
            "baseName": "max_height",
            "type": "number"
        },
        {
            "name": "maxWidth",
            "baseName": "max_width",
            "type": "number"
        },
        {
            "name": "minHeight",
            "baseName": "min_height",
            "type": "number"
        },
        {
            "name": "minWidth",
            "baseName": "min_width",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ImageGroupPropertyDefinitionResource.attributeTypeMap);
    }
}

export class ImageProperty extends FileProperty {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ImageProperty.attributeTypeMap);
    }
}

export class ShippingItem extends StoreItem {
    /**
    * A unique list of country iso3 codes that allow the shipping option
    */
    'countries': Array<string>;
    /**
    * An abstract max value that the values of item's shipping_tier work against to decide whether an order can be fulfilled
    */
    'maxTierTotal': number;
    /**
    * Whether tax should be applied to the shipping price.  Default = false
    */
    'taxable': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "countries",
            "baseName": "countries",
            "type": "Array<string>"
        },
        {
            "name": "maxTierTotal",
            "baseName": "max_tier_total",
            "type": "number"
        },
        {
            "name": "taxable",
            "baseName": "taxable",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ShippingItem.attributeTypeMap);
    }
}

export namespace ShippingItem {
}
export class Subscription extends StoreItem {
    'availability': Subscription.AvailabilityEnum;
    'consolidationDayOfMonth': number;
    'subscriptionPlans': Array<SubscriptionPlan>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "availability",
            "baseName": "availability",
            "type": "Subscription.AvailabilityEnum"
        },
        {
            "name": "consolidationDayOfMonth",
            "baseName": "consolidation_day_of_month",
            "type": "number"
        },
        {
            "name": "subscriptionPlans",
            "baseName": "subscription_plans",
            "type": "Array<SubscriptionPlan>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Subscription.attributeTypeMap);
    }
}

export namespace Subscription {
    export enum AvailabilityEnum {
        All = <any> 'all',
        NewSubscribers = <any> 'new_subscribers'
    }
}
export class VideoGroupProperty extends FileGroupProperty {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(VideoGroupProperty.attributeTypeMap);
    }
}

export class VideoGroupPropertyDefinitionResource extends FileGroupPropertyDefinitionResource {
    /**
    * If provided, the maximum height of each video
    */
    'maxHeight': number;
    /**
    * If provided, the maximum length of each video
    */
    'maxLength': number;
    /**
    * If provided, the maximum width of each video
    */
    'maxWidth': number;
    /**
    * If provided, the minimum height of each video
    */
    'minHeight': number;
    /**
    * If provided, the minimum length of each video
    */
    'minLength': number;
    /**
    * If provided, the minimum width of each video
    */
    'minWidth': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "maxHeight",
            "baseName": "max_height",
            "type": "number"
        },
        {
            "name": "maxLength",
            "baseName": "max_length",
            "type": "number"
        },
        {
            "name": "maxWidth",
            "baseName": "max_width",
            "type": "number"
        },
        {
            "name": "minHeight",
            "baseName": "min_height",
            "type": "number"
        },
        {
            "name": "minLength",
            "baseName": "min_length",
            "type": "number"
        },
        {
            "name": "minWidth",
            "baseName": "min_width",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(VideoGroupPropertyDefinitionResource.attributeTypeMap);
    }
}

export class VideoProperty extends FileProperty {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(VideoProperty.attributeTypeMap);
    }
}


let enumsMap = {
    "ActionResource.CategoryEnum": ActionResource.CategoryEnum,
    "ActivityOccurrenceResource.RewardStatusEnum": ActivityOccurrenceResource.RewardStatusEnum,
    "ActivityOccurrenceResource.StatusEnum": ActivityOccurrenceResource.StatusEnum,
    "ActivityUserResource.StatusEnum": ActivityUserResource.StatusEnum,
    "BreTriggerResource.CategoryEnum": BreTriggerResource.CategoryEnum,
    "CampaignResource.RewardStatusEnum": CampaignResource.RewardStatusEnum,
    "Cart.StatusEnum": Cart.StatusEnum,
    "CartSummary.StatusEnum": CartSummary.StatusEnum,
    "CatalogSale.DiscountTypeEnum": CatalogSale.DiscountTypeEnum,
    "ChallengeEventResource.RewardStatusEnum": ChallengeEventResource.RewardStatusEnum,
    "CouponDefinition.DiscountTypeEnum": CouponDefinition.DiscountTypeEnum,
    "CouponDefinition.TypeEnum": CouponDefinition.TypeEnum,
    "CurrencyResource.TypeEnum": CurrencyResource.TypeEnum,
    "DeltaResource.StateEnum": DeltaResource.StateEnum,
    "DeviceResource.ConditionEnum": DeviceResource.ConditionEnum,
    "DeviceResource.StatusEnum": DeviceResource.StatusEnum,
    "FlagReportResource.ResolutionEnum": FlagReportResource.ResolutionEnum,
    "GroupMemberResource.StatusEnum": GroupMemberResource.StatusEnum,
    "GroupResource.StatusEnum": GroupResource.StatusEnum,
    "ImportJobResource.StatusEnum": ImportJobResource.StatusEnum,
    "InventorySubscriptionResource.InventoryStatusEnum": InventorySubscriptionResource.InventoryStatusEnum,
    "Order.DirectionEnum": Order.DirectionEnum,
    "Order.NullHandlingEnum": Order.NullHandlingEnum,
    "PaymentMethodResource.PaymentTypeEnum": PaymentMethodResource.PaymentTypeEnum,
    "PollResource.TypeEnum": PollResource.TypeEnum,
    "PropertyFieldResource.InnerTypeEnum": PropertyFieldResource.InnerTypeEnum,
    "PropertyFieldResource.TypeEnum": PropertyFieldResource.TypeEnum,
    "Schedule.DurationUnitEnum": Schedule.DurationUnitEnum,
    "Schedule.RepeatEnum": Schedule.RepeatEnum,
    "SubscriptionPlan.AvailabilityEnum": SubscriptionPlan.AvailabilityEnum,
    "SubscriptionPlan.FirstBillUnitOfTimeEnum": SubscriptionPlan.FirstBillUnitOfTimeEnum,
    "SubscriptionPlan.RenewPeriodUnitOfTimeEnum": SubscriptionPlan.RenewPeriodUnitOfTimeEnum,
    "SubscriptionPlanResource.BillingCycleUnitEnum": SubscriptionPlanResource.BillingCycleUnitEnum,
    "SubscriptionPlanResource.FirstBillingCycleUnitEnum": SubscriptionPlanResource.FirstBillingCycleUnitEnum,
    "SubscriptionResource.AvailabilityEnum": SubscriptionResource.AvailabilityEnum,
    "SubscriptionResource.GeoPolicyTypeEnum": SubscriptionResource.GeoPolicyTypeEnum,
    "TransactionResource.SourceEnum": TransactionResource.SourceEnum,
    "UserInventoryResource.StatusEnum": UserInventoryResource.StatusEnum,
    "VariableTypeResource.BaseEnum": VariableTypeResource.BaseEnum,
    "VideoResource.PrivacyEnum": VideoResource.PrivacyEnum,
    "WalletTransactionResource.SourceEnum": WalletTransactionResource.SourceEnum,
    "StoreItem.GeoPolicyTypeEnum": StoreItem.GeoPolicyTypeEnum,
    "CouponItem.CouponTypeHintEnum": CouponItem.CouponTypeHintEnum,
    "CouponItem.DiscountTypeEnum": CouponItem.DiscountTypeEnum,
    "Subscription.AvailabilityEnum": Subscription.AvailabilityEnum,
}

let typeMap = {
    "AchievementDefinitionResource": AchievementDefinitionResource,
    "ActionResource": ActionResource,
    "ActionVariableResource": ActionVariableResource,
    "ActivityEntitlementResource": ActivityEntitlementResource,
    "ActivityOccurrenceCreationFailure": ActivityOccurrenceCreationFailure,
    "ActivityOccurrenceJoinResult": ActivityOccurrenceJoinResult,
    "ActivityOccurrenceResource": ActivityOccurrenceResource,
    "ActivityOccurrenceResults": ActivityOccurrenceResults,
    "ActivityOccurrenceResultsResource": ActivityOccurrenceResultsResource,
    "ActivityResource": ActivityResource,
    "ActivityUserResource": ActivityUserResource,
    "AddressResource": AddressResource,
    "AggregateCountResource": AggregateCountResource,
    "AggregateInvoiceReportResource": AggregateInvoiceReportResource,
    "AmazonS3Activity": AmazonS3Activity,
    "AnswerResource": AnswerResource,
    "ApplyPaymentRequest": ApplyPaymentRequest,
    "ArticleResource": ArticleResource,
    "ArtistResource": ArtistResource,
    "AvailableSettingResource": AvailableSettingResource,
    "BareActivityResource": BareActivityResource,
    "BareChallengeActivityResource": BareChallengeActivityResource,
    "Batch": Batch,
    "BatchRequest": BatchRequest,
    "BatchResult": BatchResult,
    "BatchReturn": BatchReturn,
    "Behavior": Behavior,
    "BehaviorDefinitionResource": BehaviorDefinitionResource,
    "BillingReport": BillingReport,
    "BooleanResource": BooleanResource,
    "BreCategoryResource": BreCategoryResource,
    "BreEvent": BreEvent,
    "BreEventLog": BreEventLog,
    "BreGlobalResource": BreGlobalResource,
    "BreGlobalScopeDefinition": BreGlobalScopeDefinition,
    "BreRule": BreRule,
    "BreRuleLog": BreRuleLog,
    "BreTriggerParameterDefinition": BreTriggerParameterDefinition,
    "BreTriggerResource": BreTriggerResource,
    "BroadcastableEvent": BroadcastableEvent,
    "BundledSku": BundledSku,
    "CampaignResource": CampaignResource,
    "Cart": Cart,
    "CartItemRequest": CartItemRequest,
    "CartLineItem": CartLineItem,
    "CartShippableResponse": CartShippableResponse,
    "CartShippingAddressRequest": CartShippingAddressRequest,
    "CartShippingOption": CartShippingOption,
    "CartSummary": CartSummary,
    "CatalogSale": CatalogSale,
    "CategoryResource": CategoryResource,
    "ChallengeActivityResource": ChallengeActivityResource,
    "ChallengeEventParticipantResource": ChallengeEventParticipantResource,
    "ChallengeEventResource": ChallengeEventResource,
    "ChallengeResource": ChallengeResource,
    "ClientResource": ClientResource,
    "CollectionCountry": CollectionCountry,
    "Collectionstring": Collectionstring,
    "CommentResource": CommentResource,
    "CommentSearch": CommentSearch,
    "Config": Config,
    "ConfigLookupResource": ConfigLookupResource,
    "ConstantResource": ConstantResource,
    "ContributionResource": ContributionResource,
    "Country": Country,
    "CountryResource": CountryResource,
    "CountryTaxResource": CountryTaxResource,
    "CouponDefinition": CouponDefinition,
    "CreateBillingAgreementRequest": CreateBillingAgreementRequest,
    "CreatePayPalPaymentRequest": CreatePayPalPaymentRequest,
    "CurrencyResource": CurrencyResource,
    "CustomerConfig": CustomerConfig,
    "DatabaseConfig": DatabaseConfig,
    "DateOperationResource": DateOperationResource,
    "DeltaResource": DeltaResource,
    "DeviceResource": DeviceResource,
    "Discount": Discount,
    "DispositionCount": DispositionCount,
    "DispositionResource": DispositionResource,
    "DoubleOperationResource": DoubleOperationResource,
    "EntitlementGrantRequest": EntitlementGrantRequest,
    "ErrorResource": ErrorResource,
    "EventContextResource": EventContextResource,
    "ExpressionResource": ExpressionResource,
    "Expressionobject": Expressionobject,
    "FacebookToken": FacebookToken,
    "FattMerchantPaymentMethod": FattMerchantPaymentMethod,
    "FattMerchantPaymentMethodRequest": FattMerchantPaymentMethodRequest,
    "FinalizeBillingAgreementRequest": FinalizeBillingAgreementRequest,
    "FinalizePayPalPaymentRequest": FinalizePayPalPaymentRequest,
    "FlagReportResource": FlagReportResource,
    "FlagResource": FlagResource,
    "ForwardLog": ForwardLog,
    "FulfillmentType": FulfillmentType,
    "GlobalCheckAndIncrementResource": GlobalCheckAndIncrementResource,
    "GlobalResource": GlobalResource,
    "GooglePaymentRequest": GooglePaymentRequest,
    "GoogleToken": GoogleToken,
    "GrantTypeResource": GrantTypeResource,
    "GroupMemberResource": GroupMemberResource,
    "GroupResource": GroupResource,
    "IOConfig": IOConfig,
    "ImportJobOutputResource": ImportJobOutputResource,
    "ImportJobResource": ImportJobResource,
    "IntWrapper": IntWrapper,
    "IntegerOperationResource": IntegerOperationResource,
    "InventorySubscriptionResource": InventorySubscriptionResource,
    "InvoiceCreateRequest": InvoiceCreateRequest,
    "InvoiceItemResource": InvoiceItemResource,
    "InvoiceLogEntry": InvoiceLogEntry,
    "InvoicePaymentStatusRequest": InvoicePaymentStatusRequest,
    "InvoiceResource": InvoiceResource,
    "Item": Item,
    "ItemBehaviorDefinitionResource": ItemBehaviorDefinitionResource,
    "ItemTemplateResource": ItemTemplateResource,
    "KeyValuePairstringstring": KeyValuePairstringstring,
    "LeaderboardEntryResource": LeaderboardEntryResource,
    "LeaderboardResource": LeaderboardResource,
    "LevelingResource": LevelingResource,
    "LimitedGettableGroup": LimitedGettableGroup,
    "Localizer": Localizer,
    "LocationLogResource": LocationLogResource,
    "LookupResource": LookupResource,
    "LookupTypeResource": LookupTypeResource,
    "Maintenance": Maintenance,
    "MapResource": MapResource,
    "Mapstringobject": Mapstringobject,
    "MetricResource": MetricResource,
    "MongoDatabaseConfig": MongoDatabaseConfig,
    "NestedCategory": NestedCategory,
    "NewPasswordRequest": NewPasswordRequest,
    "OAuth2Resource": OAuth2Resource,
    "OauthAccessTokenResource": OauthAccessTokenResource,
    "Operator": Operator,
    "OptimalPaymentRequest": OptimalPaymentRequest,
    "Order": Order,
    "PageResourceAchievementDefinitionResource": PageResourceAchievementDefinitionResource,
    "PageResourceAggregateCountResource": PageResourceAggregateCountResource,
    "PageResourceAggregateInvoiceReportResource": PageResourceAggregateInvoiceReportResource,
    "PageResourceArticleResource": PageResourceArticleResource,
    "PageResourceArtistResource": PageResourceArtistResource,
    "PageResourceBareActivityResource": PageResourceBareActivityResource,
    "PageResourceBareChallengeActivityResource": PageResourceBareChallengeActivityResource,
    "PageResourceBillingReport": PageResourceBillingReport,
    "PageResourceBreCategoryResource": PageResourceBreCategoryResource,
    "PageResourceBreEventLog": PageResourceBreEventLog,
    "PageResourceBreGlobalResource": PageResourceBreGlobalResource,
    "PageResourceBreRule": PageResourceBreRule,
    "PageResourceBreTriggerResource": PageResourceBreTriggerResource,
    "PageResourceCampaignResource": PageResourceCampaignResource,
    "PageResourceCartSummary": PageResourceCartSummary,
    "PageResourceCatalogSale": PageResourceCatalogSale,
    "PageResourceCategoryResource": PageResourceCategoryResource,
    "PageResourceChallengeEventParticipantResource": PageResourceChallengeEventParticipantResource,
    "PageResourceChallengeEventResource": PageResourceChallengeEventResource,
    "PageResourceChallengeResource": PageResourceChallengeResource,
    "PageResourceClientResource": PageResourceClientResource,
    "PageResourceCommentResource": PageResourceCommentResource,
    "PageResourceConfig": PageResourceConfig,
    "PageResourceCountryTaxResource": PageResourceCountryTaxResource,
    "PageResourceCurrencyResource": PageResourceCurrencyResource,
    "PageResourceDeviceResource": PageResourceDeviceResource,
    "PageResourceDispositionResource": PageResourceDispositionResource,
    "PageResourceEntitlementItem": PageResourceEntitlementItem,
    "PageResourceFlagReportResource": PageResourceFlagReportResource,
    "PageResourceForwardLog": PageResourceForwardLog,
    "PageResourceFulfillmentType": PageResourceFulfillmentType,
    "PageResourceGroupMemberResource": PageResourceGroupMemberResource,
    "PageResourceGroupResource": PageResourceGroupResource,
    "PageResourceImportJobResource": PageResourceImportJobResource,
    "PageResourceInvoiceLogEntry": PageResourceInvoiceLogEntry,
    "PageResourceInvoiceResource": PageResourceInvoiceResource,
    "PageResourceItemTemplateResource": PageResourceItemTemplateResource,
    "PageResourceLevelingResource": PageResourceLevelingResource,
    "PageResourceLocationLogResource": PageResourceLocationLogResource,
    "PageResourceMapstringobject": PageResourceMapstringobject,
    "PageResourceOauthAccessTokenResource": PageResourceOauthAccessTokenResource,
    "PageResourcePermissionResource": PageResourcePermissionResource,
    "PageResourcePollResource": PageResourcePollResource,
    "PageResourceQuestionResource": PageResourceQuestionResource,
    "PageResourceQuestionTemplateResource": PageResourceQuestionTemplateResource,
    "PageResourceRevenueCountryReportResource": PageResourceRevenueCountryReportResource,
    "PageResourceRevenueProductReportResource": PageResourceRevenueProductReportResource,
    "PageResourceRewardSetResource": PageResourceRewardSetResource,
    "PageResourceRoleResource": PageResourceRoleResource,
    "PageResourceSavedAddressResource": PageResourceSavedAddressResource,
    "PageResourceSimpleReferenceResourceobject": PageResourceSimpleReferenceResourceobject,
    "PageResourceSimpleUserResource": PageResourceSimpleUserResource,
    "PageResourceSimpleWallet": PageResourceSimpleWallet,
    "PageResourceStateTaxResource": PageResourceStateTaxResource,
    "PageResourceStoreItem": PageResourceStoreItem,
    "PageResourceStoreItemTemplateResource": PageResourceStoreItemTemplateResource,
    "PageResourceSubscriptionResource": PageResourceSubscriptionResource,
    "PageResourceSubscriptionTemplateResource": PageResourceSubscriptionTemplateResource,
    "PageResourceTemplateResource": PageResourceTemplateResource,
    "PageResourceTransactionResource": PageResourceTransactionResource,
    "PageResourceUsageInfo": PageResourceUsageInfo,
    "PageResourceUserAchievementGroupResource": PageResourceUserAchievementGroupResource,
    "PageResourceUserActionLog": PageResourceUserActionLog,
    "PageResourceUserBaseResource": PageResourceUserBaseResource,
    "PageResourceUserInventoryResource": PageResourceUserInventoryResource,
    "PageResourceUserItemLogResource": PageResourceUserItemLogResource,
    "PageResourceUserLevelingResource": PageResourceUserLevelingResource,
    "PageResourceUserRelationshipResource": PageResourceUserRelationshipResource,
    "PageResourceVendorResource": PageResourceVendorResource,
    "PageResourceVideoRelationshipResource": PageResourceVideoRelationshipResource,
    "PageResourceVideoResource": PageResourceVideoResource,
    "PageResourceWalletTotalResponse": PageResourceWalletTotalResponse,
    "PageResourceWalletTransactionResource": PageResourceWalletTransactionResource,
    "PageResourcestring": PageResourcestring,
    "ParameterResource": ParameterResource,
    "PasswordResetRequest": PasswordResetRequest,
    "PayBySavedMethodRequest": PayBySavedMethodRequest,
    "PaymentAuthorizationResource": PaymentAuthorizationResource,
    "PaymentMethodDetails": PaymentMethodDetails,
    "PaymentMethodResource": PaymentMethodResource,
    "PaymentMethodTypeResource": PaymentMethodTypeResource,
    "PermissionResource": PermissionResource,
    "PollAnswerResource": PollAnswerResource,
    "PollResource": PollResource,
    "PollResponseResource": PollResponseResource,
    "PredicateOperation": PredicateOperation,
    "PredicateResource": PredicateResource,
    "Property": Property,
    "PropertyDefinitionResource": PropertyDefinitionResource,
    "PropertyFieldListResource": PropertyFieldListResource,
    "PropertyFieldResource": PropertyFieldResource,
    "QuestionResource": QuestionResource,
    "QuestionTemplateResource": QuestionTemplateResource,
    "QuickBuyRequest": QuickBuyRequest,
    "RawEmailResource": RawEmailResource,
    "RawSMSResource": RawSMSResource,
    "ReactivateSubscriptionRequest": ReactivateSubscriptionRequest,
    "RefundRequest": RefundRequest,
    "RefundResource": RefundResource,
    "Result": Result,
    "RevenueCountryReportResource": RevenueCountryReportResource,
    "RevenueProductReportResource": RevenueProductReportResource,
    "RevenueReportResource": RevenueReportResource,
    "RewardCurrencyResource": RewardCurrencyResource,
    "RewardItemResource": RewardItemResource,
    "RewardSetResource": RewardSetResource,
    "RoleResource": RoleResource,
    "S3Config": S3Config,
    "SampleCountriesResponse": SampleCountriesResponse,
    "SavedAddressResource": SavedAddressResource,
    "Schedule": Schedule,
    "SearchReferenceMapping": SearchReferenceMapping,
    "SelectedSettingResource": SelectedSettingResource,
    "SettingOption": SettingOption,
    "SimpleReferenceResourceint": SimpleReferenceResourceint,
    "SimpleReferenceResourcelong": SimpleReferenceResourcelong,
    "SimpleReferenceResourceobject": SimpleReferenceResourceobject,
    "SimpleReferenceResourcestring": SimpleReferenceResourcestring,
    "SimpleUserResource": SimpleUserResource,
    "SimpleWallet": SimpleWallet,
    "Sku": Sku,
    "SkuRequest": SkuRequest,
    "SqlDatabaseConfig": SqlDatabaseConfig,
    "StateResource": StateResource,
    "StateTaxResource": StateTaxResource,
    "StoreItemTemplateResource": StoreItemTemplateResource,
    "StringOperationResource": StringOperationResource,
    "StringWrapper": StringWrapper,
    "StripeCreatePaymentMethod": StripeCreatePaymentMethod,
    "StripePaymentRequest": StripePaymentRequest,
    "SubscriptionCreditResource": SubscriptionCreditResource,
    "SubscriptionPlan": SubscriptionPlan,
    "SubscriptionPlanResource": SubscriptionPlanResource,
    "SubscriptionPriceOverrideRequest": SubscriptionPriceOverrideRequest,
    "SubscriptionResource": SubscriptionResource,
    "SubscriptionTemplateResource": SubscriptionTemplateResource,
    "TemplateEmailResource": TemplateEmailResource,
    "TemplateResource": TemplateResource,
    "TemplateSMSResource": TemplateSMSResource,
    "TierResource": TierResource,
    "TokenDetailsResource": TokenDetailsResource,
    "TransactionResource": TransactionResource,
    "TypeHintLookupResource": TypeHintLookupResource,
    "UsageInfo": UsageInfo,
    "UserAchievementGroupResource": UserAchievementGroupResource,
    "UserAchievementResource": UserAchievementResource,
    "UserActionLog": UserActionLog,
    "UserActivityResults": UserActivityResults,
    "UserActivityResultsResource": UserActivityResultsResource,
    "UserBaseResource": UserBaseResource,
    "UserInventoryAddRequest": UserInventoryAddRequest,
    "UserInventoryResource": UserInventoryResource,
    "UserItemLogResource": UserItemLogResource,
    "UserLevelingResource": UserLevelingResource,
    "UserRelationshipReferenceResource": UserRelationshipReferenceResource,
    "UserRelationshipResource": UserRelationshipResource,
    "UserResource": UserResource,
    "UsernameLookupResource": UsernameLookupResource,
    "VariableTypeResource": VariableTypeResource,
    "VendorEmailLookupResource": VendorEmailLookupResource,
    "VendorResource": VendorResource,
    "Version": Version,
    "VideoRelationshipResource": VideoRelationshipResource,
    "VideoResource": VideoResource,
    "WalletAlterRequest": WalletAlterRequest,
    "WalletTotalResponse": WalletTotalResponse,
    "WalletTransactionResource": WalletTransactionResource,
    "XsollaPaymentRequest": XsollaPaymentRequest,
    "AudioPropertyDefinitionResource": AudioPropertyDefinitionResource,
    "BooleanProperty": BooleanProperty,
    "BooleanPropertyDefinitionResource": BooleanPropertyDefinitionResource,
    "CacheClearEvent": CacheClearEvent,
    "Consumable": Consumable,
    "DateProperty": DateProperty,
    "DatePropertyDefinitionResource": DatePropertyDefinitionResource,
    "DoubleProperty": DoubleProperty,
    "DoublePropertyDefinitionResource": DoublePropertyDefinitionResource,
    "EntitlementItem": EntitlementItem,
    "Expirable": Expirable,
    "FileGroupProperty": FileGroupProperty,
    "FileGroupPropertyDefinitionResource": FileGroupPropertyDefinitionResource,
    "FileProperty": FileProperty,
    "FilePropertyDefinitionResource": FilePropertyDefinitionResource,
    "FormattedTextProperty": FormattedTextProperty,
    "FormattedTextPropertyDefinitionResource": FormattedTextPropertyDefinitionResource,
    "Fulfillable": Fulfillable,
    "GuestPlayable": GuestPlayable,
    "ImagePropertyDefinitionResource": ImagePropertyDefinitionResource,
    "IntegerProperty": IntegerProperty,
    "IntegerPropertyDefinitionResource": IntegerPropertyDefinitionResource,
    "LimitedGettable": LimitedGettable,
    "LogLevelEvent": LogLevelEvent,
    "LongProperty": LongProperty,
    "LongPropertyDefinitionResource": LongPropertyDefinitionResource,
    "NewCustomerEvent": NewCustomerEvent,
    "PreReqEntitlement": PreReqEntitlement,
    "PriceOverridable": PriceOverridable,
    "RemoveCustomerEvent": RemoveCustomerEvent,
    "Spendable": Spendable,
    "StoreItem": StoreItem,
    "TextProperty": TextProperty,
    "TextPropertyDefinitionResource": TextPropertyDefinitionResource,
    "TimePeriodGettable": TimePeriodGettable,
    "TimePeriodUsable": TimePeriodUsable,
    "VideoPropertyDefinitionResource": VideoPropertyDefinitionResource,
    "AudioGroupProperty": AudioGroupProperty,
    "AudioGroupPropertyDefinitionResource": AudioGroupPropertyDefinitionResource,
    "AudioProperty": AudioProperty,
    "BundleItem": BundleItem,
    "CouponItem": CouponItem,
    "ImageGroupProperty": ImageGroupProperty,
    "ImageGroupPropertyDefinitionResource": ImageGroupPropertyDefinitionResource,
    "ImageProperty": ImageProperty,
    "ShippingItem": ShippingItem,
    "Subscription": Subscription,
    "VideoGroupProperty": VideoGroupProperty,
    "VideoGroupPropertyDefinitionResource": VideoGroupPropertyDefinitionResource,
    "VideoProperty": VideoProperty,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: request.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: request.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: request.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(_: request.Options): void {
        // Do nothing
    }
}

export enum AccessTokenApiApiKeys {
}

export class AccessTokenApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AccessTokenApiApiKeys, value: string) {
        this.authentications[AccessTokenApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Get access token
     * @param grantType Grant type
     * @param clientId The id of the client
     * @param clientSecret The secret key of the client.  Used only with a grant_type of client_credentials
     * @param username The username of the client.  Used only with a grant_type of password
     * @param password The password of the client.  Used only with a grant_type of password
     */
    public getOAuthToken (grantType: string, clientId: string, clientSecret?: string, username?: string, password?: string) : Promise<{ response: http.ClientResponse; body: OAuth2Resource;  }> {
        const localVarPath = this.basePath + '/oauth/token';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'grantType' is not null or undefined
        if (grantType === null || grantType === undefined) {
            throw new Error('Required parameter grantType was null or undefined when calling getOAuthToken.');
        }

        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling getOAuthToken.');
        }


        let useFormData = false;

        if (grantType !== undefined) {
            formParams['grant_type'] = ObjectSerializer.serialize(grantType, "string");
        }

        if (clientId !== undefined) {
            formParams['client_id'] = ObjectSerializer.serialize(clientId, "string");
        }

        if (clientSecret !== undefined) {
            formParams['client_secret'] = ObjectSerializer.serialize(clientSecret, "string");
        }

        if (username !== undefined) {
            formParams['username'] = ObjectSerializer.serialize(username, "string");
        }

        if (password !== undefined) {
            formParams['password'] = ObjectSerializer.serialize(password, "string");
        }

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OAuth2Resource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OAuth2Resource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ActivitiesApiApiKeys {
}

export class ActivitiesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ActivitiesApiApiKeys, value: string) {
        this.authentications[ActivitiesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Create an activity
     * @param activityResource The activity resource object
     */
    public createActivity (activityResource?: ActivityResource) : Promise<{ response: http.ClientResponse; body: ActivityResource;  }> {
        const localVarPath = this.basePath + '/activities';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(activityResource, "ActivityResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ActivityResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ActivityResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Has to enforce extra rules if not used as an admin
     * @summary Create a new activity occurrence. Ex: start a game
     * @param test if true, indicates that the occurrence should NOT be created. This can be used to test for eligibility and valid settings
     * @param activityOccurrenceResource The activity occurrence object
     */
    public createActivityOccurrence (test?: boolean, activityOccurrenceResource?: ActivityOccurrenceResource) : Promise<{ response: http.ClientResponse; body: ActivityOccurrenceResource;  }> {
        const localVarPath = this.basePath + '/activity-occurrences';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (test !== undefined) {
            queryParameters['test'] = ObjectSerializer.serialize(test, "boolean");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(activityOccurrenceResource, "ActivityOccurrenceResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ActivityOccurrenceResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ActivityOccurrenceResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Activity Templates define a type of activity and the properties they have
     * @summary Create a activity template
     * @param activityTemplateResource The activity template resource object
     */
    public createActivityTemplate (activityTemplateResource?: TemplateResource) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/activities/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(activityTemplateResource, "TemplateResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete an activity
     * @param id The id of the activity
     */
    public deleteActivity (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/activities/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteActivity.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete a activity template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    public deleteActivityTemplate (id: string, cascade?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/activities/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteActivityTemplate.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = ObjectSerializer.serialize(cascade, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List activity definitions
     * @param filterTemplate Filter for activities that are templates, or specifically not if false
     * @param filterName Filter for activities that have a name starting with specified string
     * @param filterId Filter for activities with an id in the given comma separated list of ids
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getActivities (filterTemplate?: boolean, filterName?: string, filterId?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceBareActivityResource;  }> {
        const localVarPath = this.basePath + '/activities';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterTemplate !== undefined) {
            queryParameters['filter_template'] = ObjectSerializer.serialize(filterTemplate, "boolean");
        }

        if (filterName !== undefined) {
            queryParameters['filter_name'] = ObjectSerializer.serialize(filterName, "string");
        }

        if (filterId !== undefined) {
            queryParameters['filter_id'] = ObjectSerializer.serialize(filterId, "string");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceBareActivityResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceBareActivityResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single activity
     * @param id The id of the activity
     */
    public getActivity (id: number) : Promise<{ response: http.ClientResponse; body: ActivityResource;  }> {
        const localVarPath = this.basePath + '/activities/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getActivity.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ActivityResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ActivityResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single activity template
     * @param id The id of the template
     */
    public getActivityTemplate (id: string) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/activities/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getActivityTemplate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List and search activity templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getActivityTemplates (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }> {
        const localVarPath = this.basePath + '/activities/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Sets the status of an activity occurrence to FINISHED and logs metrics
     * @param activityOccurrenceId The id of the activity occurrence
     * @param activityOccurrenceResults The activity occurrence object
     */
    public setActivityOccurrenceResults (activityOccurrenceId: number, activityOccurrenceResults?: ActivityOccurrenceResultsResource) : Promise<{ response: http.ClientResponse; body: ActivityOccurrenceResults;  }> {
        const localVarPath = this.basePath + '/activity-occurrences/{activity_occurrence_id}/results'
            .replace('{' + 'activity_occurrence_id' + '}', String(activityOccurrenceId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'activityOccurrenceId' is not null or undefined
        if (activityOccurrenceId === null || activityOccurrenceId === undefined) {
            throw new Error('Required parameter activityOccurrenceId was null or undefined when calling setActivityOccurrenceResults.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(activityOccurrenceResults, "ActivityOccurrenceResultsResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ActivityOccurrenceResults;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ActivityOccurrenceResults");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update an activity
     * @param id The id of the activity
     * @param activityResource The activity resource object
     */
    public updateActivity (id: number, activityResource?: ActivityResource) : Promise<{ response: http.ClientResponse; body: ActivityResource;  }> {
        const localVarPath = this.basePath + '/activities/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateActivity.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(activityResource, "ActivityResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ActivityResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ActivityResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * If setting to 'FINISHED' you must POST to /results instead to record the metrics and get synchronous reward results
     * @summary Updated the status of an activity occurrence
     * @param activityOccurrenceId The id of the activity occurrence
     * @param activityCccurrenceStatus The activity occurrence status object
     */
    public updateActivityOccurrence (activityOccurrenceId: number, activityCccurrenceStatus?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/activity-occurrences/{activity_occurrence_id}/status'
            .replace('{' + 'activity_occurrence_id' + '}', String(activityOccurrenceId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'activityOccurrenceId' is not null or undefined
        if (activityOccurrenceId === null || activityOccurrenceId === undefined) {
            throw new Error('Required parameter activityOccurrenceId was null or undefined when calling updateActivityOccurrence.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(activityCccurrenceStatus, "string")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update an activity template
     * @param id The id of the template
     * @param activityTemplateResource The activity template resource object
     */
    public updateActivityTemplate (id: string, activityTemplateResource?: TemplateResource) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/activities/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateActivityTemplate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(activityTemplateResource, "TemplateResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AmazonWebServicesS3ApiApiKeys {
}

export class AmazonWebServicesS3Api {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AmazonWebServicesS3ApiApiKeys, value: string) {
        this.authentications[AmazonWebServicesS3ApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * Requires the file name and file content type (i.e., 'video/mpeg')
     * @summary Get a signed S3 URL
     * @param filename The file name
     * @param contentType The content type
     */
    public getSignedS3URL (filename?: string, contentType?: string) : Promise<{ response: http.ClientResponse; body: AmazonS3Activity;  }> {
        const localVarPath = this.basePath + '/amazon/s3/signedposturl';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filename !== undefined) {
            queryParameters['filename'] = ObjectSerializer.serialize(filename, "string");
        }

        if (contentType !== undefined) {
            queryParameters['content_type'] = ObjectSerializer.serialize(contentType, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AmazonS3Activity;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AmazonS3Activity");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AuthClientsApiApiKeys {
}

export class AuthClientsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AuthClientsApiApiKeys, value: string) {
        this.authentications[AuthClientsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Create a new client
     * @param clientResource The client resource object
     */
    public createClient (clientResource?: ClientResource) : Promise<{ response: http.ClientResponse; body: ClientResource;  }> {
        const localVarPath = this.basePath + '/auth/clients';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(clientResource, "ClientResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ClientResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ClientResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a client
     * @param clientKey The key of the client
     */
    public deleteClient (clientKey: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/auth/clients/{client_key}'
            .replace('{' + 'client_key' + '}', String(clientKey));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'clientKey' is not null or undefined
        if (clientKey === null || clientKey === undefined) {
            throw new Error('Required parameter clientKey was null or undefined when calling deleteClient.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single client
     * @param clientKey The key of the client
     */
    public getClient (clientKey: string) : Promise<{ response: http.ClientResponse; body: ClientResource;  }> {
        const localVarPath = this.basePath + '/auth/clients/{client_key}'
            .replace('{' + 'client_key' + '}', String(clientKey));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'clientKey' is not null or undefined
        if (clientKey === null || clientKey === undefined) {
            throw new Error('Required parameter clientKey was null or undefined when calling getClient.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ClientResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ClientResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List available client grant types
     */
    public getClientGrantTypes () : Promise<{ response: http.ClientResponse; body: Array<GrantTypeResource>;  }> {
        const localVarPath = this.basePath + '/auth/clients/grant-types';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GrantTypeResource>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GrantTypeResource>");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List and search clients
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getClients (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceClientResource;  }> {
        const localVarPath = this.basePath + '/auth/clients';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceClientResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceClientResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set grant types for a client
     * @param clientKey The key of the client
     * @param grantList A list of unique grant types
     */
    public setClientGrantTypes (clientKey: string, grantList?: Array<string>) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/auth/clients/{client_key}/grant-types'
            .replace('{' + 'client_key' + '}', String(clientKey));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'clientKey' is not null or undefined
        if (clientKey === null || clientKey === undefined) {
            throw new Error('Required parameter clientKey was null or undefined when calling setClientGrantTypes.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(grantList, "Array<string>")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set redirect uris for a client
     * @param clientKey The key of the client
     * @param redirectList A list of unique redirect uris
     */
    public setClientRedirectUris (clientKey: string, redirectList?: Array<string>) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/auth/clients/{client_key}/redirect-uris'
            .replace('{' + 'client_key' + '}', String(clientKey));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'clientKey' is not null or undefined
        if (clientKey === null || clientKey === undefined) {
            throw new Error('Required parameter clientKey was null or undefined when calling setClientRedirectUris.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(redirectList, "Array<string>")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a client
     * @param clientKey The key of the client
     * @param clientResource The client resource object
     */
    public updateClient (clientKey: string, clientResource?: ClientResource) : Promise<{ response: http.ClientResponse; body: ClientResource;  }> {
        const localVarPath = this.basePath + '/auth/clients/{client_key}'
            .replace('{' + 'client_key' + '}', String(clientKey));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'clientKey' is not null or undefined
        if (clientKey === null || clientKey === undefined) {
            throw new Error('Required parameter clientKey was null or undefined when calling updateClient.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(clientResource, "ClientResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ClientResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ClientResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AuthPermissionsApiApiKeys {
}

export class AuthPermissionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AuthPermissionsApiApiKeys, value: string) {
        this.authentications[AuthPermissionsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Create a new permission
     * @param permissionResource The permission resource object
     */
    public createPermission (permissionResource?: PermissionResource) : Promise<{ response: http.ClientResponse; body: PermissionResource;  }> {
        const localVarPath = this.basePath + '/auth/permissions';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(permissionResource, "PermissionResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PermissionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PermissionResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a permission
     * @param permission The permission value
     * @param force If true, removes permission assigned to roles
     */
    public deletePermission (permission: string, force?: boolean) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/auth/permissions/{permission}'
            .replace('{' + 'permission' + '}', String(permission));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'permission' is not null or undefined
        if (permission === null || permission === undefined) {
            throw new Error('Required parameter permission was null or undefined when calling deletePermission.');
        }

        if (force !== undefined) {
            queryParameters['force'] = ObjectSerializer.serialize(force, "boolean");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single permission
     * @param permission The permission value
     */
    public getPermission (permission: string) : Promise<{ response: http.ClientResponse; body: PermissionResource;  }> {
        const localVarPath = this.basePath + '/auth/permissions/{permission}'
            .replace('{' + 'permission' + '}', String(permission));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'permission' is not null or undefined
        if (permission === null || permission === undefined) {
            throw new Error('Required parameter permission was null or undefined when calling getPermission.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PermissionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PermissionResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List and search permissions
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getPermissions (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourcePermissionResource;  }> {
        const localVarPath = this.basePath + '/auth/permissions';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourcePermissionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourcePermissionResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a permission
     * @param permission The permission value
     * @param permissionResource The permission resource object
     */
    public updatePermission (permission: string, permissionResource?: PermissionResource) : Promise<{ response: http.ClientResponse; body: PermissionResource;  }> {
        const localVarPath = this.basePath + '/auth/permissions/{permission}'
            .replace('{' + 'permission' + '}', String(permission));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'permission' is not null or undefined
        if (permission === null || permission === undefined) {
            throw new Error('Required parameter permission was null or undefined when calling updatePermission.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(permissionResource, "PermissionResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PermissionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PermissionResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AuthRolesApiApiKeys {
}

export class AuthRolesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AuthRolesApiApiKeys, value: string) {
        this.authentications[AuthRolesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Create a new role
     * @param roleResource The role resource object
     */
    public createRole (roleResource?: RoleResource) : Promise<{ response: http.ClientResponse; body: RoleResource;  }> {
        const localVarPath = this.basePath + '/auth/roles';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(roleResource, "RoleResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RoleResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RoleResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a role
     * @param role The role value
     * @param force If true, removes role from users/clients
     */
    public deleteRole (role: string, force?: boolean) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/auth/roles/{role}'
            .replace('{' + 'role' + '}', String(role));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'role' is not null or undefined
        if (role === null || role === undefined) {
            throw new Error('Required parameter role was null or undefined when calling deleteRole.');
        }

        if (force !== undefined) {
            queryParameters['force'] = ObjectSerializer.serialize(force, "boolean");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get roles for a client
     * @param clientKey The client key
     */
    public getClientRoles (clientKey: string) : Promise<{ response: http.ClientResponse; body: Array<RoleResource>;  }> {
        const localVarPath = this.basePath + '/auth/clients/{client_key}/roles'
            .replace('{' + 'client_key' + '}', String(clientKey));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'clientKey' is not null or undefined
        if (clientKey === null || clientKey === undefined) {
            throw new Error('Required parameter clientKey was null or undefined when calling getClientRoles.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<RoleResource>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<RoleResource>");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single role
     * @param role The role value
     */
    public getRole (role: string) : Promise<{ response: http.ClientResponse; body: RoleResource;  }> {
        const localVarPath = this.basePath + '/auth/roles/{role}'
            .replace('{' + 'role' + '}', String(role));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'role' is not null or undefined
        if (role === null || role === undefined) {
            throw new Error('Required parameter role was null or undefined when calling getRole.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RoleResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RoleResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List and search roles
     * @param filterName Filter for roles that have a name starting with specified string
     * @param filterRole Filter for roles that have a role starting with specified string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getRoles (filterName?: string, filterRole?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceRoleResource;  }> {
        const localVarPath = this.basePath + '/auth/roles';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterName !== undefined) {
            queryParameters['filter_name'] = ObjectSerializer.serialize(filterName, "string");
        }

        if (filterRole !== undefined) {
            queryParameters['filter_role'] = ObjectSerializer.serialize(filterRole, "string");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceRoleResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceRoleResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get roles for a user
     * @param userId The user&#39;s id
     */
    public getUserRoles (userId: number) : Promise<{ response: http.ClientResponse; body: Array<RoleResource>;  }> {
        const localVarPath = this.basePath + '/auth/users/{user_id}/roles'
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserRoles.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<RoleResource>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<RoleResource>");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set roles for a client
     * @param clientKey The client key
     * @param rolesList The list of unique roles
     */
    public setClientRoles (clientKey: string, rolesList?: Array<string>) : Promise<{ response: http.ClientResponse; body: ClientResource;  }> {
        const localVarPath = this.basePath + '/auth/clients/{client_key}/roles'
            .replace('{' + 'client_key' + '}', String(clientKey));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'clientKey' is not null or undefined
        if (clientKey === null || clientKey === undefined) {
            throw new Error('Required parameter clientKey was null or undefined when calling setClientRoles.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(rolesList, "Array<string>")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ClientResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ClientResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set permissions for a role
     * @param role The role value
     * @param permissionsList The list of unique permissions
     */
    public setPermissionsForRole (role: string, permissionsList?: Array<string>) : Promise<{ response: http.ClientResponse; body: RoleResource;  }> {
        const localVarPath = this.basePath + '/auth/roles/{role}/permissions'
            .replace('{' + 'role' + '}', String(role));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'role' is not null or undefined
        if (role === null || role === undefined) {
            throw new Error('Required parameter role was null or undefined when calling setPermissionsForRole.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(permissionsList, "Array<string>")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RoleResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RoleResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set roles for a user
     * @param userId The user&#39;s id
     * @param rolesList The list of unique roles
     */
    public setUserRoles (userId: number, rolesList?: Array<string>) : Promise<{ response: http.ClientResponse; body: UserResource;  }> {
        const localVarPath = this.basePath + '/auth/users/{user_id}/roles'
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling setUserRoles.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(rolesList, "Array<string>")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a role
     * @param role The role value
     * @param roleResource The role resource object
     */
    public updateRole (role: string, roleResource?: RoleResource) : Promise<{ response: http.ClientResponse; body: RoleResource;  }> {
        const localVarPath = this.basePath + '/auth/roles/{role}'
            .replace('{' + 'role' + '}', String(role));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'role' is not null or undefined
        if (role === null || role === undefined) {
            throw new Error('Required parameter role was null or undefined when calling updateRole.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(roleResource, "RoleResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RoleResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RoleResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AuthTokensApiApiKeys {
}

export class AuthTokensApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AuthTokensApiApiKeys, value: string) {
        this.authentications[AuthTokensApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Delete tokens by username, client id, or both
     * @param username The username of the user
     * @param clientId The id of the client
     */
    public deleteTokens (username?: string, clientId?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/auth/tokens';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (username !== undefined) {
            queryParameters['username'] = ObjectSerializer.serialize(username, "string");
        }

        if (clientId !== undefined) {
            queryParameters['client_id'] = ObjectSerializer.serialize(clientId, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single token by username and client id
     * @param username The username of the user
     * @param clientId The id of the client
     */
    public getToken (username: string, clientId: string) : Promise<{ response: http.ClientResponse; body: OauthAccessTokenResource;  }> {
        const localVarPath = this.basePath + '/auth/tokens/{username}/{client_id}'
            .replace('{' + 'username' + '}', String(username))
            .replace('{' + 'client_id' + '}', String(clientId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling getToken.');
        }

        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling getToken.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OauthAccessTokenResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OauthAccessTokenResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Token value not shown
     * @summary List usernames and client ids
     * @param filterClientId Filters for token whose client id matches provided string
     * @param filterUsername Filters for token whose username matches provided string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getTokens (filterClientId?: string, filterUsername?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceOauthAccessTokenResource;  }> {
        const localVarPath = this.basePath + '/auth/tokens';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterClientId !== undefined) {
            queryParameters['filter_client_id'] = ObjectSerializer.serialize(filterClientId, "string");
        }

        if (filterUsername !== undefined) {
            queryParameters['filter_username'] = ObjectSerializer.serialize(filterUsername, "string");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceOauthAccessTokenResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceOauthAccessTokenResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BRERuleEngineActionsApiApiKeys {
}

export class BRERuleEngineActionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BRERuleEngineActionsApiApiKeys, value: string) {
        this.authentications[BRERuleEngineActionsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Get a list of available actions
     * @param filterCategory Filter for actions that are within a specific category
     * @param filterName Filter for actions that have names containing the given string
     * @param filterTags Filter for actions that have all of the given tags (comma separated list)
     * @param filterSearch Filter for actions containing the given words somewhere within name, description and tags
     */
    public getBREActions (filterCategory?: string, filterName?: string, filterTags?: string, filterSearch?: string) : Promise<{ response: http.ClientResponse; body: Array<ActionResource>;  }> {
        const localVarPath = this.basePath + '/bre/actions';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterCategory !== undefined) {
            queryParameters['filter_category'] = ObjectSerializer.serialize(filterCategory, "string");
        }

        if (filterName !== undefined) {
            queryParameters['filter_name'] = ObjectSerializer.serialize(filterName, "string");
        }

        if (filterTags !== undefined) {
            queryParameters['filter_tags'] = ObjectSerializer.serialize(filterTags, "string");
        }

        if (filterSearch !== undefined) {
            queryParameters['filter_search'] = ObjectSerializer.serialize(filterSearch, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<ActionResource>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ActionResource>");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BRERuleEngineCategoriesApiApiKeys {
}

export class BRERuleEngineCategoriesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BRERuleEngineCategoriesApiApiKeys, value: string) {
        this.authentications[BRERuleEngineCategoriesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * Templates define a type of BRE category and the properties they have
     * @summary Create a BRE category template
     * @param template The category template to create
     */
    public createBRECategoryTemplate (template?: TemplateResource) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/bre/categories/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(template, "TemplateResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete a BRE category template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    public deleteBRECategoryTemplate (id: string, cascade?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/bre/categories/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteBRECategoryTemplate.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = ObjectSerializer.serialize(cascade, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List categories
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getBRECategories (size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceBreCategoryResource;  }> {
        const localVarPath = this.basePath + '/bre/categories';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceBreCategoryResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceBreCategoryResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single category
     * @param name The category name
     */
    public getBRECategory (name: string) : Promise<{ response: http.ClientResponse; body: BreCategoryResource;  }> {
        const localVarPath = this.basePath + '/bre/categories/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getBRECategory.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BreCategoryResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BreCategoryResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single BRE category template
     * @param id The id of the template
     */
    public getBRECategoryTemplate (id: string) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/bre/categories/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getBRECategoryTemplate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List and search BRE category templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getBRECategoryTemplates (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }> {
        const localVarPath = this.basePath + '/bre/categories/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a category
     * @param name The category name
     * @param category The updated BRE category information
     */
    public updateBRECategory (name: string, category?: BreCategoryResource) : Promise<{ response: http.ClientResponse; body: BreCategoryResource;  }> {
        const localVarPath = this.basePath + '/bre/categories/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling updateBRECategory.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(category, "BreCategoryResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BreCategoryResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BreCategoryResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a BRE category template
     * @param id The id of the template
     * @param template The updated category template definition
     */
    public updateBRECategoryTemplate (id: string, template?: TemplateResource) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/bre/categories/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateBRECategoryTemplate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(template, "TemplateResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BRERuleEngineEventsApiApiKeys {
}

export class BRERuleEngineEventsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BRERuleEngineEventsApiApiKeys, value: string) {
        this.authentications[BRERuleEngineEventsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * Parameters within the event must match names and types from the trigger. Actual rule execution is asynchornous.  Returns request id, which will be used as the event id
     * @summary Fire a new event, based on an existing trigger
     * @param breEvent The BRE event object
     */
    public sendBREEvent (breEvent?: BreEvent) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/bre/events';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(breEvent, "BreEvent")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BRERuleEngineExpressionsApiApiKeys {
}

export class BRERuleEngineExpressionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BRERuleEngineExpressionsApiApiKeys, value: string) {
        this.authentications[BRERuleEngineExpressionsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * These are expression types that take a second expression as input and produce a value. These can be used in addition to the standard types, like parameter, global and constant (see BRE documentation for details).
     * @summary Get a list of 'lookup' type expressions
     */
    public getBREExpressions () : Promise<{ response: http.ClientResponse; body: Array<LookupTypeResource>;  }> {
        const localVarPath = this.basePath + '/bre/expressions/lookup';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<LookupTypeResource>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<LookupTypeResource>");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BRERuleEngineGlobalsApiApiKeys {
}

export class BRERuleEngineGlobalsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BRERuleEngineGlobalsApiApiKeys, value: string) {
        this.authentications[BRERuleEngineGlobalsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * Once created you can then use in a custom rule. Note that global definitions cannot be modified or deleted if in use.
     * @summary Create a global definition
     * @param breGlobalResource The BRE global resource object
     */
    public createBREGlobal (breGlobalResource?: BreGlobalResource) : Promise<{ response: http.ClientResponse; body: BreGlobalResource;  }> {
        const localVarPath = this.basePath + '/bre/globals/definitions';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(breGlobalResource, "BreGlobalResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BreGlobalResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BreGlobalResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * May fail if there are existing rules against it. Cannot delete core globals
     * @summary Delete a global
     * @param id The id of the global definition
     */
    public deleteBREGlobal (id: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/bre/globals/definitions/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteBREGlobal.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single global definition
     * @param id The id of the global definition
     */
    public getBREGlobal (id: string) : Promise<{ response: http.ClientResponse; body: BreGlobalResource;  }> {
        const localVarPath = this.basePath + '/bre/globals/definitions/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getBREGlobal.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BreGlobalResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BreGlobalResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List global definitions
     * @param filterSystem Filter for globals that are system globals when true, or not when false. Leave off for both mixed
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getBREGlobals (filterSystem?: boolean, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceBreGlobalResource;  }> {
        const localVarPath = this.basePath + '/bre/globals/definitions';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterSystem !== undefined) {
            queryParameters['filter_system'] = ObjectSerializer.serialize(filterSystem, "boolean");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceBreGlobalResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceBreGlobalResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * May fail if new parameters mismatch requirements of existing rules. Cannot update core globals
     * @summary Update a global definition
     * @param id The id of the global definition
     * @param breGlobalResource The BRE global resource object
     */
    public updateBREGlobal (id: string, breGlobalResource?: BreGlobalResource) : Promise<{ response: http.ClientResponse; body: BreGlobalResource;  }> {
        const localVarPath = this.basePath + '/bre/globals/definitions/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateBREGlobal.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(breGlobalResource, "BreGlobalResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BreGlobalResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BreGlobalResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BRERuleEngineRulesApiApiKeys {
}

export class BRERuleEngineRulesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BRERuleEngineRulesApiApiKeys, value: string) {
        this.authentications[BRERuleEngineRulesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * Rules define which actions to run when a given event verifies the specified conditions. Conditions and actions are defined by binding event or context parameters to arguments. Conditions also known as Predicates are logical expressions that result in a boolean. Operators are used to describe rules between arguments to form that condition. There are 3 families of operators: Boolean, Math and String. Math and String operators are functions that transform arguments into numbers or strings...<h1>Boolean Operators</h1><br /><br />1 arg:<br />======<br /><br /><ul> <li>IS_NULL</li> <li>IS_NOT_NULL</li> <li>STRING_IS_EMPTY</li> <li>NOT </li> <li>MAP_IS_EMPTY</li></ul><br />2 args:<br />=======<br /><br /><ul> <li>EQ</li> <li>NE (Not Equals)</li> <li>GT (Greater Than)</li> <li>GOE (Greater Or Equals)</li> <li>LT (Lesser Than)</li> <li>LOE (Lesser Or Equals)</li> <li>OR</li> <li>AND</li> <li>XNOR</li> <li>XOR</li> <li>CONTAINS_KEY (for maps only)</li> <li>CONTAINS_VALUE (for maps only)</li> <li>MATCHES (regex)</li> <li>MATCHES_IC (regex ignore case)</li> <li>STARTS_WITH</li> <li>STARTS_WITH_IC</li> <li>EQ_IGNORE_CASE</li> <li>ENDS_WITH</li> <li>ENDS_WITH_IC</li> <li>STRING_CONTAINS</li> <li>STRING_CONTAINS_IC</li> <li>LIKE (SQL like)</li></ul><br />3 args exceptions:<br />=================<br /><br /><ul> <li>BETWEEN</li></ul><br />n args:<br />=======<br /><br /><ul> <li>IN</li> <li>NOT_INT</li></ul><h1>Math Operators</h1>1 arg:<br />=====<br /><br /><ul> <li>NEGATE</li> <li>MAP_SIZE</li> <li>STRING_LENGTH</li> <li>CEIL</li> <li>ABS</li> <li>FLOOR</li> <li>ROUND</li> <li>RANDOM (no arg)</li> <li>RANDOM2 (seed arg)</li> <li>NUMCAST</li> <li>HOUR</li> <li>MINUTE</li> <li>SECOND</li> <li>MILLISECOND</li> <li>YEAR</li> <li>WEEK</li> <li>YEAR_MONTH</li> <li>YEAR_WEEK</li> <li>DAY_OF_WEEK</li> <li>DAY_OF_MONTH</li> <li>DAY_OF_YEAR</li> <li>WEEK</li> <li>WEEK</li> <li>WEEK</li></ul><br /><br />2 args:<br />======<br /><br /><ul> <li>ADD</li> <li>DIV</li> <li>MULT</li> <li>SUB</li> <li>POWER</li> <li>MOD</li> <li>LOCATE (index of (string, char))</li> <li>DIFF_YEARS</li> <li>DIFF_MONTHS</li> <li>DIFF_WEEKS</li> <li>DIFF_DAYS</li> <li>DIFF_HOURS</li> <li>DIFF_MINUTES</li> <li>DIFF_SECONDS</li></ul><br /><br />2 args:<br />======<br /><br /><ul> <li>MIN</li> <li>MAX</li></ul><h1>String Operators</h1>0 arg:<br />=====<br /><br /><ul> <li>CURRENT_TIME</li></ul><br /><br />1 arg:<br />=====<br /><br /><ul> <li>CURRENT_TIME</li> <li>LOWER</li> <li>UPPER</li> <li>TRIM</li> <li>STRING_CAST</li></ul><br /><br />2 args:<br />=====<br /><br /><ul> <li>CHAR_AT</li> <li>SUBSTR_1ARG (substr(string, start))</li> <li>CONCAT</li> <li>TRIM</li> <li>STRING_CAST</li></ul><br /><br />3 args:<br />=====<br /><br /><ul> <li>SUBSTR_2ARGS (substr(string, start, length))</li></ul>
     * @summary Create a rule
     * @param breRule The BRE rule object
     */
    public createBRERule (breRule?: BreRule) : Promise<{ response: http.ClientResponse; body: BreRule;  }> {
        const localVarPath = this.basePath + '/bre/rules';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(breRule, "BreRule")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BreRule;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BreRule");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * May fail if there are existing rules against it. Cannot delete core rules
     * @summary Delete a rule
     * @param id The id of the rule
     */
    public deleteBRERule (id: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/bre/rules/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteBRERule.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a string representation of the provided expression
     * @param expression The expression
     */
    public getBREExpressionAsString (expression?: Expressionobject) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/bre/rules/expression-as-string';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(expression, "Expressionobject")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single rule
     * @param id The id of the rule
     */
    public getBRERule (id: string) : Promise<{ response: http.ClientResponse; body: BreRule;  }> {
        const localVarPath = this.basePath + '/bre/rules/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getBRERule.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BreRule;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BreRule");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List rules
     * @param filterName Filter for rules containing the given name
     * @param filterEnabled Filter for rules by active status, null for both
     * @param filterSystem Filter for rules that are system rules when true, or not when false. Leave off for both mixed
     * @param filterTrigger Filter for rules that are for the trigger with the given name
     * @param filterAction Filter for rules that use the action with the given name
     * @param filterCondition Filter for rules that have a condition containing the given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getBRERules (filterName?: string, filterEnabled?: boolean, filterSystem?: boolean, filterTrigger?: string, filterAction?: string, filterCondition?: string, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceBreRule;  }> {
        const localVarPath = this.basePath + '/bre/rules';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterName !== undefined) {
            queryParameters['filter_name'] = ObjectSerializer.serialize(filterName, "string");
        }

        if (filterEnabled !== undefined) {
            queryParameters['filter_enabled'] = ObjectSerializer.serialize(filterEnabled, "boolean");
        }

        if (filterSystem !== undefined) {
            queryParameters['filter_system'] = ObjectSerializer.serialize(filterSystem, "boolean");
        }

        if (filterTrigger !== undefined) {
            queryParameters['filter_trigger'] = ObjectSerializer.serialize(filterTrigger, "string");
        }

        if (filterAction !== undefined) {
            queryParameters['filter_action'] = ObjectSerializer.serialize(filterAction, "string");
        }

        if (filterCondition !== undefined) {
            queryParameters['filter_condition'] = ObjectSerializer.serialize(filterCondition, "string");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceBreRule;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceBreRule");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This is helpful for turning off systems rules which cannot be deleted or modified otherwise
     * @summary Enable or disable a rule
     * @param id The id of the rule
     * @param enabled The boolean value
     */
    public setBRERule (id: string, enabled?: BooleanResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/bre/rules/{id}/enabled'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling setBRERule.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(enabled, "BooleanResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Cannot update system rules
     * @summary Update a rule
     * @param id The id of the rule
     * @param breRule The BRE rule object
     */
    public updateBRERule (id: string, breRule?: BreRule) : Promise<{ response: http.ClientResponse; body: BreRule;  }> {
        const localVarPath = this.basePath + '/bre/rules/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateBRERule.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(breRule, "BreRule")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BreRule;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BreRule");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BRERuleEngineTriggersApiApiKeys {
}

export class BRERuleEngineTriggersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BRERuleEngineTriggersApiApiKeys, value: string) {
        this.authentications[BRERuleEngineTriggersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * Customer added triggers will not be fired automatically or have rules associated with them by default. Custom rules must be added to get use from the trigger and it must then be fired from the outside. See the Bre Event services
     * @summary Create a trigger
     * @param breTriggerResource The BRE trigger resource object
     */
    public createBRETrigger (breTriggerResource?: BreTriggerResource) : Promise<{ response: http.ClientResponse; body: BreTriggerResource;  }> {
        const localVarPath = this.basePath + '/bre/triggers';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(breTriggerResource, "BreTriggerResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BreTriggerResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BreTriggerResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * May fail if there are existing rules against it. Cannot delete core triggers
     * @summary Delete a trigger
     * @param eventName The trigger event name
     */
    public deleteBRETrigger (eventName: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/bre/triggers/{event_name}'
            .replace('{' + 'event_name' + '}', String(eventName));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'eventName' is not null or undefined
        if (eventName === null || eventName === undefined) {
            throw new Error('Required parameter eventName was null or undefined when calling deleteBRETrigger.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single trigger
     * @param eventName The trigger event name
     */
    public getBRETrigger (eventName: string) : Promise<{ response: http.ClientResponse; body: BreTriggerResource;  }> {
        const localVarPath = this.basePath + '/bre/triggers/{event_name}'
            .replace('{' + 'event_name' + '}', String(eventName));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'eventName' is not null or undefined
        if (eventName === null || eventName === undefined) {
            throw new Error('Required parameter eventName was null or undefined when calling getBRETrigger.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BreTriggerResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BreTriggerResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List triggers
     * @param filterSystem Filter for triggers that are system triggers when true, or not when false. Leave off for both mixed
     * @param filterCategory Filter for triggers that are within a specific category
     * @param filterTags Filter for triggers that have all of the given tags (comma separated list)
     * @param filterName Filter for triggers that have names containing the given string
     * @param filterSearch Filter for triggers containing the given words somewhere within name, description and tags
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getBRETriggers (filterSystem?: boolean, filterCategory?: string, filterTags?: string, filterName?: string, filterSearch?: string, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceBreTriggerResource;  }> {
        const localVarPath = this.basePath + '/bre/triggers';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterSystem !== undefined) {
            queryParameters['filter_system'] = ObjectSerializer.serialize(filterSystem, "boolean");
        }

        if (filterCategory !== undefined) {
            queryParameters['filter_category'] = ObjectSerializer.serialize(filterCategory, "string");
        }

        if (filterTags !== undefined) {
            queryParameters['filter_tags'] = ObjectSerializer.serialize(filterTags, "string");
        }

        if (filterName !== undefined) {
            queryParameters['filter_name'] = ObjectSerializer.serialize(filterName, "string");
        }

        if (filterSearch !== undefined) {
            queryParameters['filter_search'] = ObjectSerializer.serialize(filterSearch, "string");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceBreTriggerResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceBreTriggerResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * May fail if new parameters mismatch requirements of existing rules. Cannot update core triggers
     * @summary Update a trigger
     * @param eventName The trigger event name
     * @param breTriggerResource The BRE trigger resource object
     */
    public updateBRETrigger (eventName: string, breTriggerResource?: BreTriggerResource) : Promise<{ response: http.ClientResponse; body: BreTriggerResource;  }> {
        const localVarPath = this.basePath + '/bre/triggers/{event_name}'
            .replace('{' + 'event_name' + '}', String(eventName));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'eventName' is not null or undefined
        if (eventName === null || eventName === undefined) {
            throw new Error('Required parameter eventName was null or undefined when calling updateBRETrigger.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(breTriggerResource, "BreTriggerResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BreTriggerResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BreTriggerResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BRERuleEngineVariablesApiApiKeys {
}

export class BRERuleEngineVariablesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BRERuleEngineVariablesApiApiKeys, value: string) {
        this.authentications[BRERuleEngineVariablesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * Types include integer, string, user and invoice. These are used to qualify trigger parameters and action variables with strong typing.
     * @summary Get a list of variable types available
     */
    public getBREVariableTypes () : Promise<{ response: http.ClientResponse; body: Array<VariableTypeResource>;  }> {
        const localVarPath = this.basePath + '/bre/variable-types';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<VariableTypeResource>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<VariableTypeResource>");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Used to lookup users to fill in a user constant for example. Only types marked as enumerable are suppoorted here.
     * @summary List valid values for a type
     * @param name The name of the type
     * @param filterName Filter results by those with names starting with this string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getBREVariableValues (name: string, filterName?: string, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceSimpleReferenceResourceobject;  }> {
        const localVarPath = this.basePath + '/bre/variable-types/{name}/values'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getBREVariableValues.');
        }

        if (filterName !== undefined) {
            queryParameters['filter_name'] = ObjectSerializer.serialize(filterName, "string");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceSimpleReferenceResourceobject;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceSimpleReferenceResourceobject");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CampaignsApiApiKeys {
}

export class CampaignsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CampaignsApiApiKeys, value: string) {
        this.authentications[CampaignsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Add a challenge to a campaign
     * @param id The id of the campaign
     * @param challengeId The id of the challenge
     */
    public addChallengeToCampaign (id: number, challengeId?: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/campaigns/{id}/challenges'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling addChallengeToCampaign.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(challengeId, "number")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a campaign
     * @param campaignResource The campaign resource object
     */
    public createCampaign (campaignResource?: CampaignResource) : Promise<{ response: http.ClientResponse; body: CampaignResource;  }> {
        const localVarPath = this.basePath + '/campaigns';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(campaignResource, "CampaignResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CampaignResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CampaignResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Campaign Templates define a type of campaign and the properties they have
     * @summary Create a campaign template
     * @param campaignTemplateResource The campaign template resource object
     */
    public createCampaignTemplate (campaignTemplateResource?: TemplateResource) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/campaigns/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(campaignTemplateResource, "TemplateResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a campaign
     * @param id The campaign id
     */
    public deleteCampaign (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/campaigns/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteCampaign.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete a campaign template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    public deleteCampaignTemplate (id: string, cascade?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/campaigns/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteCampaignTemplate.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = ObjectSerializer.serialize(cascade, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a single campaign
     * @param id The campaign id
     */
    public getCampaign (id: number) : Promise<{ response: http.ClientResponse; body: CampaignResource;  }> {
        const localVarPath = this.basePath + '/campaigns/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getCampaign.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CampaignResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CampaignResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List the challenges associated with a campaign
     * @param id The campaign id
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the challenge start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the challenge end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getCampaignChallenges (id: number, filterStartDate?: string, filterEndDate?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceChallengeResource;  }> {
        const localVarPath = this.basePath + '/campaigns/{id}/challenges'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getCampaignChallenges.');
        }

        if (filterStartDate !== undefined) {
            queryParameters['filter_start_date'] = ObjectSerializer.serialize(filterStartDate, "string");
        }

        if (filterEndDate !== undefined) {
            queryParameters['filter_end_date'] = ObjectSerializer.serialize(filterEndDate, "string");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceChallengeResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceChallengeResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single campaign template
     * @param id The id of the template
     */
    public getCampaignTemplate (id: string) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/campaigns/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getCampaignTemplate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List and search campaign templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getCampaignTemplates (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }> {
        const localVarPath = this.basePath + '/campaigns/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List and search campaigns
     * @param filterActive Filter for campaigns that are active
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getCampaigns (filterActive?: boolean, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceCampaignResource;  }> {
        const localVarPath = this.basePath + '/campaigns';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterActive !== undefined) {
            queryParameters['filter_active'] = ObjectSerializer.serialize(filterActive, "boolean");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceCampaignResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceCampaignResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Remove a challenge from a campaign
     * @param campaignId The campaign id
     * @param id The challenge id
     */
    public removeChallengeFromCampaign (campaignId: number, id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/campaigns/{campaign_id}/challenges/{id}'
            .replace('{' + 'campaign_id' + '}', String(campaignId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling removeChallengeFromCampaign.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling removeChallengeFromCampaign.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a campaign
     * @param id The campaign id
     * @param campaignResource The campaign resource object
     */
    public updateCampaign (id: number, campaignResource?: CampaignResource) : Promise<{ response: http.ClientResponse; body: CampaignResource;  }> {
        const localVarPath = this.basePath + '/campaigns/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateCampaign.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(campaignResource, "CampaignResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CampaignResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CampaignResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update an campaign template
     * @param id The id of the template
     * @param campaignTemplateResource The campaign template resource object
     */
    public updateCampaignTemplate (id: string, campaignTemplateResource?: TemplateResource) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/campaigns/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateCampaignTemplate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(campaignTemplateResource, "TemplateResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CampaignsChallengesApiApiKeys {
}

export class CampaignsChallengesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CampaignsChallengesApiApiKeys, value: string) {
        this.authentications[CampaignsChallengesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * Challenges do not run on their own.  They must be added to a campaign before events will spawn.
     * @summary Create a challenge
     * @param challengeResource The challenge resource object
     */
    public createChallenge (challengeResource?: ChallengeResource) : Promise<{ response: http.ClientResponse; body: ChallengeResource;  }> {
        const localVarPath = this.basePath + '/challenges';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(challengeResource, "ChallengeResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ChallengeResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ChallengeResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a challenge activity
     * @param challengeId The challenge id
     * @param challengeActivityResource The challenge activity resource object
     * @param validateSettings Whether to validate the settings being sent against the available settings on the base activity.
     */
    public createChallengeActivity (challengeId: number, challengeActivityResource?: ChallengeActivityResource, validateSettings?: boolean) : Promise<{ response: http.ClientResponse; body: ChallengeActivityResource;  }> {
        const localVarPath = this.basePath + '/challenges/{challenge_id}/activities'
            .replace('{' + 'challenge_id' + '}', String(challengeId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'challengeId' is not null or undefined
        if (challengeId === null || challengeId === undefined) {
            throw new Error('Required parameter challengeId was null or undefined when calling createChallengeActivity.');
        }

        if (validateSettings !== undefined) {
            queryParameters['validateSettings'] = ObjectSerializer.serialize(validateSettings, "boolean");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(challengeActivityResource, "ChallengeActivityResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ChallengeActivityResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ChallengeActivityResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Challenge Activity Templates define a type of challenge activity and the properties they have
     * @summary Create a challenge activity template
     * @param challengeActivityTemplateResource The challengeActivity template resource object
     */
    public createChallengeActivityTemplate (challengeActivityTemplateResource?: TemplateResource) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/challenge-activities/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(challengeActivityTemplateResource, "TemplateResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Challenge Templates define a type of challenge and the properties they have
     * @summary Create a challenge template
     * @param challengeTemplateResource The challenge template resource object
     */
    public createChallengeTemplate (challengeTemplateResource?: TemplateResource) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/challenges/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(challengeTemplateResource, "TemplateResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a challenge
     * @param id The challenge id
     */
    public deleteChallenge (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/challenges/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteChallenge.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A challenge can have multiple instances of the same activity and thus the id used is of the specific entry within the challenge
     * @summary Delete a challenge activity
     * @param id The challenge_activity id
     * @param challengeId The challenge id
     */
    public deleteChallengeActivity (id: number, challengeId: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/challenges/{challenge_id}/activities/{id}'
            .replace('{' + 'id' + '}', String(id))
            .replace('{' + 'challenge_id' + '}', String(challengeId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteChallengeActivity.');
        }

        // verify required parameter 'challengeId' is not null or undefined
        if (challengeId === null || challengeId === undefined) {
            throw new Error('Required parameter challengeId was null or undefined when calling deleteChallengeActivity.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete a challenge activity template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    public deleteChallengeActivityTemplate (id: string, cascade?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/challenge-activities/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteChallengeActivityTemplate.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = ObjectSerializer.serialize(cascade, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a challenge event
     * @param id The challenge event id
     */
    public deleteChallengeEvent (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/challenges/events/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteChallengeEvent.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete a challenge template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    public deleteChallengeTemplate (id: string, cascade?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/challenges/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteChallengeTemplate.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = ObjectSerializer.serialize(cascade, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve a challenge
     * @param id The challenge id
     */
    public getChallenge (id: number) : Promise<{ response: http.ClientResponse; body: ChallengeResource;  }> {
        const localVarPath = this.basePath + '/challenges/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getChallenge.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ChallengeResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ChallengeResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List and search challenge activities
     * @param challengeId The challenge id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getChallengeActivities (challengeId: number, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceBareChallengeActivityResource;  }> {
        const localVarPath = this.basePath + '/challenges/{challenge_id}/activities'
            .replace('{' + 'challenge_id' + '}', String(challengeId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'challengeId' is not null or undefined
        if (challengeId === null || challengeId === undefined) {
            throw new Error('Required parameter challengeId was null or undefined when calling getChallengeActivities.');
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceBareChallengeActivityResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceBareChallengeActivityResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A challenge can have multiple instances of the same activity and thus the id used is of the specific entry within the challenge
     * @summary Get a single challenge activity
     * @param id The challenge_activity id
     * @param challengeId The challenge id
     */
    public getChallengeActivity (id: number, challengeId: number) : Promise<{ response: http.ClientResponse; body: ChallengeActivityResource;  }> {
        const localVarPath = this.basePath + '/challenges/{challenge_id}/activities/{id}'
            .replace('{' + 'id' + '}', String(id))
            .replace('{' + 'challenge_id' + '}', String(challengeId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getChallengeActivity.');
        }

        // verify required parameter 'challengeId' is not null or undefined
        if (challengeId === null || challengeId === undefined) {
            throw new Error('Required parameter challengeId was null or undefined when calling getChallengeActivity.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ChallengeActivityResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ChallengeActivityResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single challenge activity template
     * @param id The id of the template
     */
    public getChallengeActivityTemplate (id: string) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/challenge-activities/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getChallengeActivityTemplate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List and search challenge activity templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getChallengeActivityTemplates (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }> {
        const localVarPath = this.basePath + '/challenge-activities/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve a single challenge event details
     * @param id The challenge event id
     */
    public getChallengeEvent (id: number) : Promise<{ response: http.ClientResponse; body: ChallengeEventResource;  }> {
        const localVarPath = this.basePath + '/challenges/events/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getChallengeEvent.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ChallengeEventResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ChallengeEventResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve a list of challenge events
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the event start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the event end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterCampaigns check only for events from currently running campaigns
     * @param filterChallenge check only for events from the challenge specified by id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getChallengeEvents (filterStartDate?: string, filterEndDate?: string, filterCampaigns?: boolean, filterChallenge?: number, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceChallengeEventResource;  }> {
        const localVarPath = this.basePath + '/challenges/events';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterStartDate !== undefined) {
            queryParameters['filter_start_date'] = ObjectSerializer.serialize(filterStartDate, "string");
        }

        if (filterEndDate !== undefined) {
            queryParameters['filter_end_date'] = ObjectSerializer.serialize(filterEndDate, "string");
        }

        if (filterCampaigns !== undefined) {
            queryParameters['filter_campaigns'] = ObjectSerializer.serialize(filterCampaigns, "boolean");
        }

        if (filterChallenge !== undefined) {
            queryParameters['filter_challenge'] = ObjectSerializer.serialize(filterChallenge, "number");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceChallengeEventResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceChallengeEventResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single challenge template
     * @param id The id of the template
     */
    public getChallengeTemplate (id: string) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/challenges/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getChallengeTemplate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List and search challenge templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getChallengeTemplates (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }> {
        const localVarPath = this.basePath + '/challenges/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve a list of challenges
     * @param filterTemplate Filter for challenges that are not tied to campaigns (templates)
     * @param filterActiveCampaign Filter for challenges that are tied to active campaigns
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the challenge start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the challenge end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getChallenges (filterTemplate?: boolean, filterActiveCampaign?: boolean, filterStartDate?: string, filterEndDate?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceChallengeResource;  }> {
        const localVarPath = this.basePath + '/challenges';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterTemplate !== undefined) {
            queryParameters['filter_template'] = ObjectSerializer.serialize(filterTemplate, "boolean");
        }

        if (filterActiveCampaign !== undefined) {
            queryParameters['filter_active_campaign'] = ObjectSerializer.serialize(filterActiveCampaign, "boolean");
        }

        if (filterStartDate !== undefined) {
            queryParameters['filter_start_date'] = ObjectSerializer.serialize(filterStartDate, "string");
        }

        if (filterEndDate !== undefined) {
            queryParameters['filter_end_date'] = ObjectSerializer.serialize(filterEndDate, "string");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceChallengeResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceChallengeResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * If the challenge is a copy, changes will propagate to all the related challenges
     * @summary Update a challenge
     * @param id The challenge id
     * @param challengeResource The challenge resource object
     */
    public updateChallenge (id: number, challengeResource?: ChallengeResource) : Promise<{ response: http.ClientResponse; body: ChallengeResource;  }> {
        const localVarPath = this.basePath + '/challenges/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateChallenge.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(challengeResource, "ChallengeResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ChallengeResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ChallengeResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A challenge can have multiple instances of the same activity and thus the id used is of the specific entry within the challenge
     * @summary Update a challenge activity
     * @param id The challenge_activity id
     * @param challengeId The challenge id
     * @param challengeActivityResource The challenge activity resource object
     */
    public updateChallengeActivity (id: number, challengeId: number, challengeActivityResource?: ChallengeActivityResource) : Promise<{ response: http.ClientResponse; body: ChallengeActivityResource;  }> {
        const localVarPath = this.basePath + '/challenges/{challenge_id}/activities/{id}'
            .replace('{' + 'id' + '}', String(id))
            .replace('{' + 'challenge_id' + '}', String(challengeId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateChallengeActivity.');
        }

        // verify required parameter 'challengeId' is not null or undefined
        if (challengeId === null || challengeId === undefined) {
            throw new Error('Required parameter challengeId was null or undefined when calling updateChallengeActivity.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(challengeActivityResource, "ChallengeActivityResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ChallengeActivityResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ChallengeActivityResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update an challenge activity template
     * @param id The id of the template
     * @param challengeActivityTemplateResource The challengeActivity template resource object
     */
    public updateChallengeActivityTemplate (id: string, challengeActivityTemplateResource?: TemplateResource) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/challenge-activities/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateChallengeActivityTemplate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(challengeActivityTemplateResource, "TemplateResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a challenge template
     * @param id The id of the template
     * @param challengeTemplateResource The challenge template resource object
     */
    public updateChallengeTemplate (id: string, challengeTemplateResource?: TemplateResource) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/challenges/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateChallengeTemplate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(challengeTemplateResource, "TemplateResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CampaignsRewardsApiApiKeys {
}

export class CampaignsRewardsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CampaignsRewardsApiApiKeys, value: string) {
        this.authentications[CampaignsRewardsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Create a reward set
     * @param rewardSetResource The reward set resource object
     */
    public createRewardSet (rewardSetResource?: RewardSetResource) : Promise<{ response: http.ClientResponse; body: RewardSetResource;  }> {
        const localVarPath = this.basePath + '/rewards';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(rewardSetResource, "RewardSetResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RewardSetResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RewardSetResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a reward set
     * @param id The reward id
     */
    public deleteRewardSet (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/rewards/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteRewardSet.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single reward set
     * @param id The reward id
     */
    public getRewardSet (id: number) : Promise<{ response: http.ClientResponse; body: RewardSetResource;  }> {
        const localVarPath = this.basePath + '/rewards/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getRewardSet.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RewardSetResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RewardSetResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List and search reward sets
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getRewardSets (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceRewardSetResource;  }> {
        const localVarPath = this.basePath + '/rewards';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceRewardSetResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceRewardSetResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a reward set
     * @param id The reward id
     * @param rewardSetResource The reward set resource object
     */
    public updateRewardSet (id: number, rewardSetResource?: RewardSetResource) : Promise<{ response: http.ClientResponse; body: RewardSetResource;  }> {
        const localVarPath = this.basePath + '/rewards/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateRewardSet.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(rewardSetResource, "RewardSetResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RewardSetResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RewardSetResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CategoriesApiApiKeys {
}

export class CategoriesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CategoriesApiApiKeys, value: string) {
        this.authentications[CategoriesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Create a new category
     * @param category The category to create
     */
    public createCategory (category?: CategoryResource) : Promise<{ response: http.ClientResponse; body: CategoryResource;  }> {
        const localVarPath = this.basePath + '/categories';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(category, "CategoryResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CategoryResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CategoryResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Templates define a type of category and the properties they have
     * @summary Create a category template
     * @param template The template to create
     */
    public createCategoryTemplate (template?: TemplateResource) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/categories/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(template, "TemplateResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete an existing category
     * @param id The id of the category to be deleted
     */
    public deleteCategory (id: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/categories/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteCategory.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete a category template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    public deleteCategoryTemplate (id: string, cascade?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/categories/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteCategoryTemplate.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = ObjectSerializer.serialize(cascade, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List and search categories with optional filters
     * @param filterSearch Filter for categories whose names begin with provided string
     * @param filterActive Filter for categories that are specifically active or inactive
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getCategories (filterSearch?: string, filterActive?: boolean, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceCategoryResource;  }> {
        const localVarPath = this.basePath + '/categories';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterSearch !== undefined) {
            queryParameters['filter_search'] = ObjectSerializer.serialize(filterSearch, "string");
        }

        if (filterActive !== undefined) {
            queryParameters['filter_active'] = ObjectSerializer.serialize(filterActive, "boolean");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceCategoryResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceCategoryResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single category
     * @param id The id of the category to retrieve
     */
    public getCategory (id: string) : Promise<{ response: http.ClientResponse; body: CategoryResource;  }> {
        const localVarPath = this.basePath + '/categories/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getCategory.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CategoryResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CategoryResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single category template
     * @param id The id of the template
     */
    public getCategoryTemplate (id: string) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/categories/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getCategoryTemplate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List and search category templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getCategoryTemplates (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }> {
        const localVarPath = this.basePath + '/categories/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List all trivia tags in the system
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getTags (size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourcestring;  }> {
        const localVarPath = this.basePath + '/tags';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourcestring;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourcestring");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update an existing category
     * @param id The id of the category
     * @param category The category to update
     */
    public updateCategory (id: string, category?: CategoryResource) : Promise<{ response: http.ClientResponse; body: CategoryResource;  }> {
        const localVarPath = this.basePath + '/categories/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateCategory.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(category, "CategoryResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CategoryResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CategoryResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a category template
     * @param id The id of the template
     * @param template The updated template information
     */
    public updateCategoryTemplate (id: string, template?: TemplateResource) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/categories/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateCategoryTemplate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(template, "TemplateResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ConfigsApiApiKeys {
}

export class ConfigsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ConfigsApiApiKeys, value: string) {
        this.authentications[ConfigsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Create a new config
     * @param config The config object
     */
    public createConfig (config?: Config) : Promise<{ response: http.ClientResponse; body: Config;  }> {
        const localVarPath = this.basePath + '/configs';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(config, "Config")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Config;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Config");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete an existing config
     * @param name The config name
     */
    public deleteConfig (name: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/configs/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteConfig.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Only configs that are public readable will be shown without admin access
     * @summary Get a single config
     * @param name The config name
     */
    public getConfig (name: string) : Promise<{ response: http.ClientResponse; body: Config;  }> {
        const localVarPath = this.basePath + '/configs/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getConfig.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Config;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Config");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List and search configs
     * @param filterSearch Filter for configs whose name contains the given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getConfigs (filterSearch?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceConfig;  }> {
        const localVarPath = this.basePath + '/configs';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterSearch !== undefined) {
            queryParameters['filter_search'] = ObjectSerializer.serialize(filterSearch, "string");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceConfig;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceConfig");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update an existing config
     * @param name The config name
     * @param config The config object
     */
    public updateConfig (name: string, config?: Config) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/configs/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling updateConfig.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(config, "Config")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ContentArticlesApiApiKeys {
}

export class ContentArticlesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ContentArticlesApiApiKeys, value: string) {
        this.authentications[ContentArticlesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * Articles are blobs of text with titles, a category and assets. Formatting and display of the text is in the hands of the front end.
     * @summary Create a new article
     * @param articleResource The new article
     */
    public createArticle (articleResource?: ArticleResource) : Promise<{ response: http.ClientResponse; body: ArticleResource;  }> {
        const localVarPath = this.basePath + '/content/articles';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(articleResource, "ArticleResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ArticleResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ArticleResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Article Templates define a type of article and the properties they have
     * @summary Create an article template
     * @param articleTemplateResource The article template resource object
     */
    public createArticleTemplate (articleTemplateResource?: TemplateResource) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/content/articles/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(articleTemplateResource, "TemplateResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete an existing article
     * @param id The article id
     */
    public deleteArticle (id: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/content/articles/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteArticle.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete an article template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    public deleteArticleTemplate (id: string, cascade?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/content/articles/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteArticleTemplate.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = ObjectSerializer.serialize(cascade, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single article
     * @param id The article id
     */
    public getArticle (id: string) : Promise<{ response: http.ClientResponse; body: ArticleResource;  }> {
        const localVarPath = this.basePath + '/content/articles/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getArticle.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ArticleResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ArticleResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single article template
     * @param id The id of the template
     */
    public getArticleTemplate (id: string) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/content/articles/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getArticleTemplate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List and search article templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getArticleTemplates (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }> {
        const localVarPath = this.basePath + '/content/articles/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of articles with optional filtering. Assets will not be filled in on the resources returned. Use 'Get a single article' to retrieve the full resource with assets for a given item as needed.
     * @summary List and search articles
     * @param filterCategory Filter for articles from a specific category by id
     * @param filterTagset Filter for articles with at least one of a specified set of tags (separated by comma)
     * @param filterTagIntersection Filter for articles with all of a specified set of tags (separated by comma)
     * @param filterTagExclusion Filter for articles with none of a specified set of tags (separated by comma)
     * @param filterTitle Filter for articles whose title contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getArticles (filterCategory?: string, filterTagset?: string, filterTagIntersection?: string, filterTagExclusion?: string, filterTitle?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceArticleResource;  }> {
        const localVarPath = this.basePath + '/content/articles';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterCategory !== undefined) {
            queryParameters['filter_category'] = ObjectSerializer.serialize(filterCategory, "string");
        }

        if (filterTagset !== undefined) {
            queryParameters['filter_tagset'] = ObjectSerializer.serialize(filterTagset, "string");
        }

        if (filterTagIntersection !== undefined) {
            queryParameters['filter_tag_intersection'] = ObjectSerializer.serialize(filterTagIntersection, "string");
        }

        if (filterTagExclusion !== undefined) {
            queryParameters['filter_tag_exclusion'] = ObjectSerializer.serialize(filterTagExclusion, "string");
        }

        if (filterTitle !== undefined) {
            queryParameters['filter_title'] = ObjectSerializer.serialize(filterTitle, "string");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceArticleResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceArticleResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update an existing article
     * @param id The article id
     * @param articleResource The article object
     */
    public updateArticle (id: string, articleResource?: ArticleResource) : Promise<{ response: http.ClientResponse; body: ArticleResource;  }> {
        const localVarPath = this.basePath + '/content/articles/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateArticle.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(articleResource, "ArticleResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ArticleResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ArticleResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update an article template
     * @param id The id of the template
     * @param articleTemplateResource The article template resource object
     */
    public updateArticleTemplate (id: string, articleTemplateResource?: TemplateResource) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/content/articles/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateArticleTemplate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(articleTemplateResource, "TemplateResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ContentCommentsApiApiKeys {
}

export class ContentCommentsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ContentCommentsApiApiKeys, value: string) {
        this.authentications[ContentCommentsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Add a new comment
     * @param commentResource The comment to be added
     */
    public addComment (commentResource?: CommentResource) : Promise<{ response: http.ClientResponse; body: CommentResource;  }> {
        const localVarPath = this.basePath + '/comments';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(commentResource, "CommentResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CommentResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CommentResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a comment
     * @param id The comment id
     */
    public deleteComment (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/comments/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteComment.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return a comment
     * @param id The comment id
     */
    public getComment (id: number) : Promise<{ response: http.ClientResponse; body: CommentResource;  }> {
        const localVarPath = this.basePath + '/comments/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getComment.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CommentResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CommentResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a page of comments
     * @param context Get comments by context type
     * @param contextId Get comments by context id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getComments (context: string, contextId: number, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceCommentResource;  }> {
        const localVarPath = this.basePath + '/comments';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'context' is not null or undefined
        if (context === null || context === undefined) {
            throw new Error('Required parameter context was null or undefined when calling getComments.');
        }

        // verify required parameter 'contextId' is not null or undefined
        if (contextId === null || contextId === undefined) {
            throw new Error('Required parameter contextId was null or undefined when calling getComments.');
        }

        if (context !== undefined) {
            queryParameters['context'] = ObjectSerializer.serialize(context, "string");
        }

        if (contextId !== undefined) {
            queryParameters['context_id'] = ObjectSerializer.serialize(contextId, "number");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceCommentResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceCommentResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * The body is an ElasticSearch query json. Please see their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html'>documentation</a> for details on the format and search options
     * @summary Search the comment index
     * @param query The search query
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public searchComments (query?: any, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: CommentSearch;  }> {
        const localVarPath = this.basePath + '/comments/search';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(query, "any")
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CommentSearch;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CommentSearch");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a comment
     * @param id The comment id
     * @param content The comment content
     */
    public updateComment (id: number, content?: StringWrapper) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/comments/{id}/content'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateComment.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(content, "StringWrapper")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ContentPollsApiApiKeys {
}

export class ContentPollsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ContentPollsApiApiKeys, value: string) {
        this.authentications[ContentPollsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Add your vote to a poll
     * @param id The poll id
     * @param answerKey The answer key
     */
    public answerPoll (id: string, answerKey?: StringWrapper) : Promise<{ response: http.ClientResponse; body: PollResponseResource;  }> {
        const localVarPath = this.basePath + '/media/polls/{id}/response'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling answerPoll.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(answerKey, "StringWrapper")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PollResponseResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PollResponseResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Polls are blobs of text with titles, a category and assets. Formatting and display of the text is in the hands of the front end.
     * @summary Create a new poll
     * @param pollResource The poll object
     */
    public createPoll (pollResource?: PollResource) : Promise<{ response: http.ClientResponse; body: PollResource;  }> {
        const localVarPath = this.basePath + '/media/polls';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(pollResource, "PollResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PollResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PollResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Poll templates define a type of poll and the properties they have
     * @summary Create a poll template
     * @param pollTemplateResource The poll template resource object
     */
    public createPollTemplate (pollTemplateResource?: TemplateResource) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/media/polls/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(pollTemplateResource, "TemplateResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete an existing poll
     * @param id The poll id
     */
    public deletePoll (id: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/media/polls/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deletePoll.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete a poll template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    public deletePollTemplate (id: string, cascade?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/media/polls/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deletePollTemplate.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = ObjectSerializer.serialize(cascade, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single poll
     * @param id The poll id
     */
    public getPoll (id: string) : Promise<{ response: http.ClientResponse; body: PollResource;  }> {
        const localVarPath = this.basePath + '/media/polls/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getPoll.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PollResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PollResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get poll answer
     * @param id The poll id
     */
    public getPollAnswer (id: string) : Promise<{ response: http.ClientResponse; body: PollResponseResource;  }> {
        const localVarPath = this.basePath + '/media/polls/{id}/response'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getPollAnswer.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PollResponseResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PollResponseResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single poll template
     * @param id The id of the template
     */
    public getPollTemplate (id: string) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/media/polls/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getPollTemplate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List and search poll templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getPollTemplates (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }> {
        const localVarPath = this.basePath + '/media/polls/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of polls with optional filtering. Assets will not be filled in on the resources returned. Use 'Get a single poll' to retrieve the full resource with assets for a given item as needed.
     * @summary List and search polls
     * @param filterCategory Filter for polls from a specific category by id
     * @param filterTagset Filter for polls with specified tags (separated by comma)
     * @param filterText Filter for polls whose text contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getPolls (filterCategory?: string, filterTagset?: string, filterText?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourcePollResource;  }> {
        const localVarPath = this.basePath + '/media/polls';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterCategory !== undefined) {
            queryParameters['filter_category'] = ObjectSerializer.serialize(filterCategory, "string");
        }

        if (filterTagset !== undefined) {
            queryParameters['filter_tagset'] = ObjectSerializer.serialize(filterTagset, "string");
        }

        if (filterText !== undefined) {
            queryParameters['filter_text'] = ObjectSerializer.serialize(filterText, "string");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourcePollResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourcePollResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update an existing poll
     * @param id The poll id
     * @param pollResource The poll object
     */
    public updatePoll (id: string, pollResource?: PollResource) : Promise<{ response: http.ClientResponse; body: PollResource;  }> {
        const localVarPath = this.basePath + '/media/polls/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updatePoll.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(pollResource, "PollResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PollResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PollResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a poll template
     * @param id The id of the template
     * @param pollTemplateResource The poll template resource object
     */
    public updatePollTemplate (id: string, pollTemplateResource?: TemplateResource) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/media/polls/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updatePollTemplate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(pollTemplateResource, "TemplateResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CurrenciesApiApiKeys {
}

export class CurrenciesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CurrenciesApiApiKeys, value: string) {
        this.authentications[CurrenciesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Create a currency
     * @param currency The currency object
     */
    public createCurrency (currency?: CurrencyResource) : Promise<{ response: http.ClientResponse; body: CurrencyResource;  }> {
        const localVarPath = this.basePath + '/currencies';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(currency, "CurrencyResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CurrencyResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CurrencyResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a currency
     * @param code The currency code
     */
    public deleteCurrency (code: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/currencies/{code}'
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling deleteCurrency.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List and search currencies
     * @param filterEnabledCurrencies Filter for alternate currencies setup explicitely in system config
     * @param filterType Filter currencies by type.  Allowable values: (&#39;virtual&#39;, &#39;real&#39;)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getCurrencies (filterEnabledCurrencies?: boolean, filterType?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceCurrencyResource;  }> {
        const localVarPath = this.basePath + '/currencies';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterEnabledCurrencies !== undefined) {
            queryParameters['filter_enabled_currencies'] = ObjectSerializer.serialize(filterEnabledCurrencies, "boolean");
        }

        if (filterType !== undefined) {
            queryParameters['filter_type'] = ObjectSerializer.serialize(filterType, "string");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceCurrencyResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceCurrencyResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single currency
     * @param code The currency code
     */
    public getCurrency (code: string) : Promise<{ response: http.ClientResponse; body: CurrencyResource;  }> {
        const localVarPath = this.basePath + '/currencies/{code}'
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling getCurrency.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CurrencyResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CurrencyResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a currency
     * @param code The currency code
     * @param currency The currency object
     */
    public updateCurrency (code: string, currency?: CurrencyResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/currencies/{code}'
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling updateCurrency.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(currency, "CurrencyResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DevicesApiApiKeys {
}

export class DevicesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DevicesApiApiKeys, value: string) {
        this.authentications[DevicesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Add device users
     * @param userResources userResources
     * @param id id
     */
    public addDeviceUsers (userResources: Array<SimpleUserResource>, id: number) : Promise<{ response: http.ClientResponse; body: DeviceResource;  }> {
        const localVarPath = this.basePath + '/devices/{id}/users'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userResources' is not null or undefined
        if (userResources === null || userResources === undefined) {
            throw new Error('Required parameter userResources was null or undefined when calling addDeviceUsers.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling addDeviceUsers.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(userResources, "Array<SimpleUserResource>")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeviceResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DeviceResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a device
     * @param device device
     */
    public createDevice (device: DeviceResource) : Promise<{ response: http.ClientResponse; body: DeviceResource;  }> {
        const localVarPath = this.basePath + '/devices';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'device' is not null or undefined
        if (device === null || device === undefined) {
            throw new Error('Required parameter device was null or undefined when calling createDevice.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(device, "DeviceResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeviceResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DeviceResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a device
     * @param id id
     */
    public deleteDevice (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/devices/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteDevice.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a device user
     * @param id The id of the device
     * @param userId The user id of the device user
     */
    public deleteDeviceUser (id: number, userId: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/devices/{id}/users/{user_id}'
            .replace('{' + 'id' + '}', String(id))
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteDeviceUser.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling deleteDeviceUser.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete all device users
     * @param id The id of the device
     * @param filterId Filter for device users to delete with a user id in a given comma separated list of ids
     */
    public deleteDeviceUsers (id: number, filterId?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/devices/{id}/users'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteDeviceUsers.');
        }

        if (filterId !== undefined) {
            queryParameters['filter_id'] = ObjectSerializer.serialize(filterId, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single device
     * @param id id
     */
    public getDevice (id: number) : Promise<{ response: http.ClientResponse; body: DeviceResource;  }> {
        const localVarPath = this.basePath + '/devices/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getDevice.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeviceResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DeviceResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of devices with optional filtering
     * @summary List and search devices
     * @param filterMake Filter for devices with specified make
     * @param filterModel Filter for devices with specified model
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getDevices (filterMake?: string, filterModel?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceDeviceResource;  }> {
        const localVarPath = this.basePath + '/devices';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterMake !== undefined) {
            queryParameters['filter_make'] = ObjectSerializer.serialize(filterMake, "string");
        }

        if (filterModel !== undefined) {
            queryParameters['filter_model'] = ObjectSerializer.serialize(filterModel, "string");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceDeviceResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceDeviceResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a device
     * @param device device
     * @param id id
     */
    public updateDevice (device: DeviceResource, id: number) : Promise<{ response: http.ClientResponse; body: DeviceResource;  }> {
        const localVarPath = this.basePath + '/devices/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'device' is not null or undefined
        if (device === null || device === undefined) {
            throw new Error('Required parameter device was null or undefined when calling updateDevice.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateDevice.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(device, "DeviceResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeviceResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DeviceResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DispositionsApiApiKeys {
}

export class DispositionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DispositionsApiApiKeys, value: string) {
        this.authentications[DispositionsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Add a new disposition
     * @param disposition The new disposition record
     */
    public addDisposition (disposition?: DispositionResource) : Promise<{ response: http.ClientResponse; body: DispositionResource;  }> {
        const localVarPath = this.basePath + '/dispositions';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(disposition, "DispositionResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DispositionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DispositionResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a disposition
     * @param id The id of the disposition record
     */
    public deleteDisposition (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/dispositions/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteDisposition.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a disposition
     * @param id The id of the disposition record
     */
    public getDisposition (id: number) : Promise<{ response: http.ClientResponse; body: DispositionResource;  }> {
        const localVarPath = this.basePath + '/dispositions/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getDisposition.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DispositionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DispositionResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a list of disposition counts
     * @param filterContext Filter for dispositions within a context type (games, articles, polls, etc). Optionally with a specific id like filter_context&#x3D;video:47
     * @param filterOwner Filter for dispositions from a specific user by id or &#39;me&#39;
     */
    public getDispositionCounts (filterContext?: string, filterOwner?: string) : Promise<{ response: http.ClientResponse; body: Array<DispositionCount>;  }> {
        const localVarPath = this.basePath + '/dispositions/count';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterContext !== undefined) {
            queryParameters['filter_context'] = ObjectSerializer.serialize(filterContext, "string");
        }

        if (filterOwner !== undefined) {
            queryParameters['filter_owner'] = ObjectSerializer.serialize(filterOwner, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<DispositionCount>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<DispositionCount>");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a page of dispositions
     * @param filterContext Filter for dispositions within a context type (games, articles, polls, etc). Optionally with a specific id like filter_context&#x3D;video:47
     * @param filterOwner Filter for dispositions from a specific user by id or &#39;me&#39;
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getDispositions (filterContext?: string, filterOwner?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceDispositionResource;  }> {
        const localVarPath = this.basePath + '/dispositions';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterContext !== undefined) {
            queryParameters['filter_context'] = ObjectSerializer.serialize(filterContext, "string");
        }

        if (filterOwner !== undefined) {
            queryParameters['filter_owner'] = ObjectSerializer.serialize(filterOwner, "string");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceDispositionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceDispositionResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum FulfillmentApiApiKeys {
}

export class FulfillmentApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: FulfillmentApiApiKeys, value: string) {
        this.authentications[FulfillmentApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Create a fulfillment type
     * @param type The fulfillment type
     */
    public createFulfillmentType (type?: FulfillmentType) : Promise<{ response: http.ClientResponse; body: FulfillmentType;  }> {
        const localVarPath = this.basePath + '/store/fulfillment/types';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(type, "FulfillmentType")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FulfillmentType;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FulfillmentType");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a fulfillment type
     * @param id The id
     */
    public deleteFulfillmentType (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/store/fulfillment/types/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteFulfillmentType.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single fulfillment type
     * @param id The id
     */
    public getFulfillmentType (id: number) : Promise<{ response: http.ClientResponse; body: FulfillmentType;  }> {
        const localVarPath = this.basePath + '/store/fulfillment/types/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getFulfillmentType.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FulfillmentType;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FulfillmentType");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List and search fulfillment types
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getFulfillmentTypes (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceFulfillmentType;  }> {
        const localVarPath = this.basePath + '/store/fulfillment/types';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceFulfillmentType;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceFulfillmentType");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a fulfillment type
     * @param id The id
     * @param fulfillmentType The fulfillment type
     */
    public updateFulfillmentType (id: number, fulfillmentType?: FulfillmentType) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/store/fulfillment/types/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateFulfillmentType.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(fulfillmentType, "FulfillmentType")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum GamificationAchievementsApiApiKeys {
}

export class GamificationAchievementsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: GamificationAchievementsApiApiKeys, value: string) {
        this.authentications[GamificationAchievementsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * If the definition contains a trigger event name, a BRE rule is created, so that tracking logic is executed when the triggering event occurs. If no trigger event name is specified, the user's achievement status must manually be updated via the API.
     * @summary Create a new achievement definition
     * @param achievement The achievement definition
     */
    public createAchievement (achievement?: AchievementDefinitionResource) : Promise<{ response: http.ClientResponse; body: AchievementDefinitionResource;  }> {
        const localVarPath = this.basePath + '/achievements';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(achievement, "AchievementDefinitionResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AchievementDefinitionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AchievementDefinitionResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Achievement templates define a type of achievement and the properties they have
     * @summary Create an achievement template
     * @param template The achievement template to be created
     */
    public createAchievementTemplate (template?: TemplateResource) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/achievements/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(template, "TemplateResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Will also disable the associated generated rule, if any.
     * @summary Delete an achievement definition
     * @param name The name of the achievement
     */
    public deleteAchievement (name: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/achievements/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteAchievement.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete an achievement template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    public deleteAchievementTemplate (id: string, cascade?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/achievements/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteAchievementTemplate.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = ObjectSerializer.serialize(cascade, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single achievement definition
     * @param name The name of the achievement
     */
    public getAchievement (name: string) : Promise<{ response: http.ClientResponse; body: AchievementDefinitionResource;  }> {
        const localVarPath = this.basePath + '/achievements/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getAchievement.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AchievementDefinitionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AchievementDefinitionResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single achievement template
     * @param id The id of the template
     */
    public getAchievementTemplate (id: string) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/achievements/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getAchievementTemplate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List and search achievement templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getAchievementTemplates (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }> {
        const localVarPath = this.basePath + '/achievements/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the list of triggers that can be used to trigger an achievement progress update
     */
    public getAchievementTriggers () : Promise<{ response: http.ClientResponse; body: Array<BreTriggerResource>;  }> {
        const localVarPath = this.basePath + '/achievements/triggers';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<BreTriggerResource>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<BreTriggerResource>");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all achievement definitions in the system
     * @param filterTagset Filter for achievements with specified tags (separated by comma)
     * @param filterName Filter for achievements whose name contains a string
     * @param filterHidden Filter for achievements that are hidden or not
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     * @param filterDerived Filter for achievements that are derived from other services
     */
    public getAchievements (filterTagset?: string, filterName?: string, filterHidden?: boolean, size?: number, page?: number, order?: string, filterDerived?: boolean) : Promise<{ response: http.ClientResponse; body: PageResourceAchievementDefinitionResource;  }> {
        const localVarPath = this.basePath + '/achievements';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterTagset !== undefined) {
            queryParameters['filter_tagset'] = ObjectSerializer.serialize(filterTagset, "string");
        }

        if (filterName !== undefined) {
            queryParameters['filter_name'] = ObjectSerializer.serialize(filterName, "string");
        }

        if (filterHidden !== undefined) {
            queryParameters['filter_hidden'] = ObjectSerializer.serialize(filterHidden, "boolean");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }

        if (filterDerived !== undefined) {
            queryParameters['filter_derived'] = ObjectSerializer.serialize(filterDerived, "boolean");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceAchievementDefinitionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceAchievementDefinitionResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Used by other services that depend on achievements
     * @summary Get a list of derived achievements
     * @param name The name of the derived achievement
     */
    public getDerivedAchievements (name: string) : Promise<{ response: http.ClientResponse; body: Array<AchievementDefinitionResource>;  }> {
        const localVarPath = this.basePath + '/achievements/derived/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getDerivedAchievements.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<AchievementDefinitionResource>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<AchievementDefinitionResource>");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Assets will not be filled in on the resources returned. Use 'Get a single poll' to retrieve the full resource with assets for a given item as needed.
     * @summary Retrieve progress on a given achievement for a given user
     * @param userId The user&#39;s id
     * @param achievementName The achievement&#39;s name
     */
    public getUserAchievementProgress (userId: number, achievementName: string) : Promise<{ response: http.ClientResponse; body: UserAchievementGroupResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/achievements/{achievement_name}'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'achievement_name' + '}', String(achievementName));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserAchievementProgress.');
        }

        // verify required parameter 'achievementName' is not null or undefined
        if (achievementName === null || achievementName === undefined) {
            throw new Error('Required parameter achievementName was null or undefined when calling getUserAchievementProgress.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserAchievementGroupResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserAchievementGroupResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Assets will not be filled in on the resources returned. Use 'Get a single poll' to retrieve the full resource with assets for a given item as needed.
     * @summary Retrieve progress on achievements for a given user
     * @param userId The user&#39;s id
     * @param filterAchievementDerived Filter for achievements that are derived from other services
     * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
     * @param filterAchievementName Filter for achievements whose name contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getUserAchievementsProgress (userId: number, filterAchievementDerived?: boolean, filterAchievementTagset?: string, filterAchievementName?: string, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceUserAchievementGroupResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/achievements'
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserAchievementsProgress.');
        }

        if (filterAchievementDerived !== undefined) {
            queryParameters['filter_achievement_derived'] = ObjectSerializer.serialize(filterAchievementDerived, "boolean");
        }

        if (filterAchievementTagset !== undefined) {
            queryParameters['filter_achievement_tagset'] = ObjectSerializer.serialize(filterAchievementTagset, "string");
        }

        if (filterAchievementName !== undefined) {
            queryParameters['filter_achievement_name'] = ObjectSerializer.serialize(filterAchievementName, "string");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceUserAchievementGroupResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceUserAchievementGroupResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Assets will not be filled in on the resources returned. Use 'Get single achievement progress for user' to retrieve the full resource with assets for a given user as needed.
     * @summary Retrieve progress on a given achievement for all users
     * @param achievementName The achievement&#39;s name
     * @param filterAchievementDerived Filter for achievements that are derived from other services
     * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
     * @param filterAchievementName Filter for achievements whose name contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getUsersAchievementProgress (achievementName: string, filterAchievementDerived?: boolean, filterAchievementTagset?: string, filterAchievementName?: string, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceUserAchievementGroupResource;  }> {
        const localVarPath = this.basePath + '/users/achievements/{achievement_name}'
            .replace('{' + 'achievement_name' + '}', String(achievementName));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'achievementName' is not null or undefined
        if (achievementName === null || achievementName === undefined) {
            throw new Error('Required parameter achievementName was null or undefined when calling getUsersAchievementProgress.');
        }

        if (filterAchievementDerived !== undefined) {
            queryParameters['filter_achievement_derived'] = ObjectSerializer.serialize(filterAchievementDerived, "boolean");
        }

        if (filterAchievementTagset !== undefined) {
            queryParameters['filter_achievement_tagset'] = ObjectSerializer.serialize(filterAchievementTagset, "string");
        }

        if (filterAchievementName !== undefined) {
            queryParameters['filter_achievement_name'] = ObjectSerializer.serialize(filterAchievementName, "string");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceUserAchievementGroupResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceUserAchievementGroupResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Assets will not be filled in on the resources returned. Use 'Get single achievement progress for user' to retrieve the full resource with assets for a given user as needed.
     * @summary Retrieve progress on achievements for all users
     * @param filterAchievementDerived Filter for achievements that are derived from other services
     * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
     * @param filterAchievementName Filter for achievements whose name contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getUsersAchievementsProgress (filterAchievementDerived?: boolean, filterAchievementTagset?: string, filterAchievementName?: string, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceUserAchievementGroupResource;  }> {
        const localVarPath = this.basePath + '/users/achievements';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterAchievementDerived !== undefined) {
            queryParameters['filter_achievement_derived'] = ObjectSerializer.serialize(filterAchievementDerived, "boolean");
        }

        if (filterAchievementTagset !== undefined) {
            queryParameters['filter_achievement_tagset'] = ObjectSerializer.serialize(filterAchievementTagset, "string");
        }

        if (filterAchievementName !== undefined) {
            queryParameters['filter_achievement_name'] = ObjectSerializer.serialize(filterAchievementName, "string");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceUserAchievementGroupResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceUserAchievementGroupResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * If no progress record yet exists for the user, it will be created. Otherwise it will be updated and the provided value added to the existing progress. May be negative. If progress meets or exceeds the achievement's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>.
     * @summary Increment an achievement progress record for a user
     * @param userId The user&#39;s id
     * @param achievementName The achievement&#39;s name
     * @param progress The amount to add to the progress value
     */
    public incrementAchievementProgress (userId: number, achievementName: string, progress?: IntWrapper) : Promise<{ response: http.ClientResponse; body: UserAchievementGroupResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/achievements/{achievement_name}/progress'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'achievement_name' + '}', String(achievementName));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling incrementAchievementProgress.');
        }

        // verify required parameter 'achievementName' is not null or undefined
        if (achievementName === null || achievementName === undefined) {
            throw new Error('Required parameter achievementName was null or undefined when calling incrementAchievementProgress.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(progress, "IntWrapper")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserAchievementGroupResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserAchievementGroupResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * If no progress record yet exists for the user, it will be created. Otherwise it will be updated and progress set to the provided value. If progress meets or exceeds the achievement's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>.
     * @summary Set an achievement progress record for a user
     * @param userId The user&#39;s id
     * @param achievementName The achievement&#39;s name
     * @param progress The new progress value
     */
    public setAchievementProgress (userId: number, achievementName: string, progress?: IntWrapper) : Promise<{ response: http.ClientResponse; body: UserAchievementGroupResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/achievements/{achievement_name}/progress'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'achievement_name' + '}', String(achievementName));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling setAchievementProgress.');
        }

        // verify required parameter 'achievementName' is not null or undefined
        if (achievementName === null || achievementName === undefined) {
            throw new Error('Required parameter achievementName was null or undefined when calling setAchievementProgress.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(progress, "IntWrapper")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserAchievementGroupResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserAchievementGroupResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * The existing generated rule, if any, will be deleted. A new rule will be created if a trigger event name is specified in the new version.
     * @summary Update an achievement definition
     * @param name The name of the achievement
     * @param achievement The achievement definition
     */
    public updateAchievement (name: string, achievement?: AchievementDefinitionResource) : Promise<{ response: http.ClientResponse; body: AchievementDefinitionResource;  }> {
        const localVarPath = this.basePath + '/achievements/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling updateAchievement.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(achievement, "AchievementDefinitionResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AchievementDefinitionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AchievementDefinitionResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update an achievement template
     * @param id The id of the template
     * @param template The updated template
     */
    public updateAchievementTemplate (id: string, template?: TemplateResource) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/achievements/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateAchievementTemplate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(template, "TemplateResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum GamificationLeaderboardsApiApiKeys {
}

export class GamificationLeaderboardsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: GamificationLeaderboardsApiApiKeys, value: string) {
        this.authentications[GamificationLeaderboardsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * The context type identifies the type of entity (i.e., 'activity') being tracked on the leaderboard. The context ID is the unique ID of the actual entity tracked by the leaderboard. Sorting is based on the fields of LeaderboardEntryResource rather than the returned LeaderboardResource.
     * @summary Retrieves leaderboard details and paginated entries
     * @param contextType The context type for the leaderboard
     * @param contextId The context id for the leaderboard
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getLeaderboard (contextType: string, contextId: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: LeaderboardResource;  }> {
        const localVarPath = this.basePath + '/leaderboards/{context_type}/{context_id}'
            .replace('{' + 'context_type' + '}', String(contextType))
            .replace('{' + 'context_id' + '}', String(contextId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'contextType' is not null or undefined
        if (contextType === null || contextType === undefined) {
            throw new Error('Required parameter contextType was null or undefined when calling getLeaderboard.');
        }

        // verify required parameter 'contextId' is not null or undefined
        if (contextId === null || contextId === undefined) {
            throw new Error('Required parameter contextId was null or undefined when calling getLeaderboard.');
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LeaderboardResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LeaderboardResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * The context type identifies the type of entity (i.e., 'activity') being tracked on the leaderboard. The context ID is the unique ID of the actual entity tracked by the leaderboard
     * @summary Retrieves a specific user entry with rank
     * @param contextType The context type for the leaderboard
     * @param contextId The context id for the leaderboard
     * @param id The id of a user
     */
    public getLeaderboardRank (contextType: string, contextId: string, id: string) : Promise<{ response: http.ClientResponse; body: LeaderboardEntryResource;  }> {
        const localVarPath = this.basePath + '/leaderboards/{context_type}/{context_id}/users/{id}/rank'
            .replace('{' + 'context_type' + '}', String(contextType))
            .replace('{' + 'context_id' + '}', String(contextId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'contextType' is not null or undefined
        if (contextType === null || contextType === undefined) {
            throw new Error('Required parameter contextType was null or undefined when calling getLeaderboardRank.');
        }

        // verify required parameter 'contextId' is not null or undefined
        if (contextId === null || contextId === undefined) {
            throw new Error('Required parameter contextId was null or undefined when calling getLeaderboardRank.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getLeaderboardRank.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LeaderboardEntryResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LeaderboardEntryResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a list of available leaderboard strategy names
     */
    public getLeaderboardStrategies () : Promise<{ response: http.ClientResponse; body: Array<string>;  }> {
        const localVarPath = this.basePath + '/leaderboards/strategies';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<string>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<string>");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum GamificationLevelingApiApiKeys {
}

export class GamificationLevelingApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: GamificationLevelingApiApiKeys, value: string) {
        this.authentications[GamificationLevelingApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Create a level schema
     * @param level The level schema definition
     */
    public createLevel (level?: LevelingResource) : Promise<{ response: http.ClientResponse; body: LevelingResource;  }> {
        const localVarPath = this.basePath + '/leveling';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(level, "LevelingResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LevelingResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LevelingResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a level
     * @param name The level schema name
     */
    public deleteLevel (name: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/leveling/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteLevel.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve a level
     * @param name The level schema name
     */
    public getLevel (name: string) : Promise<{ response: http.ClientResponse; body: LevelingResource;  }> {
        const localVarPath = this.basePath + '/leveling/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getLevel.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LevelingResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LevelingResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the list of triggers that can be used to trigger a leveling progress update
     */
    public getLevelTriggers () : Promise<{ response: http.ClientResponse; body: Array<BreTriggerResource>;  }> {
        const localVarPath = this.basePath + '/leveling/triggers';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<BreTriggerResource>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<BreTriggerResource>");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of levels schemas with optional filtering
     * @summary List and search levels
     * @param filterName Filter for level schemas whose name contains a given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getLevels (filterName?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceLevelingResource;  }> {
        const localVarPath = this.basePath + '/leveling';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterName !== undefined) {
            queryParameters['filter_name'] = ObjectSerializer.serialize(filterName, "string");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceLevelingResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceLevelingResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a user's progress for a given level schema
     * @param userId The id of the user
     * @param name The level schema name
     */
    public getUserLevel (userId: number, name: string) : Promise<{ response: http.ClientResponse; body: UserLevelingResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/leveling/{name}'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserLevel.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getUserLevel.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserLevelingResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserLevelingResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Filtering and sorting is based on the LevelingResource object, not the UserLevelingResource that is returned here.
     * @summary Get a user's progress for all level schemas
     * @param userId The id of the user
     * @param filterName Filter for level schemas whose name contains a given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getUserLevels (userId: number, filterName?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceUserLevelingResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/leveling'
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserLevels.');
        }

        if (filterName !== undefined) {
            queryParameters['filter_name'] = ObjectSerializer.serialize(filterName, "string");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceUserLevelingResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceUserLevelingResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * If no progress record yet exists for the user, it will be created. Otherwise the provided value will be added to it. May be negative. If progress meets or exceeds the level's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>.
     * @summary Update or create a leveling progress record for a user
     * @param userId The id of the user
     * @param name The level schema name
     * @param progress The amount of progress to add
     */
    public incrementProgress (userId: number, name: string, progress?: IntWrapper) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/leveling/{name}/progress'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling incrementProgress.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling incrementProgress.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(progress, "IntWrapper")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * If no progress record yet exists for the user, it will be created. Otherwise it will be updated to the provided value. If progress meets or exceeds the level's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>.
     * @summary Set leveling progress for a user
     * @param userId The id of the user
     * @param name The level schema name
     * @param progress The new progress amount
     */
    public setProgress (userId: number, name: string, progress?: IntWrapper) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/leveling/{name}/progress'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling setProgress.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling setProgress.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(progress, "IntWrapper")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a level
     * @param name The level schema name
     * @param newLevel The level schema definition
     */
    public updateLevel (name: string, newLevel?: LevelingResource) : Promise<{ response: http.ClientResponse; body: LevelingResource;  }> {
        const localVarPath = this.basePath + '/leveling/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling updateLevel.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(newLevel, "LevelingResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LevelingResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LevelingResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum GamificationMetricsApiApiKeys {
}

export class GamificationMetricsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: GamificationMetricsApiApiKeys, value: string) {
        this.authentications[GamificationMetricsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * Post a new score/stat for an activity occurrence without ending the occurrence itself
     * @summary Add a metric
     * @param metric The new metric
     */
    public addMetric (metric?: MetricResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/metrics';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(metric, "MetricResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum GamificationTriviaApiApiKeys {
}

export class GamificationTriviaApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: GamificationTriviaApiApiKeys, value: string) {
        this.authentications[GamificationTriviaApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Add an answer to a question
     * @param questionId The id of the question
     * @param answer The new answer
     */
    public addQuestionAnswers (questionId: string, answer?: AnswerResource) : Promise<{ response: http.ClientResponse; body: AnswerResource;  }> {
        const localVarPath = this.basePath + '/trivia/questions/{question_id}/answers'
            .replace('{' + 'question_id' + '}', String(questionId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'questionId' is not null or undefined
        if (questionId === null || questionId === undefined) {
            throw new Error('Required parameter questionId was null or undefined when calling addQuestionAnswers.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(answer, "AnswerResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AnswerResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AnswerResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add a tag to a question
     * @param id The id of the question
     * @param tag The new tag
     */
    public addQuestionTag (id: string, tag?: StringWrapper) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/trivia/questions/{id}/tags'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling addQuestionTag.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(tag, "StringWrapper")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * All questions that dont't have the tag and match filters will have it added. The returned number is the number of questions updated.
     * @summary Add a tag to a batch of questions
     * @param tag The tag to add
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTag Filter for questions with specified tag
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    public addTagToQuestionsBatch (tag?: StringWrapper, filterSearch?: string, filterIdset?: string, filterCategory?: string, filterTag?: string, filterTagset?: string, filterType?: string, filterPublished?: boolean, filterImportId?: number) : Promise<{ response: http.ClientResponse; body: number;  }> {
        const localVarPath = this.basePath + '/trivia/questions/tags';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterSearch !== undefined) {
            queryParameters['filter_search'] = ObjectSerializer.serialize(filterSearch, "string");
        }

        if (filterIdset !== undefined) {
            queryParameters['filter_idset'] = ObjectSerializer.serialize(filterIdset, "string");
        }

        if (filterCategory !== undefined) {
            queryParameters['filter_category'] = ObjectSerializer.serialize(filterCategory, "string");
        }

        if (filterTag !== undefined) {
            queryParameters['filter_tag'] = ObjectSerializer.serialize(filterTag, "string");
        }

        if (filterTagset !== undefined) {
            queryParameters['filter_tagset'] = ObjectSerializer.serialize(filterTagset, "string");
        }

        if (filterType !== undefined) {
            queryParameters['filter_type'] = ObjectSerializer.serialize(filterType, "string");
        }

        if (filterPublished !== undefined) {
            queryParameters['filter_published'] = ObjectSerializer.serialize(filterPublished, "boolean");
        }

        if (filterImportId !== undefined) {
            queryParameters['filter_import_id'] = ObjectSerializer.serialize(filterImportId, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(tag, "StringWrapper")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: number;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "number");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set up a job to import a set of trivia questions from a cvs file at a remote url. the file will be validated asynchronously but will not be processed until started manually with the process endpoint.
     * @summary Create an import job
     * @param request The new import job
     */
    public createImportJob (request?: ImportJobResource) : Promise<{ response: http.ClientResponse; body: ImportJobResource;  }> {
        const localVarPath = this.basePath + '/trivia/import';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "ImportJobResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ImportJobResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ImportJobResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a question
     * @param question The new question
     */
    public createQuestion (question?: QuestionResource) : Promise<{ response: http.ClientResponse; body: QuestionResource;  }> {
        const localVarPath = this.basePath + '/trivia/questions';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(question, "QuestionResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: QuestionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "QuestionResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Question templates define a type of question and the properties they have
     * @summary Create a question template
     * @param questionTemplateResource The question template resource object
     */
    public createQuestionTemplate (questionTemplateResource?: QuestionTemplateResource) : Promise<{ response: http.ClientResponse; body: QuestionTemplateResource;  }> {
        const localVarPath = this.basePath + '/trivia/questions/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(questionTemplateResource, "QuestionTemplateResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: QuestionTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "QuestionTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Also deletes all questions that were imported by it
     * @summary Delete an import job
     * @param id The id of the job
     */
    public deleteImportJob (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/trivia/import/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteImportJob.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a question
     * @param id The id of the question
     */
    public deleteQuestion (id: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/trivia/questions/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteQuestion.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Remove an answer from a question
     * @param questionId The id of the question
     * @param id The id of the answer
     */
    public deleteQuestionAnswers (questionId: string, id: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/trivia/questions/{question_id}/answers/{id}'
            .replace('{' + 'question_id' + '}', String(questionId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'questionId' is not null or undefined
        if (questionId === null || questionId === undefined) {
            throw new Error('Required parameter questionId was null or undefined when calling deleteQuestionAnswers.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteQuestionAnswers.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete a question template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    public deleteQuestionTemplate (id: string, cascade?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/trivia/questions/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteQuestionTemplate.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = ObjectSerializer.serialize(cascade, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get an import job
     * @param id The id of the job
     */
    public getImportJob (id: number) : Promise<{ response: http.ClientResponse; body: ImportJobResource;  }> {
        const localVarPath = this.basePath + '/trivia/import/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getImportJob.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ImportJobResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ImportJobResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a list of import job
     * @param filterVendor Filter for jobs by vendor id
     * @param filterCategory Filter for jobs by category id
     * @param filterName Filter for jobs which name *STARTS* with the given string
     * @param filterStatus Filter for jobs that are in a specific set of statuses (comma separated)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getImportJobs (filterVendor?: string, filterCategory?: string, filterName?: string, filterStatus?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceImportJobResource;  }> {
        const localVarPath = this.basePath + '/trivia/import';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterVendor !== undefined) {
            queryParameters['filter_vendor'] = ObjectSerializer.serialize(filterVendor, "string");
        }

        if (filterCategory !== undefined) {
            queryParameters['filter_category'] = ObjectSerializer.serialize(filterCategory, "string");
        }

        if (filterName !== undefined) {
            queryParameters['filter_name'] = ObjectSerializer.serialize(filterName, "string");
        }

        if (filterStatus !== undefined) {
            queryParameters['filter_status'] = ObjectSerializer.serialize(filterStatus, "string");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceImportJobResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceImportJobResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single question
     * @param id The id of the question
     */
    public getQuestion (id: string) : Promise<{ response: http.ClientResponse; body: QuestionResource;  }> {
        const localVarPath = this.basePath + '/trivia/questions/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getQuestion.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: QuestionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "QuestionResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get an answer for a question
     * @param questionId The id of the question
     * @param id The id of the answer
     */
    public getQuestionAnswer (questionId: string, id: string) : Promise<{ response: http.ClientResponse; body: AnswerResource;  }> {
        const localVarPath = this.basePath + '/trivia/questions/{question_id}/answers/{id}'
            .replace('{' + 'question_id' + '}', String(questionId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'questionId' is not null or undefined
        if (questionId === null || questionId === undefined) {
            throw new Error('Required parameter questionId was null or undefined when calling getQuestionAnswer.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getQuestionAnswer.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AnswerResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AnswerResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List the answers available for a question
     * @param questionId The id of the question
     */
    public getQuestionAnswers (questionId: string) : Promise<{ response: http.ClientResponse; body: Array<AnswerResource>;  }> {
        const localVarPath = this.basePath + '/trivia/questions/{question_id}/answers'
            .replace('{' + 'question_id' + '}', String(questionId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'questionId' is not null or undefined
        if (questionId === null || questionId === undefined) {
            throw new Error('Required parameter questionId was null or undefined when calling getQuestionAnswers.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<AnswerResource>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<AnswerResource>");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * The 'since' parameter is important to avoid getting a full list of all questions. Implementors should make sure they pass the updated date of the last resource loaded, not the date of the last request, in order to avoid gaps
     * @summary List question deltas in ascending order of updated date
     * @param since Timestamp in seconds
     */
    public getQuestionDeltas (since?: number) : Promise<{ response: http.ClientResponse; body: Array<DeltaResource>;  }> {
        const localVarPath = this.basePath + '/trivia/questions/delta';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (since !== undefined) {
            queryParameters['since'] = ObjectSerializer.serialize(since, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<DeltaResource>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<DeltaResource>");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List the tags for a question
     * @param id The id of the question
     */
    public getQuestionTags (id: string) : Promise<{ response: http.ClientResponse; body: Array<string>;  }> {
        const localVarPath = this.basePath + '/trivia/questions/{id}/tags'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getQuestionTags.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<string>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<string>");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single question template
     * @param id The id of the template
     */
    public getQuestionTemplate (id: string) : Promise<{ response: http.ClientResponse; body: QuestionTemplateResource;  }> {
        const localVarPath = this.basePath + '/trivia/questions/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getQuestionTemplate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: QuestionTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "QuestionTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List and search question templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getQuestionTemplates (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceQuestionTemplateResource;  }> {
        const localVarPath = this.basePath + '/trivia/questions/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceQuestionTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceQuestionTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List and search questions
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterTag Filter for questions with specified tag
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    public getQuestions (size?: number, page?: number, order?: string, filterSearch?: string, filterIdset?: string, filterCategory?: string, filterTagset?: string, filterTag?: string, filterType?: string, filterPublished?: boolean, filterImportId?: number) : Promise<{ response: http.ClientResponse; body: PageResourceQuestionResource;  }> {
        const localVarPath = this.basePath + '/trivia/questions';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }

        if (filterSearch !== undefined) {
            queryParameters['filter_search'] = ObjectSerializer.serialize(filterSearch, "string");
        }

        if (filterIdset !== undefined) {
            queryParameters['filter_idset'] = ObjectSerializer.serialize(filterIdset, "string");
        }

        if (filterCategory !== undefined) {
            queryParameters['filter_category'] = ObjectSerializer.serialize(filterCategory, "string");
        }

        if (filterTagset !== undefined) {
            queryParameters['filter_tagset'] = ObjectSerializer.serialize(filterTagset, "string");
        }

        if (filterTag !== undefined) {
            queryParameters['filter_tag'] = ObjectSerializer.serialize(filterTag, "string");
        }

        if (filterType !== undefined) {
            queryParameters['filter_type'] = ObjectSerializer.serialize(filterType, "string");
        }

        if (filterPublished !== undefined) {
            queryParameters['filter_published'] = ObjectSerializer.serialize(filterPublished, "boolean");
        }

        if (filterImportId !== undefined) {
            queryParameters['filter_import_id'] = ObjectSerializer.serialize(filterImportId, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceQuestionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceQuestionResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This is also provided by the list endpoint so you don't need to call this for pagination purposes
     * @summary Count questions based on filters
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTag Filter for questions with specified tag
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     */
    public getQuestionsCount (filterSearch?: string, filterIdset?: string, filterCategory?: string, filterTag?: string, filterTagset?: string, filterType?: string, filterPublished?: boolean) : Promise<{ response: http.ClientResponse; body: number;  }> {
        const localVarPath = this.basePath + '/trivia/questions/count';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterSearch !== undefined) {
            queryParameters['filter_search'] = ObjectSerializer.serialize(filterSearch, "string");
        }

        if (filterIdset !== undefined) {
            queryParameters['filter_idset'] = ObjectSerializer.serialize(filterIdset, "string");
        }

        if (filterCategory !== undefined) {
            queryParameters['filter_category'] = ObjectSerializer.serialize(filterCategory, "string");
        }

        if (filterTag !== undefined) {
            queryParameters['filter_tag'] = ObjectSerializer.serialize(filterTag, "string");
        }

        if (filterTagset !== undefined) {
            queryParameters['filter_tagset'] = ObjectSerializer.serialize(filterTagset, "string");
        }

        if (filterType !== undefined) {
            queryParameters['filter_type'] = ObjectSerializer.serialize(filterType, "string");
        }

        if (filterPublished !== undefined) {
            queryParameters['filter_published'] = ObjectSerializer.serialize(filterPublished, "boolean");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: number;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "number");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Will process the CSV file and add new questions asynchronously. The status of the job must be 'VALID'.
     * @summary Start processing an import job
     * @param id The id of the job
     * @param publishNow Whether the new questions should be published live immediately
     */
    public processImportJob (id: number, publishNow: boolean) : Promise<{ response: http.ClientResponse; body: ImportJobResource;  }> {
        const localVarPath = this.basePath + '/trivia/import/{id}/process'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling processImportJob.');
        }

        // verify required parameter 'publishNow' is not null or undefined
        if (publishNow === null || publishNow === undefined) {
            throw new Error('Required parameter publishNow was null or undefined when calling processImportJob.');
        }

        if (publishNow !== undefined) {
            queryParameters['publish_now'] = ObjectSerializer.serialize(publishNow, "boolean");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ImportJobResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ImportJobResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Remove a tag from a question
     * @param id The id of the question
     * @param tag The tag to remove
     */
    public removeQuestionTag (id: string, tag: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/trivia/questions/{id}/tags/{tag}'
            .replace('{' + 'id' + '}', String(id))
            .replace('{' + 'tag' + '}', String(tag));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling removeQuestionTag.');
        }

        // verify required parameter 'tag' is not null or undefined
        if (tag === null || tag === undefined) {
            throw new Error('Required parameter tag was null or undefined when calling removeQuestionTag.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * ll questions that have the tag and match filters will have it removed. The returned number is the number of questions updated.
     * @summary Remove a tag from a batch of questions
     * @param tag The tag to remove
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTag Filter for questions with specified tag
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    public removeTagToQuestionsBatch (tag: string, filterSearch?: string, filterIdset?: string, filterCategory?: string, filterTag?: string, filterTagset?: string, filterType?: string, filterPublished?: boolean, filterImportId?: number) : Promise<{ response: http.ClientResponse; body: number;  }> {
        const localVarPath = this.basePath + '/trivia/questions/tags/{tag}'
            .replace('{' + 'tag' + '}', String(tag));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tag' is not null or undefined
        if (tag === null || tag === undefined) {
            throw new Error('Required parameter tag was null or undefined when calling removeTagToQuestionsBatch.');
        }

        if (filterSearch !== undefined) {
            queryParameters['filter_search'] = ObjectSerializer.serialize(filterSearch, "string");
        }

        if (filterIdset !== undefined) {
            queryParameters['filter_idset'] = ObjectSerializer.serialize(filterIdset, "string");
        }

        if (filterCategory !== undefined) {
            queryParameters['filter_category'] = ObjectSerializer.serialize(filterCategory, "string");
        }

        if (filterTag !== undefined) {
            queryParameters['filter_tag'] = ObjectSerializer.serialize(filterTag, "string");
        }

        if (filterTagset !== undefined) {
            queryParameters['filter_tagset'] = ObjectSerializer.serialize(filterTagset, "string");
        }

        if (filterType !== undefined) {
            queryParameters['filter_type'] = ObjectSerializer.serialize(filterType, "string");
        }

        if (filterPublished !== undefined) {
            queryParameters['filter_published'] = ObjectSerializer.serialize(filterPublished, "boolean");
        }

        if (filterImportId !== undefined) {
            queryParameters['filter_import_id'] = ObjectSerializer.serialize(filterImportId, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: number;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "number");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * For performance reasons, search & category filters are mutually exclusive. If category is specified, search filter will be ignored in order to do fast matches for typeahead.
     * @summary List and search tags by the beginning of the string
     * @param filterSearch Filter for tags starting with the given text
     * @param filterCategory Filter for tags on questions from a specific category
     * @param filterImportId Filter for tags on questions from a specific import job
     */
    public searchQuestionTags (filterSearch?: string, filterCategory?: string, filterImportId?: number) : Promise<{ response: http.ClientResponse; body: Collectionstring;  }> {
        const localVarPath = this.basePath + '/trivia/tags';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterSearch !== undefined) {
            queryParameters['filter_search'] = ObjectSerializer.serialize(filterSearch, "string");
        }

        if (filterCategory !== undefined) {
            queryParameters['filter_category'] = ObjectSerializer.serialize(filterCategory, "string");
        }

        if (filterImportId !== undefined) {
            queryParameters['filter_import_id'] = ObjectSerializer.serialize(filterImportId, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Collectionstring;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Collectionstring");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Changes should be made before process is started for there to be any effect.
     * @summary Update an import job
     * @param id The id of the job
     * @param request The updated job
     */
    public updateImportJob (id: number, request?: ImportJobResource) : Promise<{ response: http.ClientResponse; body: ImportJobResource;  }> {
        const localVarPath = this.basePath + '/trivia/import/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateImportJob.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "ImportJobResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ImportJobResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ImportJobResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a question
     * @param id The id of the question
     * @param question The updated question
     */
    public updateQuestion (id: string, question?: QuestionResource) : Promise<{ response: http.ClientResponse; body: QuestionResource;  }> {
        const localVarPath = this.basePath + '/trivia/questions/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateQuestion.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(question, "QuestionResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: QuestionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "QuestionResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update an answer for a question
     * @param questionId The id of the question
     * @param id The id of the answer
     * @param answer The updated answer
     */
    public updateQuestionAnswer (questionId: string, id: string, answer?: AnswerResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/trivia/questions/{question_id}/answers/{id}'
            .replace('{' + 'question_id' + '}', String(questionId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'questionId' is not null or undefined
        if (questionId === null || questionId === undefined) {
            throw new Error('Required parameter questionId was null or undefined when calling updateQuestionAnswer.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateQuestionAnswer.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(answer, "AnswerResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a question template
     * @param id The id of the template
     * @param questionTemplateResource The question template resource object
     */
    public updateQuestionTemplate (id: string, questionTemplateResource?: QuestionTemplateResource) : Promise<{ response: http.ClientResponse; body: QuestionTemplateResource;  }> {
        const localVarPath = this.basePath + '/trivia/questions/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateQuestionTemplate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(questionTemplateResource, "QuestionTemplateResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: QuestionTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "QuestionTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Will update all questions that match filters used (or all questions in system if no filters used). Body should match a question resource with only those properties you wish to set. Null values will be ignored. Returned number is how many were updated.
     * @summary Bulk update questions
     * @param question New values for a set of question fields
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    public updateQuestionsInBulk (question?: QuestionResource, filterSearch?: string, filterIdset?: string, filterCategory?: string, filterTagset?: string, filterType?: string, filterPublished?: boolean, filterImportId?: number) : Promise<{ response: http.ClientResponse; body: number;  }> {
        const localVarPath = this.basePath + '/trivia/questions';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterSearch !== undefined) {
            queryParameters['filter_search'] = ObjectSerializer.serialize(filterSearch, "string");
        }

        if (filterIdset !== undefined) {
            queryParameters['filter_idset'] = ObjectSerializer.serialize(filterIdset, "string");
        }

        if (filterCategory !== undefined) {
            queryParameters['filter_category'] = ObjectSerializer.serialize(filterCategory, "string");
        }

        if (filterTagset !== undefined) {
            queryParameters['filter_tagset'] = ObjectSerializer.serialize(filterTagset, "string");
        }

        if (filterType !== undefined) {
            queryParameters['filter_type'] = ObjectSerializer.serialize(filterType, "string");
        }

        if (filterPublished !== undefined) {
            queryParameters['filter_published'] = ObjectSerializer.serialize(filterPublished, "boolean");
        }

        if (filterImportId !== undefined) {
            queryParameters['filter_import_id'] = ObjectSerializer.serialize(filterImportId, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(question, "QuestionResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: number;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "number");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum InvoicesApiApiKeys {
}

export class InvoicesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: InvoicesApiApiKeys, value: string) {
        this.authentications[InvoicesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * Create an invoice(s) by providing a cart GUID. Note that there may be multiple invoices created, one per vendor.
     * @summary Create an invoice
     * @param req Invoice to be created
     */
    public createInvoice (req?: InvoiceCreateRequest) : Promise<{ response: http.ClientResponse; body: Array<InvoiceResource>;  }> {
        const localVarPath = this.basePath + '/invoices';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(req, "InvoiceCreateRequest")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<InvoiceResource>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<InvoiceResource>");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Lists available fulfillment statuses
     */
    public getFulFillmentStatuses () : Promise<{ response: http.ClientResponse; body: Array<string>;  }> {
        const localVarPath = this.basePath + '/invoices/fulfillment-statuses';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<string>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<string>");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve an invoice
     * @param id The id of the invoice
     */
    public getInvoice (id: number) : Promise<{ response: http.ClientResponse; body: InvoiceResource;  }> {
        const localVarPath = this.basePath + '/invoices/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getInvoice.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InvoiceResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InvoiceResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List invoice logs
     * @param id The id of the invoice
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getInvoiceLogs (id: number, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceInvoiceLogEntry;  }> {
        const localVarPath = this.basePath + '/invoices/{id}/logs'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getInvoiceLogs.');
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceInvoiceLogEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceInvoiceLogEntry");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Without INVOICES_ADMIN permission the results are automatically filtered for only the logged in user's invoices. It is recomended however that filter_user be added to avoid issues for admin users accidentally getting additional invoices.
     * @summary Retrieve invoices
     * @param filterUser The id of a user to get invoices for. Automtically added if not being called with admin permissions.
     * @param filterEmail Filters invoices by customer&#39;s email. Admins only.
     * @param filterFulfillmentStatus Filters invoices by fulfillment status type. Can be a comma separated list of statuses
     * @param filterPaymentStatus Filters invoices by payment status type. Can be a comma separated list of statuses
     * @param filterItemName Filters invoices by item name containing the given string
     * @param filterExternalRef Filters invoices by external reference.
     * @param filterCreatedDate Filters invoices by creation date. Multiple values possible for range search. Format: filter_created_date&#x3D;OP,ts&amp;... where OP in (GT, LT, GOE, LOE, EQ) and ts is a unix timestamp in seconds. Ex: filter_created_date&#x3D;GT,1452154258,LT,1554254874
     * @param filterVendorIds Filters invoices for ones from one of the vendors whose id is in the given comma separated list
     * @param filterCurrency Filters invoices by currency. ISO3 currency code
     * @param filterShippingStateName Filters invoices by shipping address: Exact match state name
     * @param filterShippingCountryName Filters invoices by shipping address: Exact match country name
     * @param filterShipping Filters invoices by shipping price. Multiple values possible for range search. Format: filter_shipping&#x3D;OP,ts&amp;... where OP in (GT, LT, GOE, LOE, EQ). Ex: filter_shipping&#x3D;GT,14.58,LT,15.54
     * @param filterVendorName Filters invoices by vendor name starting with given string
     * @param filterSku Filters invoices by item sku
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getInvoices (filterUser?: number, filterEmail?: string, filterFulfillmentStatus?: string, filterPaymentStatus?: string, filterItemName?: string, filterExternalRef?: string, filterCreatedDate?: string, filterVendorIds?: string, filterCurrency?: string, filterShippingStateName?: string, filterShippingCountryName?: string, filterShipping?: string, filterVendorName?: string, filterSku?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceInvoiceResource;  }> {
        const localVarPath = this.basePath + '/invoices';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterUser !== undefined) {
            queryParameters['filter_user'] = ObjectSerializer.serialize(filterUser, "number");
        }

        if (filterEmail !== undefined) {
            queryParameters['filter_email'] = ObjectSerializer.serialize(filterEmail, "string");
        }

        if (filterFulfillmentStatus !== undefined) {
            queryParameters['filter_fulfillment_status'] = ObjectSerializer.serialize(filterFulfillmentStatus, "string");
        }

        if (filterPaymentStatus !== undefined) {
            queryParameters['filter_payment_status'] = ObjectSerializer.serialize(filterPaymentStatus, "string");
        }

        if (filterItemName !== undefined) {
            queryParameters['filter_item_name'] = ObjectSerializer.serialize(filterItemName, "string");
        }

        if (filterExternalRef !== undefined) {
            queryParameters['filter_external_ref'] = ObjectSerializer.serialize(filterExternalRef, "string");
        }

        if (filterCreatedDate !== undefined) {
            queryParameters['filter_created_date'] = ObjectSerializer.serialize(filterCreatedDate, "string");
        }

        if (filterVendorIds !== undefined) {
            queryParameters['filter_vendor_ids'] = ObjectSerializer.serialize(filterVendorIds, "string");
        }

        if (filterCurrency !== undefined) {
            queryParameters['filter_currency'] = ObjectSerializer.serialize(filterCurrency, "string");
        }

        if (filterShippingStateName !== undefined) {
            queryParameters['filter_shipping_state_name'] = ObjectSerializer.serialize(filterShippingStateName, "string");
        }

        if (filterShippingCountryName !== undefined) {
            queryParameters['filter_shipping_country_name'] = ObjectSerializer.serialize(filterShippingCountryName, "string");
        }

        if (filterShipping !== undefined) {
            queryParameters['filter_shipping'] = ObjectSerializer.serialize(filterShipping, "string");
        }

        if (filterVendorName !== undefined) {
            queryParameters['filter_vendor_name'] = ObjectSerializer.serialize(filterVendorName, "string");
        }

        if (filterSku !== undefined) {
            queryParameters['filter_sku'] = ObjectSerializer.serialize(filterSku, "string");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceInvoiceResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceInvoiceResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Lists available payment statuses
     */
    public getPaymentStatuses () : Promise<{ response: http.ClientResponse; body: Array<string>;  }> {
        const localVarPath = this.basePath + '/invoices/payment-statuses';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<string>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<string>");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Pay an invoice using a saved payment method
     * @param id The id of the invoice
     * @param request The payment method details. Will default to the appropriate user&#39;s wallet in the invoice currency if ommited.
     */
    public payInvoice (id: number, request?: PayBySavedMethodRequest) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/invoices/{id}/payments'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling payInvoice.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "PayBySavedMethodRequest")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This allows external fulfillment systems to report success or failure. Fulfillment status changes are restricted by a specific flow determining which status can lead to which.
     * @summary Set the fulfillment status of a bundled invoice item
     * @param id The id of the invoice
     * @param bundleSku The sku of the bundle in the invoice that contains the given target
     * @param sku The sku of an item in the bundle in the invoice
     * @param status The new fulfillment status for the item. Additional options may be available based on configuration.  Allowable values:  &#39;unfulfilled&#39;, &#39;fulfilled&#39;, &#39;not fulfillable&#39;, &#39;failed&#39;, &#39;processing&#39;, &#39;failed_permanent&#39;, &#39;delayed&#39;
     */
    public setBundledInvoiceItemFulfillmentStatus (id: number, bundleSku: string, sku: string, status: StringWrapper) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/invoices/{id}/items/{bundleSku}/bundled-skus/{sku}/fulfillment-status'
            .replace('{' + 'id' + '}', String(id))
            .replace('{' + 'bundleSku' + '}', String(bundleSku))
            .replace('{' + 'sku' + '}', String(sku));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling setBundledInvoiceItemFulfillmentStatus.');
        }

        // verify required parameter 'bundleSku' is not null or undefined
        if (bundleSku === null || bundleSku === undefined) {
            throw new Error('Required parameter bundleSku was null or undefined when calling setBundledInvoiceItemFulfillmentStatus.');
        }

        // verify required parameter 'sku' is not null or undefined
        if (sku === null || sku === undefined) {
            throw new Error('Required parameter sku was null or undefined when calling setBundledInvoiceItemFulfillmentStatus.');
        }

        // verify required parameter 'status' is not null or undefined
        if (status === null || status === undefined) {
            throw new Error('Required parameter status was null or undefined when calling setBundledInvoiceItemFulfillmentStatus.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(status, "StringWrapper")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set the external reference of an invoice
     * @param id The id of the invoice
     * @param externalRef External reference info
     */
    public setExternalRef (id: number, externalRef?: StringWrapper) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/invoices/{id}/external-ref'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling setExternalRef.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(externalRef, "StringWrapper")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This allows external fulfillment systems to report success or failure. Fulfillment status changes are restricted by a specific flow determining which status can lead to which.
     * @summary Set the fulfillment status of an invoice item
     * @param id The id of the invoice
     * @param sku The sku of an item in the invoice
     * @param status The new fulfillment status for the item. Additional options may be available based on configuration.  Allowable values:  &#39;unfulfilled&#39;, &#39;fulfilled&#39;, &#39;not fulfillable&#39;, &#39;failed&#39;, &#39;processing&#39;, &#39;failed_permanent&#39;, &#39;delayed&#39;
     */
    public setInvoiceItemFulfillmentStatus (id: number, sku: string, status: StringWrapper) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/invoices/{id}/items/{sku}/fulfillment-status'
            .replace('{' + 'id' + '}', String(id))
            .replace('{' + 'sku' + '}', String(sku));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling setInvoiceItemFulfillmentStatus.');
        }

        // verify required parameter 'sku' is not null or undefined
        if (sku === null || sku === undefined) {
            throw new Error('Required parameter sku was null or undefined when calling setInvoiceItemFulfillmentStatus.');
        }

        // verify required parameter 'status' is not null or undefined
        if (status === null || status === undefined) {
            throw new Error('Required parameter status was null or undefined when calling setInvoiceItemFulfillmentStatus.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(status, "StringWrapper")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set the order notes of an invoice
     * @param id The id of the invoice
     * @param orderNotes Payment status info
     */
    public setOrderNotes (id: number, orderNotes?: StringWrapper) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/invoices/{id}/order-notes'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling setOrderNotes.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(orderNotes, "StringWrapper")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This may trigger fulfillment if setting the status to 'paid'. This is mainly intended to support external payment systems that cannot be incorporated into the payment method system. Payment status changes are restricted by a specific flow determining which status can lead to which.
     * @summary Set the payment status of an invoice
     * @param id The id of the invoice
     * @param request Payment status info
     */
    public setPaymentStatus (id: number, request?: InvoicePaymentStatusRequest) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/invoices/{id}/payment-status'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling setPaymentStatus.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "InvoicePaymentStatusRequest")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set or update billing info
     * @param id The id of the invoice
     * @param billingInfoRequest Address info
     */
    public updateBillingInfo (id: number, billingInfoRequest?: AddressResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/invoices/{id}/billing-address'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateBillingInfo.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(billingInfoRequest, "AddressResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LocationsApiApiKeys {
}

export class LocationsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LocationsApiApiKeys, value: string) {
        this.authentications[LocationsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Get a list of countries
     */
    public getCountries () : Promise<{ response: http.ClientResponse; body: Array<CountryResource>;  }> {
        const localVarPath = this.basePath + '/location/countries';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<CountryResource>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<CountryResource>");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Determined by geo ip location
     * @summary Get the iso3 code of your country
     */
    public getCountryByGeoLocation () : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/location/geolocation/country';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a list of a country's states
     * @param countryCodeIso3 The iso3 code of the country
     */
    public getCountryStates (countryCodeIso3: string) : Promise<{ response: http.ClientResponse; body: Array<StateResource>;  }> {
        const localVarPath = this.basePath + '/location/countries/{country_code_iso3}/states'
            .replace('{' + 'country_code_iso3' + '}', String(countryCodeIso3));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'countryCodeIso3' is not null or undefined
        if (countryCodeIso3 === null || countryCodeIso3 === undefined) {
            throw new Error('Required parameter countryCodeIso3 was null or undefined when calling getCountryStates.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<StateResource>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<StateResource>");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Determined by geo ip location, currency to country mapping and a fallback setting
     * @summary Get the currency information of your country
     */
    public getCurrencyByGeoLocation () : Promise<{ response: http.ClientResponse; body: CurrencyResource;  }> {
        const localVarPath = this.basePath + '/location/geolocation/currency';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CurrencyResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CurrencyResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LogsApiApiKeys {
}

export class LogsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LogsApiApiKeys, value: string) {
        this.authentications[LogsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Add a user log entry
     * @param logEntry The user log entry to be added
     */
    public addUserLog (logEntry?: UserActionLog) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/audit/logs';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(logEntry, "UserActionLog")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get an existing BRE event log entry by id
     * @param id The BRE event log entry id
     */
    public getBREEventLog (id: string) : Promise<{ response: http.ClientResponse; body: BreEventLog;  }> {
        const localVarPath = this.basePath + '/bre/logs/event-log/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getBREEventLog.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BreEventLog;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BreEventLog");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a list of BRE event log entries
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the event log start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEventName Filter event logs by event name
     * @param filterEventId Filter event logs by request id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getBREEventLogs (filterStartDate?: string, filterEventName?: string, filterEventId?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceBreEventLog;  }> {
        const localVarPath = this.basePath + '/bre/logs/event-log';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterStartDate !== undefined) {
            queryParameters['filter_start_date'] = ObjectSerializer.serialize(filterStartDate, "string");
        }

        if (filterEventName !== undefined) {
            queryParameters['filter_event_name'] = ObjectSerializer.serialize(filterEventName, "string");
        }

        if (filterEventId !== undefined) {
            queryParameters['filter_event_id'] = ObjectSerializer.serialize(filterEventId, "string");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceBreEventLog;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceBreEventLog");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get an existing forward log entry by id
     * @param id The forward log entry id
     */
    public getBREForwardLog (id: string) : Promise<{ response: http.ClientResponse; body: ForwardLog;  }> {
        const localVarPath = this.basePath + '/bre/logs/forward-log/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getBREForwardLog.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ForwardLog;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ForwardLog");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a list of forward log entries
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the log end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterStatusCode Filter forward logs by http status code
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getBREForwardLogs (filterStartDate?: string, filterEndDate?: string, filterStatusCode?: number, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceForwardLog;  }> {
        const localVarPath = this.basePath + '/bre/logs/forward-log';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterStartDate !== undefined) {
            queryParameters['filter_start_date'] = ObjectSerializer.serialize(filterStartDate, "string");
        }

        if (filterEndDate !== undefined) {
            queryParameters['filter_end_date'] = ObjectSerializer.serialize(filterEndDate, "string");
        }

        if (filterStatusCode !== undefined) {
            queryParameters['filter_status_code'] = ObjectSerializer.serialize(filterStatusCode, "number");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceForwardLog;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceForwardLog");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a user log entry by id
     * @param id The user log entry id
     */
    public getUserLog (id: string) : Promise<{ response: http.ClientResponse; body: UserActionLog;  }> {
        const localVarPath = this.basePath + '/audit/logs/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getUserLog.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserActionLog;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserActionLog");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a page of user logs entries
     * @param filterUser Filter for actions taken by a specific user by id
     * @param filterActionName Filter for actions of a specific name
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getUserLogs (filterUser?: number, filterActionName?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceUserActionLog;  }> {
        const localVarPath = this.basePath + '/audit/logs';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterUser !== undefined) {
            queryParameters['filter_user'] = ObjectSerializer.serialize(filterUser, "number");
        }

        if (filterActionName !== undefined) {
            queryParameters['filter_action_name'] = ObjectSerializer.serialize(filterActionName, "string");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceUserActionLog;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceUserActionLog");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MediaArtistsApiApiKeys {
}

export class MediaArtistsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MediaArtistsApiApiKeys, value: string) {
        this.authentications[MediaArtistsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * Adds a new artist in the system. Use specific media contributions endpoint to add contributions
     * @summary Adds a new artist in the system
     * @param artistResource The new artist
     */
    public addArtist (artistResource?: ArtistResource) : Promise<{ response: http.ClientResponse; body: ArtistResource;  }> {
        const localVarPath = this.basePath + '/media/artists';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(artistResource, "ArtistResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ArtistResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ArtistResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Artist Templates define a type of artist and the properties they have
     * @summary Create an artist template
     * @param artistTemplateResource The artist template resource object
     */
    public createArtistTemplate (artistTemplateResource?: TemplateResource) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/media/artists/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(artistTemplateResource, "TemplateResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Removes an artist from the system IF no resources are attached to it
     * @param id The artist id
     */
    public deleteArtist (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/media/artists/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteArtist.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete an artist template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    public deleteArtistTemplate (id: string, cascade?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/media/artists/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteArtistTemplate.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = ObjectSerializer.serialize(cascade, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Loads a specific artist details
     * @param id The artist id
     * @param showContributions The number of contributions to show fetch
     */
    public getArtist (id: number, showContributions?: number) : Promise<{ response: http.ClientResponse; body: ArtistResource;  }> {
        const localVarPath = this.basePath + '/media/artists/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getArtist.');
        }

        if (showContributions !== undefined) {
            queryParameters['show_contributions'] = ObjectSerializer.serialize(showContributions, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ArtistResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ArtistResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single artist template
     * @param id The id of the template
     */
    public getArtistTemplate (id: string) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/media/artists/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getArtistTemplate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List and search artist templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getArtistTemplates (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }> {
        const localVarPath = this.basePath + '/media/artists/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Search for artists
     * @param filterArtistsByName Filter for artists which name *STARTS* with the given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getArtists (filterArtistsByName?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceArtistResource;  }> {
        const localVarPath = this.basePath + '/media/artists';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterArtistsByName !== undefined) {
            queryParameters['filter_artists_by_name'] = ObjectSerializer.serialize(filterArtistsByName, "string");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceArtistResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceArtistResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Modifies an artist details
     * @param id The artist id
     * @param artistResource The new artist
     */
    public updateArtist (id: number, artistResource?: ArtistResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/media/artists/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateArtist.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(artistResource, "ArtistResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update an artist template
     * @param id The id of the template
     * @param artistTemplateResource The artist template resource object
     */
    public updateArtistTemplate (id: string, artistTemplateResource?: TemplateResource) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/media/artists/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateArtistTemplate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(artistTemplateResource, "TemplateResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MediaModerationApiApiKeys {
}

export class MediaModerationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MediaModerationApiApiKeys, value: string) {
        this.authentications[MediaModerationApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Get a flag report
     * @param id The flag report id
     */
    public getModerationReport (id: number) : Promise<{ response: http.ClientResponse; body: FlagReportResource;  }> {
        const localVarPath = this.basePath + '/moderation/reports/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getModerationReport.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FlagReportResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlagReportResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Context can be either a free-form string or a pre-defined context name
     * @summary Returns a page of flag reports
     * @param excludeResolved Ignore resolved context
     * @param filterContext Filter by moderation context
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getModerationReports (excludeResolved?: boolean, filterContext?: string, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceFlagReportResource;  }> {
        const localVarPath = this.basePath + '/moderation/reports';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (excludeResolved !== undefined) {
            queryParameters['exclude_resolved'] = ObjectSerializer.serialize(excludeResolved, "boolean");
        }

        if (filterContext !== undefined) {
            queryParameters['filter_context'] = ObjectSerializer.serialize(filterContext, "string");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceFlagReportResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceFlagReportResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Lets you set the resolution of a report. Resolution types is {banned,ignore} in case of 'banned' you will need to pass the reason.
     * @summary Update a flag report
     * @param id The flag report id
     * @param flagReportResource The new flag report
     */
    public updateModerationReport (id: number, flagReportResource?: FlagReportResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/moderation/reports/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateModerationReport.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(flagReportResource, "FlagReportResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MediaVideosApiApiKeys {
}

export class MediaVideosApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MediaVideosApiApiKeys, value: string) {
        this.authentications[MediaVideosApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * Whitelisted users can view video regardless of privacy setting.
     * @summary Adds a user to a video's whitelist
     * @param id The video id
     * @param userId The user id
     */
    public addUserToVideoWhitelist (id: number, userId?: IntWrapper) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/media/videos/{id}/whitelist'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling addUserToVideoWhitelist.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(userId, "IntWrapper")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a new video in the system
     * @param videoResource The video object
     */
    public addVideo (videoResource?: VideoResource) : Promise<{ response: http.ClientResponse; body: VideoResource;  }> {
        const localVarPath = this.basePath + '/media/videos';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(videoResource, "VideoResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VideoResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "VideoResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add a new video comment
     * @param videoId The video id 
     * @param commentResource The comment object
     */
    public addVideoComment (videoId: number, commentResource?: CommentResource) : Promise<{ response: http.ClientResponse; body: CommentResource;  }> {
        const localVarPath = this.basePath + '/media/videos/{video_id}/comments'
            .replace('{' + 'video_id' + '}', String(videoId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'videoId' is not null or undefined
        if (videoId === null || videoId === undefined) {
            throw new Error('Required parameter videoId was null or undefined when calling addVideoComment.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(commentResource, "CommentResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CommentResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CommentResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a contributor to a video
     * @param videoId The video id
     * @param contributionResource The contribution object
     */
    public addVideoContributor (videoId: number, contributionResource?: ContributionResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/media/videos/{video_id}/contributors'
            .replace('{' + 'video_id' + '}', String(videoId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'videoId' is not null or undefined
        if (videoId === null || videoId === undefined) {
            throw new Error('Required parameter videoId was null or undefined when calling addVideoContributor.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(contributionResource, "ContributionResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add a new flag
     * @param videoId The video id
     * @param reason The flag reason
     */
    public addVideoFlag (videoId: number, reason?: StringWrapper) : Promise<{ response: http.ClientResponse; body: FlagResource;  }> {
        const localVarPath = this.basePath + '/media/videos/{video_id}/moderation'
            .replace('{' + 'video_id' + '}', String(videoId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'videoId' is not null or undefined
        if (videoId === null || videoId === undefined) {
            throw new Error('Required parameter videoId was null or undefined when calling addVideoFlag.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(reason, "StringWrapper")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FlagResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlagResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds one or more existing videos as related to this one
     * @param videoId The video id
     * @param videoRelationshipResource The video relationship object 
     */
    public addVideoRelationships (videoId: number, videoRelationshipResource?: VideoRelationshipResource) : Promise<{ response: http.ClientResponse; body: VideoRelationshipResource;  }> {
        const localVarPath = this.basePath + '/media/videos/{video_id}/related'
            .replace('{' + 'video_id' + '}', String(videoId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'videoId' is not null or undefined
        if (videoId === null || videoId === undefined) {
            throw new Error('Required parameter videoId was null or undefined when calling addVideoRelationships.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(videoRelationshipResource, "VideoRelationshipResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VideoRelationshipResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "VideoRelationshipResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a video disposition
     * @param videoId The video id
     * @param dispositionResource The disposition object
     */
    public createVideoDisposition (videoId: number, dispositionResource?: DispositionResource) : Promise<{ response: http.ClientResponse; body: DispositionResource;  }> {
        const localVarPath = this.basePath + '/media/videos/{video_id}/dispositions'
            .replace('{' + 'video_id' + '}', String(videoId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'videoId' is not null or undefined
        if (videoId === null || videoId === undefined) {
            throw new Error('Required parameter videoId was null or undefined when calling createVideoDisposition.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(dispositionResource, "DispositionResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DispositionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DispositionResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a video from the system if no resources are attached to it
     * @param id The video id
     */
    public deleteVideo (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/media/videos/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteVideo.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a video comment
     * @param videoId The video id
     * @param id The comment id
     */
    public deleteVideoComment (videoId: number, id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/media/videos/{video_id}/comments/{id}'
            .replace('{' + 'video_id' + '}', String(videoId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'videoId' is not null or undefined
        if (videoId === null || videoId === undefined) {
            throw new Error('Required parameter videoId was null or undefined when calling deleteVideoComment.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteVideoComment.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a video disposition
     * @param dispositionId The disposition id
     */
    public deleteVideoDisposition (dispositionId: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/media/videos/{video_id}/dispositions/{disposition_id}'
            .replace('{' + 'disposition_id' + '}', String(dispositionId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'dispositionId' is not null or undefined
        if (dispositionId === null || dispositionId === undefined) {
            throw new Error('Required parameter dispositionId was null or undefined when calling deleteVideoDisposition.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a flag
     * @param videoId The video id
     */
    public deleteVideoFlag (videoId: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/media/videos/{video_id}/moderation'
            .replace('{' + 'video_id' + '}', String(videoId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'videoId' is not null or undefined
        if (videoId === null || videoId === undefined) {
            throw new Error('Required parameter videoId was null or undefined when calling deleteVideoFlag.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a video's relationship
     * @param videoId The video id
     * @param id The relationship id
     */
    public deleteVideoRelationship (videoId: number, id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/media/videos/{video_id}/related/{id}'
            .replace('{' + 'video_id' + '}', String(videoId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'videoId' is not null or undefined
        if (videoId === null || videoId === undefined) {
            throw new Error('Required parameter videoId was null or undefined when calling deleteVideoRelationship.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteVideoRelationship.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get user videos
     * @param userId The user id
     * @param excludeFlagged Skip videos that have been flagged by the current user
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getUserVideos (userId: number, excludeFlagged?: boolean, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceVideoResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/videos'
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserVideos.');
        }

        if (excludeFlagged !== undefined) {
            queryParameters['exclude_flagged'] = ObjectSerializer.serialize(excludeFlagged, "boolean");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceVideoResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceVideoResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Loads a specific video details
     * @param id The video id
     */
    public getVideo (id: number) : Promise<{ response: http.ClientResponse; body: VideoResource;  }> {
        const localVarPath = this.basePath + '/media/videos/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getVideo.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VideoResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "VideoResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a page of comments for a video
     * @param videoId The video id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getVideoComments (videoId: number, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceCommentResource;  }> {
        const localVarPath = this.basePath + '/media/videos/{video_id}/comments'
            .replace('{' + 'video_id' + '}', String(videoId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'videoId' is not null or undefined
        if (videoId === null || videoId === undefined) {
            throw new Error('Required parameter videoId was null or undefined when calling getVideoComments.');
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceCommentResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceCommentResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a page of dispositions for a video
     * @param videoId The video id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getVideoDispositions (videoId: number, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceDispositionResource;  }> {
        const localVarPath = this.basePath + '/media/videos/{video_id}/dispositions'
            .replace('{' + 'video_id' + '}', String(videoId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'videoId' is not null or undefined
        if (videoId === null || videoId === undefined) {
            throw new Error('Required parameter videoId was null or undefined when calling getVideoDispositions.');
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceDispositionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceDispositionResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a page of video relationships
     * @param videoId The video id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getVideoRelationships (videoId: number, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceVideoRelationshipResource;  }> {
        const localVarPath = this.basePath + '/media/videos/{video_id}/related'
            .replace('{' + 'video_id' + '}', String(videoId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'videoId' is not null or undefined
        if (videoId === null || videoId === undefined) {
            throw new Error('Required parameter videoId was null or undefined when calling getVideoRelationships.');
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceVideoRelationshipResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceVideoRelationshipResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Search videos using the documented filters
     * @param excludeFlagged Skip videos that have been flagged by the current user
     * @param filterVideosByUploader Filter for videos by uploader id
     * @param filterCategory Filter for videos from a specific category by id
     * @param filterTagset Filter for videos with specified tags (separated by comma)
     * @param filterVideosByName Filter for videos which name *STARTS* with the given string
     * @param filterVideosByContributor Filter for videos with contribution from the artist specified by ID
     * @param filterVideosByAuthor Filter for videos with an artist as author specified by ID
     * @param filterHasAuthor Filter for videos that have an author set if true, or that have no author if false
     * @param filterHasUploader Filter for videos that have an uploader set if true, or that have no uploader if false
     * @param filterRelatedTo Filter for videos that have designated a particular video as the TO of a relationship. Pattern should match VIDEO_ID or VIDEO_ID:DETAILS to match with a specific details string as well
     * @param filterFriends Filter for videos uploaded by friends. &#39;true&#39; for friends of the caller (requires user token) or a user id for a specific user&#39;s friends (requires VIDEOS_ADMIN permission)
     * @param filterDisposition Filter for videos a given user has a given disposition towards. USER_ID:DISPOSITION where USER_ID is the id of the user who has this disposition or &#39;me&#39; for the caller (requires user token for &#39;me&#39;) and DISPOSITION is the name of the disposition. E.G. filter_disposition&#x3D;123:like or filter_disposition&#x3D;me:favorite
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getVideos (excludeFlagged?: boolean, filterVideosByUploader?: number, filterCategory?: string, filterTagset?: string, filterVideosByName?: string, filterVideosByContributor?: number, filterVideosByAuthor?: number, filterHasAuthor?: boolean, filterHasUploader?: boolean, filterRelatedTo?: string, filterFriends?: boolean, filterDisposition?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceVideoResource;  }> {
        const localVarPath = this.basePath + '/media/videos';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (excludeFlagged !== undefined) {
            queryParameters['exclude_flagged'] = ObjectSerializer.serialize(excludeFlagged, "boolean");
        }

        if (filterVideosByUploader !== undefined) {
            queryParameters['filter_videos_by_uploader'] = ObjectSerializer.serialize(filterVideosByUploader, "number");
        }

        if (filterCategory !== undefined) {
            queryParameters['filter_category'] = ObjectSerializer.serialize(filterCategory, "string");
        }

        if (filterTagset !== undefined) {
            queryParameters['filter_tagset'] = ObjectSerializer.serialize(filterTagset, "string");
        }

        if (filterVideosByName !== undefined) {
            queryParameters['filter_videos_by_name'] = ObjectSerializer.serialize(filterVideosByName, "string");
        }

        if (filterVideosByContributor !== undefined) {
            queryParameters['filter_videos_by_contributor'] = ObjectSerializer.serialize(filterVideosByContributor, "number");
        }

        if (filterVideosByAuthor !== undefined) {
            queryParameters['filter_videos_by_author'] = ObjectSerializer.serialize(filterVideosByAuthor, "number");
        }

        if (filterHasAuthor !== undefined) {
            queryParameters['filter_has_author'] = ObjectSerializer.serialize(filterHasAuthor, "boolean");
        }

        if (filterHasUploader !== undefined) {
            queryParameters['filter_has_uploader'] = ObjectSerializer.serialize(filterHasUploader, "boolean");
        }

        if (filterRelatedTo !== undefined) {
            queryParameters['filter_related_to'] = ObjectSerializer.serialize(filterRelatedTo, "string");
        }

        if (filterFriends !== undefined) {
            queryParameters['filter_friends'] = ObjectSerializer.serialize(filterFriends, "boolean");
        }

        if (filterDisposition !== undefined) {
            queryParameters['filter_disposition'] = ObjectSerializer.serialize(filterDisposition, "string");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceVideoResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceVideoResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Remove the user with the id given in the path from the whitelist of users that can view this video regardless of privacy setting.
     * @summary Removes a user from a video's whitelist
     * @param videoId The video id
     * @param id The user id
     */
    public removeUserFromVideoWhitelist (videoId: number, id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/media/videos/{video_id}/whitelist/{id}'
            .replace('{' + 'video_id' + '}', String(videoId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'videoId' is not null or undefined
        if (videoId === null || videoId === undefined) {
            throw new Error('Required parameter videoId was null or undefined when calling removeUserFromVideoWhitelist.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling removeUserFromVideoWhitelist.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Removes a contributor from a video
     * @param videoId The video id
     * @param id The contributor id
     */
    public removeVideoContributor (videoId: number, id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/media/videos/{video_id}/contributors/{id}'
            .replace('{' + 'video_id' + '}', String(videoId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'videoId' is not null or undefined
        if (videoId === null || videoId === undefined) {
            throw new Error('Required parameter videoId was null or undefined when calling removeVideoContributor.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling removeVideoContributor.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Modifies a video's details
     * @param id The video id
     * @param videoResource The video object
     */
    public updateVideo (id: number, videoResource?: VideoResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/media/videos/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateVideo.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(videoResource, "VideoResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a video comment
     * @param videoId The video id
     * @param id The comment id
     * @param content The comment content
     */
    public updateVideoComment (videoId: number, id: number, content?: StringWrapper) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/media/videos/{video_id}/comments/{id}/content'
            .replace('{' + 'video_id' + '}', String(videoId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'videoId' is not null or undefined
        if (videoId === null || videoId === undefined) {
            throw new Error('Required parameter videoId was null or undefined when calling updateVideoComment.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateVideoComment.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(content, "StringWrapper")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a video's relationship details
     * @param videoId The video id
     * @param relationshipId The relationship id
     * @param details The video relationship details
     */
    public updateVideoRelationship (videoId: number, relationshipId: number, details?: StringWrapper) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/media/videos/{video_id}/related/{id}/relationship_details'
            .replace('{' + 'video_id' + '}', String(videoId))
            .replace('{' + 'relationship_id' + '}', String(relationshipId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'videoId' is not null or undefined
        if (videoId === null || videoId === undefined) {
            throw new Error('Required parameter videoId was null or undefined when calling updateVideoRelationship.');
        }

        // verify required parameter 'relationshipId' is not null or undefined
        if (relationshipId === null || relationshipId === undefined) {
            throw new Error('Required parameter relationshipId was null or undefined when calling updateVideoRelationship.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(details, "StringWrapper")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Increment a video's view count
     * @param id The video id
     */
    public viewVideo (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/media/videos/{id}/views'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling viewVideo.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MessagingApiApiKeys {
}

export class MessagingApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MessagingApiApiKeys, value: string) {
        this.authentications[MessagingApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Send a raw email to one or more users
     * @param rawEmailResource The new raw email to be sent
     */
    public sendRawEmail (rawEmailResource?: RawEmailResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/messaging/raw-email';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(rawEmailResource, "RawEmailResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Sends a raw SMS text message to one or more users. User's without registered mobile numbers will be skipped.
     * @summary Send a raw SMS
     * @param rawSMSResource The new raw SMS to be sent
     */
    public sendRawSMS (rawSMSResource?: RawSMSResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/messaging/raw-sms';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(rawSMSResource, "RawSMSResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send a templated email to one or more users
     * @param messageResource The new template email to be sent
     */
    public sendTemplatedEmail (messageResource?: TemplateEmailResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/messaging/templated-email';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(messageResource, "TemplateEmailResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Sends a templated SMS text message to one or more users. User's without registered mobile numbers will be skipped.
     * @summary Send a new templated SMS
     * @param templateSMSResource The new template SMS to be sent
     */
    public sendTemplatedSMS (templateSMSResource?: TemplateSMSResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/messaging/templated-sms';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(templateSMSResource, "TemplateSMSResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PaymentsApiApiKeys {
}

export class PaymentsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PaymentsApiApiKeys, value: string) {
        this.authentications[PaymentsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Create a new payment method for a user
     * @param userId ID of the user for whom the payment method is being created
     * @param paymentMethod Payment method being created
     */
    public createPaymentMethod (userId: number, paymentMethod?: PaymentMethodResource) : Promise<{ response: http.ClientResponse; body: PaymentMethodResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/payment-methods'
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling createPaymentMethod.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(paymentMethod, "PaymentMethodResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PaymentMethodResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PaymentMethodResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete an existing payment method for a user
     * @param userId ID of the user for whom the payment method is being updated
     * @param id ID of the payment method being deleted
     */
    public deletePaymentMethod (userId: number, id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/payment-methods/{id}'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling deletePaymentMethod.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deletePaymentMethod.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single payment method for a user
     * @param userId ID of the user for whom the payment method is being retrieved
     * @param id ID of the payment method being retrieved
     */
    public getPaymentMethod (userId: number, id: number) : Promise<{ response: http.ClientResponse; body: PaymentMethodResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/payment-methods/{id}'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getPaymentMethod.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getPaymentMethod.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PaymentMethodResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PaymentMethodResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all payment methods for a user
     * @param userId ID of the user for whom the payment methods are being retrieved
     * @param filterName Filter for payment methods whose name starts with a given string
     * @param filterPaymentType Filter for payment methods with a specific payment type
     * @param filterPaymentMethodTypeId Filter for payment methods with a specific payment method type by id
     * @param filterPaymentMethodTypeName Filter for payment methods whose payment method type name starts with a given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order a comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getPaymentMethods (userId: number, filterName?: string, filterPaymentType?: string, filterPaymentMethodTypeId?: number, filterPaymentMethodTypeName?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: Array<PaymentMethodResource>;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/payment-methods'
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getPaymentMethods.');
        }

        if (filterName !== undefined) {
            queryParameters['filter_name'] = ObjectSerializer.serialize(filterName, "string");
        }

        if (filterPaymentType !== undefined) {
            queryParameters['filter_payment_type'] = ObjectSerializer.serialize(filterPaymentType, "string");
        }

        if (filterPaymentMethodTypeId !== undefined) {
            queryParameters['filter_payment_method_type_id'] = ObjectSerializer.serialize(filterPaymentMethodTypeId, "number");
        }

        if (filterPaymentMethodTypeName !== undefined) {
            queryParameters['filter_payment_method_type_name'] = ObjectSerializer.serialize(filterPaymentMethodTypeName, "string");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<PaymentMethodResource>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PaymentMethodResource>");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Authorize payment of an invoice for later capture
     * @param request Payment authorization request
     */
    public paymentAuthorization (request?: PaymentAuthorizationResource) : Promise<{ response: http.ClientResponse; body: PaymentAuthorizationResource;  }> {
        const localVarPath = this.basePath + '/payment/authorizations';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "PaymentAuthorizationResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PaymentAuthorizationResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PaymentAuthorizationResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Capture an existing invoice payment authorization
     * @param id ID of the payment authorization to capture
     */
    public paymentCapture (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/payment/authorizations/{id}/capture'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling paymentCapture.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update an existing payment method for a user
     * @param userId ID of the user for whom the payment method is being updated
     * @param id ID of the payment method being updated
     * @param paymentMethod The updated payment method data
     */
    public updatePaymentMethod (userId: number, id: number, paymentMethod?: PaymentMethodResource) : Promise<{ response: http.ClientResponse; body: PaymentMethodResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/payment-methods/{id}'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling updatePaymentMethod.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updatePaymentMethod.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(paymentMethod, "PaymentMethodResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PaymentMethodResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PaymentMethodResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PaymentsAppleApiApiKeys {
}

export class PaymentsAppleApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PaymentsAppleApiApiKeys, value: string) {
        this.authentications[PaymentsAppleApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * Mark an invoice paid using Apple payment receipt. A receipt will only be accepted once and the details of the transaction must match the invoice, including the product_id matching the sku text of the item in the invoice. Returns the transaction ID if successful.
     * @summary Pay invoice with Apple receipt
     * @param request The request for paying an invoice through an Apple receipt
     */
    public verifyAppleReceipt (request?: ApplyPaymentRequest) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/payment/provider/apple/receipt';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "ApplyPaymentRequest")
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PaymentsFattMerchantApiApiKeys {
}

export class PaymentsFattMerchantApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PaymentsFattMerchantApiApiKeys, value: string) {
        this.authentications[PaymentsFattMerchantApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * Stores customer information and creates a payment method that can be used to pay invoices through the payments endpoints.
     * @summary Create or update a FattMerchant payment method for a user
     * @param request Request containing payment method information for user
     */
    public createOrUpdateFattMerchantPaymentMethod (request?: FattMerchantPaymentMethodRequest) : Promise<{ response: http.ClientResponse; body: PaymentMethodResource;  }> {
        const localVarPath = this.basePath + '/payment/provider/fattmerchant/payment-methods';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "FattMerchantPaymentMethodRequest")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PaymentMethodResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PaymentMethodResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PaymentsGoogleApiApiKeys {
}

export class PaymentsGoogleApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PaymentsGoogleApiApiKeys, value: string) {
        this.authentications[PaymentsGoogleApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * Mark an invoice paid with Google. Verifies signature from Google and treats the developerPayload field inside the json payload as the id of the invoice to pay. Returns the transaction ID if successful.
     * @summary Mark an invoice paid with Google
     * @param request The request for paying an invoice through a Google in-app payment
     */
    public handleGooglePayment (request?: GooglePaymentRequest) : Promise<{ response: http.ClientResponse; body: number;  }> {
        const localVarPath = this.basePath + '/payment/provider/google/payments';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "GooglePaymentRequest")
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: number;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "number");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PaymentsOptimalApiApiKeys {
}

export class PaymentsOptimalApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PaymentsOptimalApiApiKeys, value: string) {
        this.authentications[PaymentsOptimalApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * Will return the url for a hosted payment endpoint to post to. See Optimal documentation for details.
     * @summary Initiate silent post with Optimal
     * @param request The payment request to initiate
     */
    public silentPostOptimal (request?: OptimalPaymentRequest) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/payment/provider/optimal/silent';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "OptimalPaymentRequest")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PaymentsPayPalClassicApiApiKeys {
}

export class PaymentsPayPalClassicApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PaymentsPayPalClassicApiApiKeys, value: string) {
        this.authentications[PaymentsPayPalClassicApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * Returns the token that should be used to forward the user to PayPal so they can accept the agreement.
     * @summary Create a PayPal Classic billing agreement for the user
     * @param request The request to create a PayPal billing agreement
     */
    public createPayPalBillingAgreementUrl (request?: CreateBillingAgreementRequest) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/payment/provider/paypal/classic/agreements/start';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "CreateBillingAgreementRequest")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns the token that should be used to forward the user to PayPal so they can complete the checkout.
     * @summary Create a payment token for PayPal express checkout
     * @param request The request to create a PayPal payment token
     */
    public createPayPalExpressCheckout (request?: CreatePayPalPaymentRequest) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/payment/provider/paypal/classic/checkout/start';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "CreatePayPalPaymentRequest")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns the ID of the new payment method created for the user for the billing agreement.
     * @summary Finalizes a billing agreement after the user has accepted through PayPal
     * @param request The request to finalize a PayPal billing agreement
     */
    public finalizePayPalBillingAgreement (request?: FinalizeBillingAgreementRequest) : Promise<{ response: http.ClientResponse; body: number;  }> {
        const localVarPath = this.basePath + '/payment/provider/paypal/classic/agreements/finish';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "FinalizeBillingAgreementRequest")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: number;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "number");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * The invoice will be marked paid/failed by asynchronous IPN callback.
     * @summary Finalizes a payment after the user has completed checkout with PayPal
     * @param request The request to finalize the payment
     */
    public finalizePayPalCheckout (request?: FinalizePayPalPaymentRequest) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/payment/provider/paypal/classic/checkout/finish';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "FinalizePayPalPaymentRequest")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PaymentsStripeApiApiKeys {
}

export class PaymentsStripeApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PaymentsStripeApiApiKeys, value: string) {
        this.authentications[PaymentsStripeApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * Stores customer information and creates a payment method that can be used to pay invoices through the payments endpoints.
     * @summary Create a Stripe payment method for a user
     * @param request The request to create a Stripe customer with payment info
     */
    public createStripePaymentMethod (request?: StripeCreatePaymentMethod) : Promise<{ response: http.ClientResponse; body: PaymentMethodResource;  }> {
        const localVarPath = this.basePath + '/payment/provider/stripe/payment-methods';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "StripeCreatePaymentMethod")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PaymentMethodResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PaymentMethodResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Pay with a single use token
     * @param request The request to pay an invoice
     */
    public payStripeInvoice (request?: StripePaymentRequest) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/payment/provider/stripe/payments';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "StripePaymentRequest")
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PaymentsTransactionsApiApiKeys {
}

export class PaymentsTransactionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PaymentsTransactionsApiApiKeys, value: string) {
        this.authentications[PaymentsTransactionsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Get the details for a single transaction
     * @param id id
     */
    public getTransaction (id: number) : Promise<{ response: http.ClientResponse; body: TransactionResource;  }> {
        const localVarPath = this.basePath + '/transactions/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTransaction.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TransactionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List and search transactions
     * @param filterInvoice Filter for transactions from a specific invoice
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getTransactions (filterInvoice?: number, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceTransactionResource;  }> {
        const localVarPath = this.basePath + '/transactions';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterInvoice !== undefined) {
            queryParameters['filter_invoice'] = ObjectSerializer.serialize(filterInvoice, "number");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceTransactionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceTransactionResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Will not allow for refunding more than the full amount even with multiple partial refunds. Money is refunded to the payment method used to make the original payment. Payment method must support refunds.
     * @summary Refund a payment transaction, in full or in part
     * @param id The id of the transaction to refund
     * @param request Request containing refund details
     */
    public refundTransaction (id: number, request?: RefundRequest) : Promise<{ response: http.ClientResponse; body: RefundResource;  }> {
        const localVarPath = this.basePath + '/transactions/{id}/refunds'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling refundTransaction.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "RefundRequest")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RefundResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RefundResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PaymentsWalletsApiApiKeys {
}

export class PaymentsWalletsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PaymentsWalletsApiApiKeys, value: string) {
        this.authentications[PaymentsWalletsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Returns the user's wallet for the given currency code
     * @param userId The ID of the user for whom wallet is being retrieved
     * @param currencyCode Currency code of the user&#39;s wallet
     */
    public getUserWallet (userId: number, currencyCode: string) : Promise<{ response: http.ClientResponse; body: SimpleWallet;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/wallets/{currency_code}'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'currency_code' + '}', String(currencyCode));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserWallet.');
        }

        // verify required parameter 'currencyCode' is not null or undefined
        if (currencyCode === null || currencyCode === undefined) {
            throw new Error('Required parameter currencyCode was null or undefined when calling getUserWallet.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SimpleWallet;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SimpleWallet");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve a user's wallet transactions
     * @param userId The ID of the user for whom wallet transactions are being retrieved
     * @param currencyCode Currency code of the user&#39;s wallet
     * @param filterType Filter for transactions with specified type
     * @param filterMaxDate Filter for transactions from no earlier than the specified date as a unix timestamp in seconds
     * @param filterMinDate Filter for transactions from no later than the specified date as a unix timestamp in seconds
     * @param filterSign Filter for transactions with amount with the given sign.  Allowable values: (&#39;positive&#39;, &#39;negative&#39;)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getUserWalletTransactions (userId: number, currencyCode: string, filterType?: string, filterMaxDate?: number, filterMinDate?: number, filterSign?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceWalletTransactionResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/wallets/{currency_code}/transactions'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'currency_code' + '}', String(currencyCode));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserWalletTransactions.');
        }

        // verify required parameter 'currencyCode' is not null or undefined
        if (currencyCode === null || currencyCode === undefined) {
            throw new Error('Required parameter currencyCode was null or undefined when calling getUserWalletTransactions.');
        }

        if (filterType !== undefined) {
            queryParameters['filter_type'] = ObjectSerializer.serialize(filterType, "string");
        }

        if (filterMaxDate !== undefined) {
            queryParameters['filter_max_date'] = ObjectSerializer.serialize(filterMaxDate, "number");
        }

        if (filterMinDate !== undefined) {
            queryParameters['filter_min_date'] = ObjectSerializer.serialize(filterMinDate, "number");
        }

        if (filterSign !== undefined) {
            queryParameters['filter_sign'] = ObjectSerializer.serialize(filterSign, "string");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceWalletTransactionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceWalletTransactionResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List all of a user's wallets
     * @param userId The ID of the user for whom wallets are being retrieved
     */
    public getUserWallets (userId: number) : Promise<{ response: http.ClientResponse; body: Array<SimpleWallet>;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/wallets'
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserWallets.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<SimpleWallet>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<SimpleWallet>");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a summation of wallet balances by currency code
     */
    public getWalletBalances () : Promise<{ response: http.ClientResponse; body: PageResourceWalletTotalResponse;  }> {
        const localVarPath = this.basePath + '/wallets/totals';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceWalletTotalResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceWalletTotalResponse");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve wallet transactions across the system
     * @param filterInvoice Filter for transactions from a specific invoice
     * @param filterType Filter for transactions with specified type
     * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterSign Filter for transactions with amount with the given sign
     * @param filterUserId Filter for transactions for specific userId
     * @param filterUsername Filter for transactions for specific username that start with the given string
     * @param filterDetails Filter for transactions for specific details that start with the given string
     * @param filterCurrencyCode Filter for transactions for specific currency code
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getWalletTransactions (filterInvoice?: number, filterType?: string, filterDate?: string, filterSign?: string, filterUserId?: number, filterUsername?: string, filterDetails?: string, filterCurrencyCode?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceWalletTransactionResource;  }> {
        const localVarPath = this.basePath + '/wallets/transactions';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterInvoice !== undefined) {
            queryParameters['filter_invoice'] = ObjectSerializer.serialize(filterInvoice, "number");
        }

        if (filterType !== undefined) {
            queryParameters['filter_type'] = ObjectSerializer.serialize(filterType, "string");
        }

        if (filterDate !== undefined) {
            queryParameters['filter_date'] = ObjectSerializer.serialize(filterDate, "string");
        }

        if (filterSign !== undefined) {
            queryParameters['filter_sign'] = ObjectSerializer.serialize(filterSign, "string");
        }

        if (filterUserId !== undefined) {
            queryParameters['filter_user_id'] = ObjectSerializer.serialize(filterUserId, "number");
        }

        if (filterUsername !== undefined) {
            queryParameters['filter_username'] = ObjectSerializer.serialize(filterUsername, "string");
        }

        if (filterDetails !== undefined) {
            queryParameters['filter_details'] = ObjectSerializer.serialize(filterDetails, "string");
        }

        if (filterCurrencyCode !== undefined) {
            queryParameters['filter_currency_code'] = ObjectSerializer.serialize(filterCurrencyCode, "string");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceWalletTransactionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceWalletTransactionResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve a list of wallets across the system
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getWallets (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceSimpleWallet;  }> {
        const localVarPath = this.basePath + '/wallets';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceSimpleWallet;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceSimpleWallet");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the balance for a user's wallet
     * @param userId The ID of the user for whom wallet is being modified
     * @param currencyCode Currency code of the user&#39;s wallet
     * @param request The requested balance modification to be made to the user&#39;s wallet
     */
    public updateWalletBalance (userId: number, currencyCode: string, request?: WalletAlterRequest) : Promise<{ response: http.ClientResponse; body: WalletTransactionResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/wallets/{currency_code}/balance'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'currency_code' + '}', String(currencyCode));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling updateWalletBalance.');
        }

        // verify required parameter 'currencyCode' is not null or undefined
        if (currencyCode === null || currencyCode === undefined) {
            throw new Error('Required parameter currencyCode was null or undefined when calling updateWalletBalance.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "WalletAlterRequest")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: WalletTransactionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WalletTransactionResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PaymentsXsollaApiApiKeys {
}

export class PaymentsXsollaApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PaymentsXsollaApiApiKeys, value: string) {
        this.authentications[PaymentsXsollaApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Create a payment token that should be used to forward the user to Xsolla so they can complete payment
     * @param request The payment request to be sent to XSolla
     */
    public createXsollaTokenUrl (request?: XsollaPaymentRequest) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/payment/provider/xsolla/payment';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "XsollaPaymentRequest")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Only used by Xsolla to call back to JSAPI after processing user payment action
     * @summary Receives payment response from Xsolla
     */
    public receiveXsollaNotification () : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/payment/provider/xsolla/notifications';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ReportingChallengesApiApiKeys {
}

export class ReportingChallengesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ReportingChallengesApiApiKeys, value: string) {
        this.authentications[ReportingChallengesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * Lists all leaderboard entries with additional user details
     * @summary Retrieve a challenge event leaderboard details
     * @param filterEvent A sepecific challenge event id
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getChallengeEventLeaderboard (filterEvent?: number, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceChallengeEventParticipantResource;  }> {
        const localVarPath = this.basePath + '/reporting/events/leaderboard';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterEvent !== undefined) {
            queryParameters['filter_event'] = ObjectSerializer.serialize(filterEvent, "number");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceChallengeEventParticipantResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceChallengeEventParticipantResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Lists all user submitted scores sorted by value, including those that do not apear in the leaderboard due to value or aggregation
     * @summary Retrieve a challenge event participant details
     * @param filterEvent A sepecific challenge event id
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getChallengeEventParticipants (filterEvent?: number, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceChallengeEventParticipantResource;  }> {
        const localVarPath = this.basePath + '/reporting/events/participants';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterEvent !== undefined) {
            queryParameters['filter_event'] = ObjectSerializer.serialize(filterEvent, "number");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceChallengeEventParticipantResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceChallengeEventParticipantResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ReportingOrdersApiApiKeys {
}

export class ReportingOrdersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ReportingOrdersApiApiKeys, value: string) {
        this.authentications[ReportingOrdersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Retrieve invoice counts aggregated by time ranges
     * @param currencyCode The code for a currency to get sales data for
     * @param granularity The time duration to aggregate by
     * @param filterPaymentStatus A payment status to filter results by, can be a comma separated list
     * @param filterFulfillmentStatus An invoice fulfillment status to filter results by, can be a comma separated list
     * @param startDate The start of the time range to return, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to return, unix timestamp in seconds. Default is end of time
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     */
    public getInvoiceReports (currencyCode: string, granularity?: string, filterPaymentStatus?: string, filterFulfillmentStatus?: string, startDate?: number, endDate?: number, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceAggregateInvoiceReportResource;  }> {
        const localVarPath = this.basePath + '/reporting/orders/count/{currency_code}'
            .replace('{' + 'currency_code' + '}', String(currencyCode));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'currencyCode' is not null or undefined
        if (currencyCode === null || currencyCode === undefined) {
            throw new Error('Required parameter currencyCode was null or undefined when calling getInvoiceReports.');
        }

        if (granularity !== undefined) {
            queryParameters['granularity'] = ObjectSerializer.serialize(granularity, "string");
        }

        if (filterPaymentStatus !== undefined) {
            queryParameters['filter_payment_status'] = ObjectSerializer.serialize(filterPaymentStatus, "string");
        }

        if (filterFulfillmentStatus !== undefined) {
            queryParameters['filter_fulfillment_status'] = ObjectSerializer.serialize(filterFulfillmentStatus, "string");
        }

        if (startDate !== undefined) {
            queryParameters['start_date'] = ObjectSerializer.serialize(startDate, "number");
        }

        if (endDate !== undefined) {
            queryParameters['end_date'] = ObjectSerializer.serialize(endDate, "number");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceAggregateInvoiceReportResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceAggregateInvoiceReportResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ReportingRevenueApiApiKeys {
}

export class ReportingRevenueApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ReportingRevenueApiApiKeys, value: string) {
        this.authentications[ReportingRevenueApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * Get basic info about revenue from sales of items and bundles (not subscriptions, shipping, etc), summed up within a time range
     * @summary Get item revenue info
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     */
    public getItemRevenue (currencyCode: string, startDate?: number, endDate?: number) : Promise<{ response: http.ClientResponse; body: RevenueReportResource;  }> {
        const localVarPath = this.basePath + '/reporting/revenue/item-sales/{currency_code}'
            .replace('{' + 'currency_code' + '}', String(currencyCode));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'currencyCode' is not null or undefined
        if (currencyCode === null || currencyCode === undefined) {
            throw new Error('Required parameter currencyCode was null or undefined when calling getItemRevenue.');
        }

        if (startDate !== undefined) {
            queryParameters['start_date'] = ObjectSerializer.serialize(startDate, "number");
        }

        if (endDate !== undefined) {
            queryParameters['end_date'] = ObjectSerializer.serialize(endDate, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RevenueReportResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RevenueReportResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get basic info about revenue loss from refunds (for all item types), summed up within a time range.
     * @summary Get refund revenue info
     * @param currencyCode The code for a currency to get refund data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     */
    public getRefundRevenue (currencyCode: string, startDate?: number, endDate?: number) : Promise<{ response: http.ClientResponse; body: RevenueReportResource;  }> {
        const localVarPath = this.basePath + '/reporting/revenue/refunds/{currency_code}'
            .replace('{' + 'currency_code' + '}', String(currencyCode));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'currencyCode' is not null or undefined
        if (currencyCode === null || currencyCode === undefined) {
            throw new Error('Required parameter currencyCode was null or undefined when calling getRefundRevenue.');
        }

        if (startDate !== undefined) {
            queryParameters['start_date'] = ObjectSerializer.serialize(startDate, "number");
        }

        if (endDate !== undefined) {
            queryParameters['end_date'] = ObjectSerializer.serialize(endDate, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RevenueReportResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RevenueReportResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get basic info about revenue from sales of all types, summed up within a time range and split out by country. Sorted for largest revenue at the top
     * @summary Get revenue info by country
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getRevenueByCountry (currencyCode: string, startDate?: number, endDate?: number, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceRevenueCountryReportResource;  }> {
        const localVarPath = this.basePath + '/reporting/revenue/countries/{currency_code}'
            .replace('{' + 'currency_code' + '}', String(currencyCode));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'currencyCode' is not null or undefined
        if (currencyCode === null || currencyCode === undefined) {
            throw new Error('Required parameter currencyCode was null or undefined when calling getRevenueByCountry.');
        }

        if (startDate !== undefined) {
            queryParameters['start_date'] = ObjectSerializer.serialize(startDate, "number");
        }

        if (endDate !== undefined) {
            queryParameters['end_date'] = ObjectSerializer.serialize(endDate, "number");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceRevenueCountryReportResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceRevenueCountryReportResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get basic info about revenue from sales of all types, summed up within a time range and split out by specific item. Sorted for largest revenue at the top
     * @summary Get revenue info by item
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getRevenueByItem (currencyCode: string, startDate?: number, endDate?: number, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceRevenueProductReportResource;  }> {
        const localVarPath = this.basePath + '/reporting/revenue/products/{currency_code}'
            .replace('{' + 'currency_code' + '}', String(currencyCode));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'currencyCode' is not null or undefined
        if (currencyCode === null || currencyCode === undefined) {
            throw new Error('Required parameter currencyCode was null or undefined when calling getRevenueByItem.');
        }

        if (startDate !== undefined) {
            queryParameters['start_date'] = ObjectSerializer.serialize(startDate, "number");
        }

        if (endDate !== undefined) {
            queryParameters['end_date'] = ObjectSerializer.serialize(endDate, "number");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceRevenueProductReportResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceRevenueProductReportResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get basic info about revenue from sales of new subscriptions as well as recurring payemnts, summed up within a time range
     * @summary Get subscription revenue info
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     */
    public getSubscriptionRevenue (currencyCode: string, startDate?: number, endDate?: number) : Promise<{ response: http.ClientResponse; body: RevenueReportResource;  }> {
        const localVarPath = this.basePath + '/reporting/revenue/subscription-sales/{currency_code}'
            .replace('{' + 'currency_code' + '}', String(currencyCode));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'currencyCode' is not null or undefined
        if (currencyCode === null || currencyCode === undefined) {
            throw new Error('Required parameter currencyCode was null or undefined when calling getSubscriptionRevenue.');
        }

        if (startDate !== undefined) {
            queryParameters['start_date'] = ObjectSerializer.serialize(startDate, "number");
        }

        if (endDate !== undefined) {
            queryParameters['end_date'] = ObjectSerializer.serialize(endDate, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RevenueReportResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RevenueReportResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ReportingSubscriptionsApiApiKeys {
}

export class ReportingSubscriptionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ReportingSubscriptionsApiApiKeys, value: string) {
        this.authentications[ReportingSubscriptionsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Get a list of available subscription reports in most recent first order
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getSubscriptionReports (size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceBillingReport;  }> {
        const localVarPath = this.basePath + '/reporting/subscription';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceBillingReport;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceBillingReport");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ReportingUsageApiApiKeys {
}

export class ReportingUsageApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ReportingUsageApiApiKeys, value: string) {
        this.authentications[ReportingUsageApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Returns aggregated endpoint usage information by day
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param method Filter for a certain endpoint method.  Must include url as well to work
     * @param url Filter for a certain endpoint.  Must include method as well to work
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getUsageByDay (startDate: number, endDate: number, combineEndpoints?: boolean, method?: string, url?: string, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceUsageInfo;  }> {
        const localVarPath = this.basePath + '/reporting/usage/day';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'startDate' is not null or undefined
        if (startDate === null || startDate === undefined) {
            throw new Error('Required parameter startDate was null or undefined when calling getUsageByDay.');
        }

        // verify required parameter 'endDate' is not null or undefined
        if (endDate === null || endDate === undefined) {
            throw new Error('Required parameter endDate was null or undefined when calling getUsageByDay.');
        }

        if (startDate !== undefined) {
            queryParameters['start_date'] = ObjectSerializer.serialize(startDate, "number");
        }

        if (endDate !== undefined) {
            queryParameters['end_date'] = ObjectSerializer.serialize(endDate, "number");
        }

        if (combineEndpoints !== undefined) {
            queryParameters['combine_endpoints'] = ObjectSerializer.serialize(combineEndpoints, "boolean");
        }

        if (method !== undefined) {
            queryParameters['method'] = ObjectSerializer.serialize(method, "string");
        }

        if (url !== undefined) {
            queryParameters['url'] = ObjectSerializer.serialize(url, "string");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceUsageInfo;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceUsageInfo");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns aggregated endpoint usage information by hour
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param method Filter for a certain endpoint method.  Must include url as well to work
     * @param url Filter for a certain endpoint.  Must include method as well to work
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getUsageByHour (startDate: number, endDate: number, combineEndpoints?: boolean, method?: string, url?: string, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceUsageInfo;  }> {
        const localVarPath = this.basePath + '/reporting/usage/hour';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'startDate' is not null or undefined
        if (startDate === null || startDate === undefined) {
            throw new Error('Required parameter startDate was null or undefined when calling getUsageByHour.');
        }

        // verify required parameter 'endDate' is not null or undefined
        if (endDate === null || endDate === undefined) {
            throw new Error('Required parameter endDate was null or undefined when calling getUsageByHour.');
        }

        if (startDate !== undefined) {
            queryParameters['start_date'] = ObjectSerializer.serialize(startDate, "number");
        }

        if (endDate !== undefined) {
            queryParameters['end_date'] = ObjectSerializer.serialize(endDate, "number");
        }

        if (combineEndpoints !== undefined) {
            queryParameters['combine_endpoints'] = ObjectSerializer.serialize(combineEndpoints, "boolean");
        }

        if (method !== undefined) {
            queryParameters['method'] = ObjectSerializer.serialize(method, "string");
        }

        if (url !== undefined) {
            queryParameters['url'] = ObjectSerializer.serialize(url, "string");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceUsageInfo;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceUsageInfo");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns aggregated endpoint usage information by minute
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param method Filter for a certain endpoint method.  Must include url as well to work
     * @param url Filter for a certain endpoint.  Must include method as well to work
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getUsageByMinute (startDate: number, endDate: number, combineEndpoints?: boolean, method?: string, url?: string, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceUsageInfo;  }> {
        const localVarPath = this.basePath + '/reporting/usage/minute';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'startDate' is not null or undefined
        if (startDate === null || startDate === undefined) {
            throw new Error('Required parameter startDate was null or undefined when calling getUsageByMinute.');
        }

        // verify required parameter 'endDate' is not null or undefined
        if (endDate === null || endDate === undefined) {
            throw new Error('Required parameter endDate was null or undefined when calling getUsageByMinute.');
        }

        if (startDate !== undefined) {
            queryParameters['start_date'] = ObjectSerializer.serialize(startDate, "number");
        }

        if (endDate !== undefined) {
            queryParameters['end_date'] = ObjectSerializer.serialize(endDate, "number");
        }

        if (combineEndpoints !== undefined) {
            queryParameters['combine_endpoints'] = ObjectSerializer.serialize(combineEndpoints, "boolean");
        }

        if (method !== undefined) {
            queryParameters['method'] = ObjectSerializer.serialize(method, "string");
        }

        if (url !== undefined) {
            queryParameters['url'] = ObjectSerializer.serialize(url, "string");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceUsageInfo;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceUsageInfo");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns aggregated endpoint usage information by month
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param method Filter for a certain endpoint method.  Must include url as well to work
     * @param url Filter for a certain endpoint.  Must include method as well to work
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getUsageByMonth (startDate: number, endDate: number, combineEndpoints?: boolean, method?: string, url?: string, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceUsageInfo;  }> {
        const localVarPath = this.basePath + '/reporting/usage/month';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'startDate' is not null or undefined
        if (startDate === null || startDate === undefined) {
            throw new Error('Required parameter startDate was null or undefined when calling getUsageByMonth.');
        }

        // verify required parameter 'endDate' is not null or undefined
        if (endDate === null || endDate === undefined) {
            throw new Error('Required parameter endDate was null or undefined when calling getUsageByMonth.');
        }

        if (startDate !== undefined) {
            queryParameters['start_date'] = ObjectSerializer.serialize(startDate, "number");
        }

        if (endDate !== undefined) {
            queryParameters['end_date'] = ObjectSerializer.serialize(endDate, "number");
        }

        if (combineEndpoints !== undefined) {
            queryParameters['combine_endpoints'] = ObjectSerializer.serialize(combineEndpoints, "boolean");
        }

        if (method !== undefined) {
            queryParameters['method'] = ObjectSerializer.serialize(method, "string");
        }

        if (url !== undefined) {
            queryParameters['url'] = ObjectSerializer.serialize(url, "string");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceUsageInfo;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceUsageInfo");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns aggregated endpoint usage information by year
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoints. Removes the url and method from the result object
     * @param method Filter for a certain endpoint method.  Must include url as well to work
     * @param url Filter for a certain endpoint.  Must include method as well to work
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getUsageByYear (startDate: number, endDate: number, combineEndpoints?: boolean, method?: string, url?: string, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceUsageInfo;  }> {
        const localVarPath = this.basePath + '/reporting/usage/year';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'startDate' is not null or undefined
        if (startDate === null || startDate === undefined) {
            throw new Error('Required parameter startDate was null or undefined when calling getUsageByYear.');
        }

        // verify required parameter 'endDate' is not null or undefined
        if (endDate === null || endDate === undefined) {
            throw new Error('Required parameter endDate was null or undefined when calling getUsageByYear.');
        }

        if (startDate !== undefined) {
            queryParameters['start_date'] = ObjectSerializer.serialize(startDate, "number");
        }

        if (endDate !== undefined) {
            queryParameters['end_date'] = ObjectSerializer.serialize(endDate, "number");
        }

        if (combineEndpoints !== undefined) {
            queryParameters['combine_endpoints'] = ObjectSerializer.serialize(combineEndpoints, "boolean");
        }

        if (method !== undefined) {
            queryParameters['method'] = ObjectSerializer.serialize(method, "string");
        }

        if (url !== undefined) {
            queryParameters['url'] = ObjectSerializer.serialize(url, "string");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceUsageInfo;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceUsageInfo");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns list of endpoints called (method and url)
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     */
    public getUsageEndpoints (startDate: number, endDate: number) : Promise<{ response: http.ClientResponse; body: Array<string>;  }> {
        const localVarPath = this.basePath + '/reporting/usage/endpoints';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'startDate' is not null or undefined
        if (startDate === null || startDate === undefined) {
            throw new Error('Required parameter startDate was null or undefined when calling getUsageEndpoints.');
        }

        // verify required parameter 'endDate' is not null or undefined
        if (endDate === null || endDate === undefined) {
            throw new Error('Required parameter endDate was null or undefined when calling getUsageEndpoints.');
        }

        if (startDate !== undefined) {
            queryParameters['start_date'] = ObjectSerializer.serialize(startDate, "number");
        }

        if (endDate !== undefined) {
            queryParameters['end_date'] = ObjectSerializer.serialize(endDate, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<string>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<string>");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ReportingUsersApiApiKeys {
}

export class ReportingUsersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ReportingUsersApiApiKeys, value: string) {
        this.authentications[ReportingUsersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * Get user registration counts grouped by time range
     * @summary Get user registration info
     * @param granularity The time duration to aggregate by
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getUserRegistrations (granularity?: string, startDate?: number, endDate?: number, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceAggregateCountResource;  }> {
        const localVarPath = this.basePath + '/reporting/users/registrations';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (granularity !== undefined) {
            queryParameters['granularity'] = ObjectSerializer.serialize(granularity, "string");
        }

        if (startDate !== undefined) {
            queryParameters['start_date'] = ObjectSerializer.serialize(startDate, "number");
        }

        if (endDate !== undefined) {
            queryParameters['end_date'] = ObjectSerializer.serialize(endDate, "number");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceAggregateCountResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceAggregateCountResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SearchApiApiKeys {
}

export class SearchApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SearchApiApiKeys, value: string) {
        this.authentications[SearchApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * Mainly intended for internal use.
     * @summary Add a new object to an index
     * @param type The index type
     * @param id The ID of the object
     * @param object The object to add
     */
    public addSearchIndex (type: string, id: string, object?: any) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/search/index/{type}/{id}'
            .replace('{' + 'type' + '}', String(type))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling addSearchIndex.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling addSearchIndex.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(object, "any")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Add a new type mapping to connect data from one index to another, or discover an exsting one. Mainly intended for internal use.
     * @summary Register reference mappings
     * @param mappings The mappings to add
     */
    public addSearchMappings (mappings?: Array<SearchReferenceMapping>) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/search/mappings';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(mappings, "Array<SearchReferenceMapping>")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Mainly intended for internal use. Requires SEARCH_ADMIN.
     * @summary Delete an object
     * @param type The index type
     * @param id The ID of the object to delete
     */
    public deleteSearchIndex (type: string, id: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/search/index/{type}/{id}'
            .replace('{' + 'type' + '}', String(type))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling deleteSearchIndex.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteSearchIndex.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Mainly intended for internal use
     * @summary Delete all objects in an index
     * @param type The index type
     */
    public deleteSearchIndexes (type: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/search/index/{type}'
            .replace('{' + 'type' + '}', String(type));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling deleteSearchIndexes.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * The body is an ElasticSearch query in JSON format. Please see their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html'>documentation</a> for details on the format and search options. The searchable object's format depends on on the type. See individual search endpoints on other resources for details on their format.
     * @summary Search an index
     * @param type The index type
     * @param query The query to be used for the search
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public searchIndex (type: string, query?: any, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceMapstringobject;  }> {
        const localVarPath = this.basePath + '/search/index/{type}'
            .replace('{' + 'type' + '}', String(type));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling searchIndex.');
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(query, "any")
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceMapstringobject;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceMapstringobject");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SocialFacebookApiApiKeys {
}

export class SocialFacebookApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SocialFacebookApiApiKeys, value: string) {
        this.authentications[SocialFacebookApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * Links the current user account to a facebook account, using the acccess token from facebook. Can also be used to update the access token after it has expired.
     * @summary Link facebook account
     * @param facebookToken The token from facebook
     */
    public linkAccounts (facebookToken?: FacebookToken) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/social/facebook/users';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(facebookToken, "FacebookToken")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SocialGoogleApiApiKeys {
}

export class SocialGoogleApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SocialGoogleApiApiKeys, value: string) {
        this.authentications[SocialGoogleApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * Links the current user account to a google account, using the acccess token from google. Can also be used to update the access token after it has expired.
     * @summary Link google account
     * @param googleToken The token from google
     */
    public linkAccounts1 (googleToken?: GoogleToken) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/social/google/users';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(googleToken, "GoogleToken")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StoreApiApiKeys {
}

export class StoreApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StoreApiApiKeys, value: string) {
        this.authentications[StoreApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * Item Templates define a type of item and the properties they have.
     * @summary Create an item template
     * @param itemTemplateResource The new item template
     */
    public createItemTemplate (itemTemplateResource?: StoreItemTemplateResource) : Promise<{ response: http.ClientResponse; body: StoreItemTemplateResource;  }> {
        const localVarPath = this.basePath + '/store/items/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(itemTemplateResource, "StoreItemTemplateResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: StoreItemTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "StoreItemTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * SKUs have to be unique in the entire store. If a duplicate SKU is found, a 400 error is generated and the response will have a \"parameters\" field that is a list of duplicates. A duplicate is an object like {item_id, offending_sku_list}. Ex:<br /> {..., parameters: [[{item: 1, skus: [\"SKU-1\"]}]]}<br /> If an item is brand new and has duplicate SKUs within itself, the item ID will be 0.  Item subclasses are not allowed here, you will have to use their respective endpoints.
     * @summary Create a store item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param storeItem The store item object
     */
    public createStoreItem (cascade?: boolean, storeItem?: StoreItem) : Promise<{ response: http.ClientResponse; body: StoreItem;  }> {
        const localVarPath = this.basePath + '/store/items';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (cascade !== undefined) {
            queryParameters['cascade'] = ObjectSerializer.serialize(cascade, "boolean");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(storeItem, "StoreItem")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: StoreItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "StoreItem");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete an item template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    public deleteItemTemplate (id: string, cascade?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/store/items/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteItemTemplate.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = ObjectSerializer.serialize(cascade, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a store item
     * @param id The id of the item
     */
    public deleteStoreItem (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/store/items/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteStoreItem.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List available item behaviors
     */
    public getBehaviors () : Promise<{ response: http.ClientResponse; body: Array<BehaviorDefinitionResource>;  }> {
        const localVarPath = this.basePath + '/store/items/behaviors';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<BehaviorDefinitionResource>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<BehaviorDefinitionResource>");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Item Templates define a type of item and the properties they have.
     * @summary Get a single item template
     * @param id The id of the template
     */
    public getItemTemplate (id: string) : Promise<{ response: http.ClientResponse; body: StoreItemTemplateResource;  }> {
        const localVarPath = this.basePath + '/store/items/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getItemTemplate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: StoreItemTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "StoreItemTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List and search item templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getItemTemplates (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceStoreItemTemplateResource;  }> {
        const localVarPath = this.basePath + '/store/items/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceStoreItemTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceStoreItemTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * The exact structure of each items may differ to include fields specific to the type. The same is true for behaviors.
     * @summary Get a listing of store items
     * @param limit The amount of items returned
     * @param page The page of the request
     * @param useCatalog Whether to remove items that are not intended for display or not in date
     * @param ignoreLocation Whether to ignore country restrictions based on the caller&#39;s location
     * @param inStockOnly Whether only in-stock items should be returned.  Default value is false
     */
    public getStore (limit?: number, page?: number, useCatalog?: boolean, ignoreLocation?: boolean, inStockOnly?: boolean) : Promise<{ response: http.ClientResponse; body: PageResourceStoreItem;  }> {
        const localVarPath = this.basePath + '/store';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (limit !== undefined) {
            queryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (useCatalog !== undefined) {
            queryParameters['use_catalog'] = ObjectSerializer.serialize(useCatalog, "boolean");
        }

        if (ignoreLocation !== undefined) {
            queryParameters['ignore_location'] = ObjectSerializer.serialize(ignoreLocation, "boolean");
        }

        if (inStockOnly !== undefined) {
            queryParameters['in_stock_only'] = ObjectSerializer.serialize(inStockOnly, "boolean");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceStoreItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceStoreItem");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single store item
     * @param id The id of the item
     */
    public getStoreItem (id: number) : Promise<{ response: http.ClientResponse; body: StoreItem;  }> {
        const localVarPath = this.basePath + '/store/items/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getStoreItem.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: StoreItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "StoreItem");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List and search store items
     * @param filterNameSearch Filter for items whose name starts with a given string.
     * @param filterUniqueKey Filter for items whose unique_key is a given string.
     * @param filterPublished Filter for skus that have been published.
     * @param filterDisplayable Filter for items that are displayable.
     * @param filterStart A comma separated string without spaces.  First value is the operator to search on, second value is the store start date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterEnd A comma separated string without spaces.  First value is the operator to search on, second value is the store end date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the sku start date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterStopDate A comma separated string without spaces.  First value is the operator to search on, second value is the sku end date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterSku Filter for skus whose name starts with a given string.
     * @param filterPrice A colon separated string without spaces.  First value is the operator to search on, second value is the price of a sku.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterTag A comma separated list without spaces of the names of tags. Will only return items with at least one of the tags.
     * @param filterItemsByType Filter for item type based on its type hint.
     * @param filterBundledSkus Filter for skus inside bundles whose name starts with a given string.  Used only when type hint is &#39;bundle_item&#39;
     * @param filterVendor Filter for items from a given vendor, by id.
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getStoreItems (filterNameSearch?: string, filterUniqueKey?: string, filterPublished?: boolean, filterDisplayable?: boolean, filterStart?: string, filterEnd?: string, filterStartDate?: string, filterStopDate?: string, filterSku?: string, filterPrice?: string, filterTag?: string, filterItemsByType?: string, filterBundledSkus?: string, filterVendor?: number, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceStoreItem;  }> {
        const localVarPath = this.basePath + '/store/items';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterNameSearch !== undefined) {
            queryParameters['filter_name_search'] = ObjectSerializer.serialize(filterNameSearch, "string");
        }

        if (filterUniqueKey !== undefined) {
            queryParameters['filter_unique_key'] = ObjectSerializer.serialize(filterUniqueKey, "string");
        }

        if (filterPublished !== undefined) {
            queryParameters['filter_published'] = ObjectSerializer.serialize(filterPublished, "boolean");
        }

        if (filterDisplayable !== undefined) {
            queryParameters['filter_displayable'] = ObjectSerializer.serialize(filterDisplayable, "boolean");
        }

        if (filterStart !== undefined) {
            queryParameters['filter_start'] = ObjectSerializer.serialize(filterStart, "string");
        }

        if (filterEnd !== undefined) {
            queryParameters['filter_end'] = ObjectSerializer.serialize(filterEnd, "string");
        }

        if (filterStartDate !== undefined) {
            queryParameters['filter_start_date'] = ObjectSerializer.serialize(filterStartDate, "string");
        }

        if (filterStopDate !== undefined) {
            queryParameters['filter_stop_date'] = ObjectSerializer.serialize(filterStopDate, "string");
        }

        if (filterSku !== undefined) {
            queryParameters['filter_sku'] = ObjectSerializer.serialize(filterSku, "string");
        }

        if (filterPrice !== undefined) {
            queryParameters['filter_price'] = ObjectSerializer.serialize(filterPrice, "string");
        }

        if (filterTag !== undefined) {
            queryParameters['filter_tag'] = ObjectSerializer.serialize(filterTag, "string");
        }

        if (filterItemsByType !== undefined) {
            queryParameters['filter_items_by_type'] = ObjectSerializer.serialize(filterItemsByType, "string");
        }

        if (filterBundledSkus !== undefined) {
            queryParameters['filter_bundled_skus'] = ObjectSerializer.serialize(filterBundledSkus, "string");
        }

        if (filterVendor !== undefined) {
            queryParameters['filter_vendor'] = ObjectSerializer.serialize(filterVendor, "number");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceStoreItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceStoreItem");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Used to create and automatically pay an invoice for a single unit of a single SKU from a user's wallet. SKU must be priced in virtual currency and must not be an item that requires shipping. PAYMENTS_ADMIN permission is required if user ID is specified and is not the ID of the currently logged in user. If invoice price does not match expected price, purchase is aborted
     * @summary One-step purchase and pay for a single SKU item from a user's wallet
     * @param quickBuyRequest Quick buy details
     */
    public quickBuy (quickBuyRequest?: QuickBuyRequest) : Promise<{ response: http.ClientResponse; body: InvoiceResource;  }> {
        const localVarPath = this.basePath + '/store/quick-buy';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(quickBuyRequest, "QuickBuyRequest")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InvoiceResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InvoiceResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update an item template
     * @param id The id of the template
     * @param itemTemplateResource The item template resource object
     */
    public updateItemTemplate (id: string, itemTemplateResource?: StoreItemTemplateResource) : Promise<{ response: http.ClientResponse; body: StoreItemTemplateResource;  }> {
        const localVarPath = this.basePath + '/store/items/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateItemTemplate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(itemTemplateResource, "StoreItemTemplateResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: StoreItemTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "StoreItemTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a store item
     * @param id The id of the item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param storeItem The store item object
     */
    public updateStoreItem (id: number, cascade?: boolean, storeItem?: StoreItem) : Promise<{ response: http.ClientResponse; body: StoreItem;  }> {
        const localVarPath = this.basePath + '/store/items/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateStoreItem.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = ObjectSerializer.serialize(cascade, "boolean");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(storeItem, "StoreItem")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: StoreItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "StoreItem");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StoreBundlesApiApiKeys {
}

export class StoreBundlesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StoreBundlesApiApiKeys, value: string) {
        this.authentications[StoreBundlesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * The SKU for the bundle itself must be unique and there can only be one SKU.  Extra notes for price_override:  The price of all the items (multiplied by the quantity) must equal the price of the bundle.  With individual prices set, items will be processed individually and can be refunded as such.  However, if all prices are set to null, the price of the bundle will be used and will be treated as one item.
     * @summary Create a bundle item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param bundleItem The bundle item object
     */
    public createBundleItem (cascade?: boolean, bundleItem?: BundleItem) : Promise<{ response: http.ClientResponse; body: BundleItem;  }> {
        const localVarPath = this.basePath + '/store/bundles';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (cascade !== undefined) {
            queryParameters['cascade'] = ObjectSerializer.serialize(cascade, "boolean");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(bundleItem, "BundleItem")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BundleItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BundleItem");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Bundle Templates define a type of bundle and the properties they have.
     * @summary Create a bundle template
     * @param bundleTemplateResource The new bundle template
     */
    public createBundleTemplate (bundleTemplateResource?: ItemTemplateResource) : Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }> {
        const localVarPath = this.basePath + '/store/bundles/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(bundleTemplateResource, "ItemTemplateResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ItemTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a bundle item
     * @param id The id of the bundle
     */
    public deleteBundleItem (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/store/bundles/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteBundleItem.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a bundle template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    public deleteBundleTemplate (id: string, cascade?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/store/bundles/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteBundleTemplate.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = ObjectSerializer.serialize(cascade, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single bundle item
     * @param id The id of the bundle
     */
    public getBundleItem (id: number) : Promise<{ response: http.ClientResponse; body: BundleItem;  }> {
        const localVarPath = this.basePath + '/store/bundles/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getBundleItem.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BundleItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BundleItem");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Bundle Templates define a type of bundle and the properties they have.
     * @summary Get a single bundle template
     * @param id The id of the template
     */
    public getBundleTemplate (id: string) : Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }> {
        const localVarPath = this.basePath + '/store/bundles/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getBundleTemplate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ItemTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List and search bundle templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getBundleTemplates (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceItemTemplateResource;  }> {
        const localVarPath = this.basePath + '/store/bundles/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceItemTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceItemTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a bundle item
     * @param id The id of the bundle
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param bundleItem The bundle item object
     */
    public updateBundleItem (id: number, cascade?: boolean, bundleItem?: BundleItem) : Promise<{ response: http.ClientResponse; body: BundleItem;  }> {
        const localVarPath = this.basePath + '/store/bundles/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateBundleItem.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = ObjectSerializer.serialize(cascade, "boolean");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(bundleItem, "BundleItem")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BundleItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BundleItem");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a bundle template
     * @param id The id of the template
     * @param bundleTemplateResource The bundle template resource object
     */
    public updateBundleTemplate (id: string, bundleTemplateResource?: ItemTemplateResource) : Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }> {
        const localVarPath = this.basePath + '/store/bundles/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateBundleTemplate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(bundleTemplateResource, "ItemTemplateResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ItemTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StoreCouponsApiApiKeys {
}

export class StoreCouponsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StoreCouponsApiApiKeys, value: string) {
        this.authentications[StoreCouponsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * SKUs have to be unique in the entire store.
     * @summary Create a coupon item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param couponItem The coupon item object
     */
    public createCouponItem (cascade?: boolean, couponItem?: CouponItem) : Promise<{ response: http.ClientResponse; body: CouponItem;  }> {
        const localVarPath = this.basePath + '/store/coupons';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (cascade !== undefined) {
            queryParameters['cascade'] = ObjectSerializer.serialize(cascade, "boolean");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(couponItem, "CouponItem")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CouponItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CouponItem");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Coupon Templates define a type of coupon and the properties they have.
     * @summary Create a coupon template
     * @param couponTemplateResource The new coupon template
     */
    public createCouponTemplate (couponTemplateResource?: ItemTemplateResource) : Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }> {
        const localVarPath = this.basePath + '/store/coupons/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(couponTemplateResource, "ItemTemplateResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ItemTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a coupon item
     * @param id The id of the coupon
     */
    public deleteCouponItem (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/store/coupons/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteCouponItem.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a coupon template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    public deleteCouponTemplate (id: string, cascade?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/store/coupons/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteCouponTemplate.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = ObjectSerializer.serialize(cascade, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single coupon item
     * @param id The id of the coupon
     */
    public getCouponItem (id: number) : Promise<{ response: http.ClientResponse; body: CouponItem;  }> {
        const localVarPath = this.basePath + '/store/coupons/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getCouponItem.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CouponItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CouponItem");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Coupon Templates define a type of coupon and the properties they have.
     * @summary Get a single coupon template
     * @param id The id of the template
     */
    public getCouponTemplate (id: string) : Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }> {
        const localVarPath = this.basePath + '/store/coupons/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getCouponTemplate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ItemTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List and search coupon templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getCouponTemplates (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceItemTemplateResource;  }> {
        const localVarPath = this.basePath + '/store/coupons/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceItemTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceItemTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a coupon item
     * @param id The id of the coupon
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param couponItem The coupon item object
     */
    public updateCouponItem (id: number, cascade?: boolean, couponItem?: CouponItem) : Promise<{ response: http.ClientResponse; body: CouponItem;  }> {
        const localVarPath = this.basePath + '/store/coupons/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateCouponItem.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = ObjectSerializer.serialize(cascade, "boolean");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(couponItem, "CouponItem")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CouponItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CouponItem");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a coupon template
     * @param id The id of the template
     * @param couponTemplateResource The coupon template resource object
     */
    public updateCouponTemplate (id: string, couponTemplateResource?: ItemTemplateResource) : Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }> {
        const localVarPath = this.basePath + '/store/coupons/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateCouponTemplate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(couponTemplateResource, "ItemTemplateResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ItemTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StoreSalesApiApiKeys {
}

export class StoreSalesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StoreSalesApiApiKeys, value: string) {
        this.authentications[StoreSalesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Create a sale
     * @param catalogSale The catalog sale object
     */
    public createCatalogSale (catalogSale?: CatalogSale) : Promise<{ response: http.ClientResponse; body: CatalogSale;  }> {
        const localVarPath = this.basePath + '/store/sales';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(catalogSale, "CatalogSale")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CatalogSale;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CatalogSale");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a sale
     * @param id The id of the sale
     */
    public deleteCatalogSale (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/store/sales/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteCatalogSale.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single sale
     * @param id The id of the sale
     */
    public getCatalogSale (id: number) : Promise<{ response: http.ClientResponse; body: CatalogSale;  }> {
        const localVarPath = this.basePath + '/store/sales/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getCatalogSale.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CatalogSale;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CatalogSale");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List and search sales
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getCatalogSales (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceCatalogSale;  }> {
        const localVarPath = this.basePath + '/store/sales';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceCatalogSale;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceCatalogSale");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a sale
     * @param id The id of the sale
     * @param catalogSale The catalog sale object
     */
    public updateCatalogSale (id: number, catalogSale?: CatalogSale) : Promise<{ response: http.ClientResponse; body: CatalogSale;  }> {
        const localVarPath = this.basePath + '/store/sales/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateCatalogSale.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(catalogSale, "CatalogSale")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CatalogSale;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CatalogSale");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StoreShippingApiApiKeys {
}

export class StoreShippingApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StoreShippingApiApiKeys, value: string) {
        this.authentications[StoreShippingApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * A shipping item represents a shipping option and cost. SKUs have to be unique in the entire store.
     * @summary Create a shipping item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param shippingItem The shipping item object
     */
    public createShippingItem (cascade?: boolean, shippingItem?: ShippingItem) : Promise<{ response: http.ClientResponse; body: ShippingItem;  }> {
        const localVarPath = this.basePath + '/store/shipping';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (cascade !== undefined) {
            queryParameters['cascade'] = ObjectSerializer.serialize(cascade, "boolean");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(shippingItem, "ShippingItem")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ShippingItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ShippingItem");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Shipping Templates define a type of shipping and the properties they have.
     * @summary Create a shipping template
     * @param shippingTemplateResource The new shipping template
     */
    public createShippingTemplate (shippingTemplateResource?: ItemTemplateResource) : Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }> {
        const localVarPath = this.basePath + '/store/shipping/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(shippingTemplateResource, "ItemTemplateResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ItemTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a shipping item
     * @param id The id of the shipping item
     */
    public deleteShippingItem (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/store/shipping/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteShippingItem.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a shipping template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    public deleteShippingTemplate (id: string, cascade?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/store/shipping/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteShippingTemplate.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = ObjectSerializer.serialize(cascade, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single shipping item
     * @param id The id of the shipping item
     */
    public getShippingItem (id: number) : Promise<{ response: http.ClientResponse; body: ShippingItem;  }> {
        const localVarPath = this.basePath + '/store/shipping/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getShippingItem.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ShippingItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ShippingItem");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Shipping Templates define a type of shipping and the properties they have.
     * @summary Get a single shipping template
     * @param id The id of the template
     */
    public getShippingTemplate (id: string) : Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }> {
        const localVarPath = this.basePath + '/store/shipping/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getShippingTemplate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ItemTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List and search shipping templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getShippingTemplates (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceItemTemplateResource;  }> {
        const localVarPath = this.basePath + '/store/shipping/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceItemTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceItemTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a shipping item
     * @param id The id of the shipping item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param shippingItem The shipping item object
     */
    public updateShippingItem (id: number, cascade?: boolean, shippingItem?: ShippingItem) : Promise<{ response: http.ClientResponse; body: ShippingItem;  }> {
        const localVarPath = this.basePath + '/store/shipping/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateShippingItem.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = ObjectSerializer.serialize(cascade, "boolean");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(shippingItem, "ShippingItem")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ShippingItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ShippingItem");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a shipping template
     * @param id The id of the template
     * @param shippingTemplateResource The shipping template resource object
     */
    public updateShippingTemplate (id: string, shippingTemplateResource?: ItemTemplateResource) : Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }> {
        const localVarPath = this.basePath + '/store/shipping/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateShippingTemplate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(shippingTemplateResource, "ItemTemplateResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ItemTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StoreShoppingCartsApiApiKeys {
}

export class StoreShoppingCartsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StoreShoppingCartsApiApiKeys, value: string) {
        this.authentications[StoreShoppingCartsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Adds a custom discount to the cart
     * @param id The id of the cart
     * @param customDiscount The details of the discount to add
     */
    public addCustomDiscount (id: string, customDiscount?: CouponDefinition) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/carts/{id}/custom-discounts'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling addCustomDiscount.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(customDiscount, "CouponDefinition")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a discount coupon to the cart
     * @param id The id of the cart
     * @param skuRequest The request of the sku
     */
    public addDiscountToCart (id: string, skuRequest?: SkuRequest) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/carts/{id}/discounts'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling addDiscountToCart.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(skuRequest, "SkuRequest")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Currently, carts cannot contain virtual and real currency items at the same time. Furthermore, the API only support a single virtual item at the moment
     * @summary Add an item to the cart
     * @param id The id of the cart
     * @param cartItemRequest The cart item request object
     */
    public addItemToCart (id: string, cartItemRequest?: CartItemRequest) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/carts/{id}/items'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling addItemToCart.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(cartItemRequest, "CartItemRequest")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * You don't have to have a user to create a cart but the API requires authentication to checkout
     * @summary Create a cart
     * @param owner Set the owner of a cart. If not specified, defaults to the calling user&#39;s id. If specified and is not the calling user&#39;s id, SHOPPING_CARTS_ADMIN permission is required
     * @param currencyCode Set the currency for the cart, by currency code. May be disallowed by site settings.
     */
    public createCart (owner?: number, currencyCode?: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/carts';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (owner !== undefined) {
            queryParameters['owner'] = ObjectSerializer.serialize(owner, "number");
        }

        if (currencyCode !== undefined) {
            queryParameters['currency_code'] = ObjectSerializer.serialize(currencyCode, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns the cart with the given GUID
     * @param id The id of the cart
     */
    public getCart (id: string) : Promise<{ response: http.ClientResponse; body: Cart;  }> {
        const localVarPath = this.basePath + '/carts/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getCart.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Cart;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Cart");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a list of carts
     * @param filterOwnerId Filter by the id of the owner
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getCarts (filterOwnerId?: number, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceCartSummary;  }> {
        const localVarPath = this.basePath + '/carts';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterOwnerId !== undefined) {
            queryParameters['filter_owner_id'] = ObjectSerializer.serialize(filterOwnerId, "number");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceCartSummary;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceCartSummary");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns whether a cart requires shipping
     * @param id The id of the cart
     */
    public getShippable (id: string) : Promise<{ response: http.ClientResponse; body: CartShippableResponse;  }> {
        const localVarPath = this.basePath + '/carts/{id}/shippable'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getShippable.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CartShippableResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CartShippableResponse");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Since a cart can have multiple vendors with different shipping options, the countries are broken down by vendors. Please see notes about the response object as the fields are variable.
     * @summary Get the list of available shipping countries per vendor
     * @param id The id of the cart
     */
    public getShippingCountries (id: string) : Promise<{ response: http.ClientResponse; body: SampleCountriesResponse;  }> {
        const localVarPath = this.basePath + '/carts/{id}/countries'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getShippingCountries.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SampleCountriesResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SampleCountriesResponse");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Removes a discount coupon from the cart
     * @param id The id of the cart
     * @param code The SKU code of the coupon to remove
     */
    public removeDiscountFromCart (id: string, code: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/carts/{id}/discounts/{code}'
            .replace('{' + 'id' + '}', String(id))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling removeDiscountFromCart.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling removeDiscountFromCart.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * May be disallowed by site settings.
     * @summary Sets the currency to use for the cart
     * @param id The id of the cart
     * @param currencyCode The code of the currency
     */
    public setCartCurrency (id: string, currencyCode?: StringWrapper) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/carts/{id}/currency'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling setCartCurrency.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(currencyCode, "StringWrapper")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Sets the owner of a cart if none is set already
     * @param id The id of the cart
     * @param userId The id of the user
     */
    public setCartOwner (id: string, userId?: IntWrapper) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/carts/{id}/owner'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling setCartOwner.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(userId, "IntWrapper")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A quantity of zero will remove the item from the cart altogether.
     * @summary Changes the quantity of an item already in the cart
     * @param id The id of the cart
     * @param cartItemRequest The cart item request object
     */
    public updateItemInCart (id: string, cartItemRequest?: CartItemRequest) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/carts/{id}/items'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateItemInCart.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(cartItemRequest, "CartItemRequest")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Modifies or sets the order shipping address
     * @param id The id of the cart
     * @param cartShippingAddressRequest The cart shipping address request object
     */
    public updateShippingAddress (id: string, cartShippingAddressRequest?: CartShippingAddressRequest) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/carts/{id}/shipping-address'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateShippingAddress.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(cartShippingAddressRequest, "CartShippingAddressRequest")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StoreSubscriptionsApiApiKeys {
}

export class StoreSubscriptionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StoreSubscriptionsApiApiKeys, value: string) {
        this.authentications[StoreSubscriptionsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Creates a subscription item and associated plans
     * @param subscriptionResource The subscription to be created
     */
    public createSubscription (subscriptionResource?: SubscriptionResource) : Promise<{ response: http.ClientResponse; body: SubscriptionResource;  }> {
        const localVarPath = this.basePath + '/subscriptions';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(subscriptionResource, "SubscriptionResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SubscriptionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SubscriptionResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Subscription Templates define a type of subscription and the properties they have.
     * @summary Create a subscription template
     * @param subscriptionTemplateResource The new subscription template
     */
    public createSubscriptionTemplate (subscriptionTemplateResource?: SubscriptionTemplateResource) : Promise<{ response: http.ClientResponse; body: SubscriptionTemplateResource;  }> {
        const localVarPath = this.basePath + '/subscriptions/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(subscriptionTemplateResource, "SubscriptionTemplateResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SubscriptionTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SubscriptionTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Must not be locked or a migration target
     * @summary Delete a subscription plan
     * @param id The id of the subscription
     * @param planId The id of the plan
     */
    public deleteSubscription (id: number, planId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/subscriptions/{id}/plans/{plan_id}'
            .replace('{' + 'id' + '}', String(id))
            .replace('{' + 'plan_id' + '}', String(planId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteSubscription.');
        }

        // verify required parameter 'planId' is not null or undefined
        if (planId === null || planId === undefined) {
            throw new Error('Required parameter planId was null or undefined when calling deleteSubscription.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a subscription template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    public deleteSubscriptionTemplate (id: string, cascade?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/subscriptions/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteSubscriptionTemplate.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = ObjectSerializer.serialize(cascade, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve a single subscription item and associated plans
     * @param id The id of the subscription
     */
    public getSubscription (id: number) : Promise<{ response: http.ClientResponse; body: SubscriptionResource;  }> {
        const localVarPath = this.basePath + '/subscriptions/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getSubscription.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SubscriptionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SubscriptionResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Subscription Templates define a type of subscription and the properties they have.
     * @summary Get a single subscription template
     * @param id The id of the template
     */
    public getSubscriptionTemplate (id: string) : Promise<{ response: http.ClientResponse; body: SubscriptionTemplateResource;  }> {
        const localVarPath = this.basePath + '/subscriptions/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getSubscriptionTemplate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SubscriptionTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SubscriptionTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List and search subscription templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getSubscriptionTemplates (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceSubscriptionTemplateResource;  }> {
        const localVarPath = this.basePath + '/subscriptions/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceSubscriptionTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceSubscriptionTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List available subscription items and associated plans
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getSubscriptions (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceSubscriptionResource;  }> {
        const localVarPath = this.basePath + '/subscriptions';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceSubscriptionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceSubscriptionResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Processes subscriptions and charge dues
     */
    public processSubscriptions () : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/subscriptions/process';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Will not remove plans left out
     * @summary Updates a subscription item and associated plans
     * @param id The id of the subscription
     * @param subscriptionResource The subscription resource object
     */
    public updateSubscription (id: number, subscriptionResource?: SubscriptionResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/subscriptions/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateSubscription.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(subscriptionResource, "SubscriptionResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a subscription template
     * @param id The id of the template
     * @param subscriptionTemplateResource The subscription template resource object
     */
    public updateSubscriptionTemplate (id: string, subscriptionTemplateResource?: SubscriptionTemplateResource) : Promise<{ response: http.ClientResponse; body: SubscriptionTemplateResource;  }> {
        const localVarPath = this.basePath + '/subscriptions/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateSubscriptionTemplate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(subscriptionTemplateResource, "SubscriptionTemplateResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SubscriptionTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SubscriptionTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StoreVendorsApiApiKeys {
}

export class StoreVendorsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StoreVendorsApiApiKeys, value: string) {
        this.authentications[StoreVendorsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Create a vendor
     * @param vendor The vendor
     */
    public createVendor (vendor?: VendorResource) : Promise<{ response: http.ClientResponse; body: VendorResource;  }> {
        const localVarPath = this.basePath + '/vendors';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(vendor, "VendorResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VendorResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "VendorResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Vendor Templates define a type of vendor and the properties they have.
     * @summary Create a vendor template
     * @param vendorTemplateResource The new vendor template
     */
    public createVendorTemplate (vendorTemplateResource?: ItemTemplateResource) : Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }> {
        const localVarPath = this.basePath + '/vendors/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(vendorTemplateResource, "ItemTemplateResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ItemTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a vendor
     * @param id The id of the vendor
     */
    public deleteVendor (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/vendors/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteVendor.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a vendor template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    public deleteVendorTemplate (id: string, cascade?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/vendors/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteVendorTemplate.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = ObjectSerializer.serialize(cascade, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single vendor
     * @param id The id of the vendor
     */
    public getVendor (id: number) : Promise<{ response: http.ClientResponse; body: VendorResource;  }> {
        const localVarPath = this.basePath + '/vendors/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getVendor.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VendorResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "VendorResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Vendor Templates define a type of vendor and the properties they have.
     * @summary Get a single vendor template
     * @param id The id of the template
     */
    public getVendorTemplate (id: string) : Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }> {
        const localVarPath = this.basePath + '/vendors/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getVendorTemplate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ItemTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List and search vendor templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getVendorTemplates (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceItemTemplateResource;  }> {
        const localVarPath = this.basePath + '/vendors/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceItemTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceItemTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List and search vendors
     * @param filterName Filters vendors by name starting with the text provided in the filter
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getVendors (filterName?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceVendorResource;  }> {
        const localVarPath = this.basePath + '/vendors';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterName !== undefined) {
            queryParameters['filter_name'] = ObjectSerializer.serialize(filterName, "string");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceVendorResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceVendorResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a vendor
     * @param id The id of the vendor
     * @param vendor The vendor
     */
    public updateVendor (id: number, vendor?: VendorResource) : Promise<{ response: http.ClientResponse; body: VendorResource;  }> {
        const localVarPath = this.basePath + '/vendors/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateVendor.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(vendor, "VendorResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VendorResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "VendorResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a vendor template
     * @param id The id of the template
     * @param vendorTemplateResource The vendor template resource object
     */
    public updateVendorTemplate (id: string, vendorTemplateResource?: ItemTemplateResource) : Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }> {
        const localVarPath = this.basePath + '/vendors/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateVendorTemplate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(vendorTemplateResource, "ItemTemplateResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ItemTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TaxesApiApiKeys {
}

export class TaxesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TaxesApiApiKeys, value: string) {
        this.authentications[TaxesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Create a country tax
     * @param taxResource The tax object
     */
    public createCountryTax (taxResource?: CountryTaxResource) : Promise<{ response: http.ClientResponse; body: CountryTaxResource;  }> {
        const localVarPath = this.basePath + '/tax/countries';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(taxResource, "CountryTaxResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CountryTaxResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CountryTaxResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a state tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param taxResource The tax object
     */
    public createStateTax (countryCodeIso3: string, taxResource?: StateTaxResource) : Promise<{ response: http.ClientResponse; body: StateTaxResource;  }> {
        const localVarPath = this.basePath + '/tax/countries/{country_code_iso3}/states'
            .replace('{' + 'country_code_iso3' + '}', String(countryCodeIso3));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'countryCodeIso3' is not null or undefined
        if (countryCodeIso3 === null || countryCodeIso3 === undefined) {
            throw new Error('Required parameter countryCodeIso3 was null or undefined when calling createStateTax.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(taxResource, "StateTaxResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: StateTaxResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "StateTaxResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete an existing tax
     * @param countryCodeIso3 The iso3 code of the country
     */
    public deleteCountryTax (countryCodeIso3: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/tax/countries/{country_code_iso3}'
            .replace('{' + 'country_code_iso3' + '}', String(countryCodeIso3));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'countryCodeIso3' is not null or undefined
        if (countryCodeIso3 === null || countryCodeIso3 === undefined) {
            throw new Error('Required parameter countryCodeIso3 was null or undefined when calling deleteCountryTax.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete an existing state tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param stateCode The code of the state
     */
    public deleteStateTax (countryCodeIso3: string, stateCode: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/tax/countries/{country_code_iso3}/states/{state_code}'
            .replace('{' + 'country_code_iso3' + '}', String(countryCodeIso3))
            .replace('{' + 'state_code' + '}', String(stateCode));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'countryCodeIso3' is not null or undefined
        if (countryCodeIso3 === null || countryCodeIso3 === undefined) {
            throw new Error('Required parameter countryCodeIso3 was null or undefined when calling deleteStateTax.');
        }

        // verify required parameter 'stateCode' is not null or undefined
        if (stateCode === null || stateCode === undefined) {
            throw new Error('Required parameter stateCode was null or undefined when calling deleteStateTax.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single tax
     * @param countryCodeIso3 The iso3 code of the country
     */
    public getCountryTax (countryCodeIso3: string) : Promise<{ response: http.ClientResponse; body: CountryTaxResource;  }> {
        const localVarPath = this.basePath + '/tax/countries/{country_code_iso3}'
            .replace('{' + 'country_code_iso3' + '}', String(countryCodeIso3));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'countryCodeIso3' is not null or undefined
        if (countryCodeIso3 === null || countryCodeIso3 === undefined) {
            throw new Error('Required parameter countryCodeIso3 was null or undefined when calling getCountryTax.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CountryTaxResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CountryTaxResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of taxes
     * @summary List and search taxes
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getCountryTaxes (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceCountryTaxResource;  }> {
        const localVarPath = this.basePath + '/tax/countries';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceCountryTaxResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceCountryTaxResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single state tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param stateCode The code of the state
     */
    public getStateTax (countryCodeIso3: string, stateCode: string) : Promise<{ response: http.ClientResponse; body: StateTaxResource;  }> {
        const localVarPath = this.basePath + '/tax/countries/{country_code_iso3}/states/{state_code}'
            .replace('{' + 'country_code_iso3' + '}', String(countryCodeIso3))
            .replace('{' + 'state_code' + '}', String(stateCode));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'countryCodeIso3' is not null or undefined
        if (countryCodeIso3 === null || countryCodeIso3 === undefined) {
            throw new Error('Required parameter countryCodeIso3 was null or undefined when calling getStateTax.');
        }

        // verify required parameter 'stateCode' is not null or undefined
        if (stateCode === null || stateCode === undefined) {
            throw new Error('Required parameter stateCode was null or undefined when calling getStateTax.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: StateTaxResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "StateTaxResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of taxes
     * @summary List and search taxes across all countries
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getStateTaxesForCountries (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceStateTaxResource;  }> {
        const localVarPath = this.basePath + '/tax/states';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceStateTaxResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceStateTaxResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of taxes
     * @summary List and search taxes within a country
     * @param countryCodeIso3 The iso3 code of the country
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getStateTaxesForCountry (countryCodeIso3: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceStateTaxResource;  }> {
        const localVarPath = this.basePath + '/tax/countries/{country_code_iso3}/states'
            .replace('{' + 'country_code_iso3' + '}', String(countryCodeIso3));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'countryCodeIso3' is not null or undefined
        if (countryCodeIso3 === null || countryCodeIso3 === undefined) {
            throw new Error('Required parameter countryCodeIso3 was null or undefined when calling getStateTaxesForCountry.');
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceStateTaxResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceStateTaxResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create or update a tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param taxResource The tax object
     */
    public updateCountryTax (countryCodeIso3: string, taxResource?: CountryTaxResource) : Promise<{ response: http.ClientResponse; body: CountryTaxResource;  }> {
        const localVarPath = this.basePath + '/tax/countries/{country_code_iso3}'
            .replace('{' + 'country_code_iso3' + '}', String(countryCodeIso3));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'countryCodeIso3' is not null or undefined
        if (countryCodeIso3 === null || countryCodeIso3 === undefined) {
            throw new Error('Required parameter countryCodeIso3 was null or undefined when calling updateCountryTax.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(taxResource, "CountryTaxResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CountryTaxResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CountryTaxResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create or update a state tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param stateCode The code of the state
     * @param taxResource The tax object
     */
    public updateStateTax (countryCodeIso3: string, stateCode: string, taxResource?: StateTaxResource) : Promise<{ response: http.ClientResponse; body: StateTaxResource;  }> {
        const localVarPath = this.basePath + '/tax/countries/{country_code_iso3}/states/{state_code}'
            .replace('{' + 'country_code_iso3' + '}', String(countryCodeIso3))
            .replace('{' + 'state_code' + '}', String(stateCode));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'countryCodeIso3' is not null or undefined
        if (countryCodeIso3 === null || countryCodeIso3 === undefined) {
            throw new Error('Required parameter countryCodeIso3 was null or undefined when calling updateStateTax.');
        }

        // verify required parameter 'stateCode' is not null or undefined
        if (stateCode === null || stateCode === undefined) {
            throw new Error('Required parameter stateCode was null or undefined when calling updateStateTax.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(taxResource, "StateTaxResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: StateTaxResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "StateTaxResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TemplatesPropertiesApiApiKeys {
}

export class TemplatesPropertiesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TemplatesPropertiesApiApiKeys, value: string) {
        this.authentications[TemplatesPropertiesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Get details for a template property type
     * @param type type
     */
    public getTemplatePropertyType (type: string) : Promise<{ response: http.ClientResponse; body: PropertyFieldListResource;  }> {
        const localVarPath = this.basePath + '/templates/properties/{type}'
            .replace('{' + 'type' + '}', String(type));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling getTemplatePropertyType.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PropertyFieldListResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PropertyFieldListResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List template property types
     */
    public getTemplatePropertyTypes () : Promise<{ response: http.ClientResponse; body: Array<PropertyFieldListResource>;  }> {
        const localVarPath = this.basePath + '/templates/properties';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<PropertyFieldListResource>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PropertyFieldListResource>");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UsersApiApiKeys {
}

export class UsersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UsersApiApiKeys, value: string) {
        this.authentications[UsersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Add a tag to a user
     * @param userId The id of the user
     * @param tag tag
     */
    public addUserTag (userId: number, tag: StringWrapper) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/tags'
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling addUserTag.');
        }

        // verify required parameter 'tag' is not null or undefined
        if (tag === null || tag === undefined) {
            throw new Error('Required parameter tag was null or undefined when calling addUserTag.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(tag, "StringWrapper")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * User Templates define a type of user and the properties they have
     * @summary Create a user template
     * @param userTemplateResource The user template resource object
     */
    public createUserTemplate (userTemplateResource?: TemplateResource) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/users/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(userTemplateResource, "TemplateResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete a user template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    public deleteUserTemplate (id: string, cascade?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteUserTemplate.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = ObjectSerializer.serialize(cascade, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Additional private info is included as USERS_ADMIN
     * @summary Get a single user
     * @param id The id of the user or &#39;me&#39;
     */
    public getUser (id: string) : Promise<{ response: http.ClientResponse; body: UserResource;  }> {
        const localVarPath = this.basePath + '/users/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getUser.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List tags for a user
     * @param userId The id of the user
     */
    public getUserTags (userId: number) : Promise<{ response: http.ClientResponse; body: Array<string>;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/tags'
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserTags.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<string>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<string>");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single user template
     * @param id The id of the template
     */
    public getUserTemplate (id: string) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/users/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getUserTemplate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List and search user templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getUserTemplates (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }> {
        const localVarPath = this.basePath + '/users/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Additional private info is included as USERS_ADMIN
     * @summary List and search users
     * @param filterDisplayname Filter for users whose display name starts with provided string.
     * @param filterEmail Filter for users whose email starts with provided string. Requires USERS_ADMIN permission
     * @param filterFirstname Filter for users whose first name starts with provided string. Requires USERS_ADMIN permission
     * @param filterFullname Filter for users whose full name starts with provided string. Requires USERS_ADMIN permission
     * @param filterLastname Filter for users whose last name starts with provided string. Requires USERS_ADMIN permission
     * @param filterUsername Filter for users whose username starts with the provided string. Requires USERS_ADMIN permission
     * @param filterTag Filter for users who have a given tag
     * @param filterGroup Filter for users in a given group, by unique name
     * @param filterRole Filter for users with a given role
     * @param filterSearch Filter for users whose display_name starts with the provided string, or username if display_name is null
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getUsers (filterDisplayname?: string, filterEmail?: string, filterFirstname?: string, filterFullname?: string, filterLastname?: string, filterUsername?: string, filterTag?: string, filterGroup?: string, filterRole?: string, filterSearch?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceUserBaseResource;  }> {
        const localVarPath = this.basePath + '/users';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterDisplayname !== undefined) {
            queryParameters['filter_displayname'] = ObjectSerializer.serialize(filterDisplayname, "string");
        }

        if (filterEmail !== undefined) {
            queryParameters['filter_email'] = ObjectSerializer.serialize(filterEmail, "string");
        }

        if (filterFirstname !== undefined) {
            queryParameters['filter_firstname'] = ObjectSerializer.serialize(filterFirstname, "string");
        }

        if (filterFullname !== undefined) {
            queryParameters['filter_fullname'] = ObjectSerializer.serialize(filterFullname, "string");
        }

        if (filterLastname !== undefined) {
            queryParameters['filter_lastname'] = ObjectSerializer.serialize(filterLastname, "string");
        }

        if (filterUsername !== undefined) {
            queryParameters['filter_username'] = ObjectSerializer.serialize(filterUsername, "string");
        }

        if (filterTag !== undefined) {
            queryParameters['filter_tag'] = ObjectSerializer.serialize(filterTag, "string");
        }

        if (filterGroup !== undefined) {
            queryParameters['filter_group'] = ObjectSerializer.serialize(filterGroup, "string");
        }

        if (filterRole !== undefined) {
            queryParameters['filter_role'] = ObjectSerializer.serialize(filterRole, "string");
        }

        if (filterSearch !== undefined) {
            queryParameters['filter_search'] = ObjectSerializer.serialize(filterSearch, "string");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceUserBaseResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceUserBaseResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Finish resetting a user's password using the secret provided from the password-reset endpoint.  Password should be in plain text and will be encrypted on receipt. Use SSL for security.
     * @summary Choose a new password after a reset
     * @param id The id of the user
     * @param newPasswordRequest The new password request object
     */
    public passwordReset (id: number, newPasswordRequest?: NewPasswordRequest) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{id}/password-reset'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling passwordReset.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(newPasswordRequest, "NewPasswordRequest")
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Password should be in plain text and will be encrypted on receipt. Use SSL for security
     * @summary Register a new user
     * @param userResource The user resource object
     */
    public registerUser (userResource?: UserResource) : Promise<{ response: http.ClientResponse; body: UserResource;  }> {
        const localVarPath = this.basePath + '/users';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(userResource, "UserResource")
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Remove a tag from a user
     * @param userId The id of the user
     * @param tag The tag to remove
     */
    public removeUserTag (userId: number, tag: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/tags/{tag}'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'tag' + '}', String(tag));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling removeUserTag.');
        }

        // verify required parameter 'tag' is not null or undefined
        if (tag === null || tag === undefined) {
            throw new Error('Required parameter tag was null or undefined when calling removeUserTag.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Password should be in plain text and will be encrypted on receipt. Use SSL for security.
     * @summary Set a user's password
     * @param id The id of the user
     * @param password The new plain text password
     */
    public setPassword (id: number, password?: StringWrapper) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{id}/password'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling setPassword.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(password, "StringWrapper")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A reset code will be generated and a 'forgot_password' BRE event will be fired with that code.  The default system rule will send an email to the selected user if an email service has been setup. You can modify that rule in BRE to send an SMS instead or any other type of notification as you see fit
     * @summary Reset a user's password
     * @param id The id of the user
     */
    public startPasswordReset (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{id}/password-reset'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling startPasswordReset.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A reset code will be generated and a 'forgot_password' BRE event will be fired with that code.  The default system rule will send an email to the selected user if an email service has been setup. You can modify that rule in BRE to send an SMS instead or any other type of notification as you see fit.  Must submit their email, username, or mobile phone number
     * @summary Reset a user's password without user id
     * @param passwordReset An object containing one of three methods to look up a user
     */
    public submitPasswordReset (passwordReset?: PasswordResetRequest) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/password-reset';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(passwordReset, "PasswordResetRequest")
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Password will not be edited on this endpoint, use password specific endpoints.
     * @summary Update a user
     * @param id The id of the user or &#39;me&#39;
     * @param userResource The user resource object
     */
    public updateUser (id: string, userResource?: UserResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateUser.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(userResource, "UserResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a user template
     * @param id The id of the template
     * @param userTemplateResource The user template resource object
     */
    public updateUserTemplate (id: string, userTemplateResource?: TemplateResource) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/users/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateUserTemplate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(userTemplateResource, "TemplateResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UsersAddressesApiApiKeys {
}

export class UsersAddressesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UsersAddressesApiApiKeys, value: string) {
        this.authentications[UsersAddressesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Create a new address
     * @param userId The id of the user
     * @param savedAddressResource The new address
     */
    public createAddress (userId: string, savedAddressResource?: SavedAddressResource) : Promise<{ response: http.ClientResponse; body: SavedAddressResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/addresses'
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling createAddress.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(savedAddressResource, "SavedAddressResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SavedAddressResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SavedAddressResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete an address
     * @param userId The id of the user
     * @param id The id of the address
     */
    public deleteAddress (userId: string, id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/addresses/{id}'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling deleteAddress.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteAddress.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single address
     * @param userId The id of the user
     * @param id The id of the address
     */
    public getAddress (userId: string, id: number) : Promise<{ response: http.ClientResponse; body: SavedAddressResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/addresses/{id}'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getAddress.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getAddress.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SavedAddressResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SavedAddressResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List and search addresses
     * @param userId The id of the user
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getAddresses (userId: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceSavedAddressResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/addresses'
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getAddresses.');
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceSavedAddressResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceSavedAddressResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update an address
     * @param userId The id of the user
     * @param id The id of the address
     * @param savedAddressResource The saved address resource object
     */
    public updateAddress (userId: string, id: number, savedAddressResource?: SavedAddressResource) : Promise<{ response: http.ClientResponse; body: SavedAddressResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/addresses/{id}'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling updateAddress.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateAddress.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(savedAddressResource, "SavedAddressResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SavedAddressResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SavedAddressResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UsersFriendshipsApiApiKeys {
}

export class UsersFriendshipsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UsersFriendshipsApiApiKeys, value: string) {
        this.authentications[UsersFriendshipsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * As a user, either creates or confirm a pending request. As an admin, call this endpoint twice while inverting the IDs to create a confirmed friendship.
     * @summary Add a friend
     * @param userId The id of the user or &#39;me&#39; if logged in
     * @param id The id of the user to befriend
     */
    public addFriend (userId: string, id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/friends/{id}'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling addFriend.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling addFriend.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get friends list
     * @param userId The id of the user or &#39;me&#39;
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getFriends (userId: string, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceSimpleUserResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/friends'
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getFriends.');
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceSimpleUserResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceSimpleUserResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This is a unique invite token that allows direct connection to the request user.  Exposing that token presents privacy issues if the token is leaked. Use friend request flow instead if confirmation is required
     * @summary Returns the invite token
     * @param userId The id of the user or &#39;me&#39; if logged in
     */
    public getInviteToken (userId: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/invite-token'
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getInviteToken.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Invites that the specified user received
     * @summary Get pending invites
     * @param userId The id of the user or &#39;me&#39;
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getInvites (userId: string, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceSimpleUserResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/invites'
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getInvites.');
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceSimpleUserResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceSimpleUserResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Immediately connects the requested user with the user mapped by the provided invite token
     * @summary Redeem friendship token
     * @param userId The id of the user or &#39;me&#39; if logged in
     * @param token The invite token
     */
    public redeemFriendshipToken (userId: string, token?: StringWrapper) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/friends/tokens'
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling redeemFriendshipToken.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(token, "StringWrapper")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Remove or decline a friend
     * @param userId The id of the user or &#39;me&#39; if logged in
     * @param id The id of the user to befriend
     */
    public removeOrDeclineFriend (userId: string, id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/friends/{id}'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling removeOrDeclineFriend.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling removeOrDeclineFriend.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UsersGroupsApiApiKeys {
}

export class UsersGroupsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UsersGroupsApiApiKeys, value: string) {
        this.authentications[UsersGroupsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Adds a new member to the group
     * @param uniqueName The group unique name
     * @param user The id and status for a user to add to the group
     */
    public addMemberToGroup (uniqueName: string, user: GroupMemberResource) : Promise<{ response: http.ClientResponse; body: GroupMemberResource;  }> {
        const localVarPath = this.basePath + '/users/groups/{unique_name}/members'
            .replace('{' + 'unique_name' + '}', String(uniqueName));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'uniqueName' is not null or undefined
        if (uniqueName === null || uniqueName === undefined) {
            throw new Error('Required parameter uniqueName was null or undefined when calling addMemberToGroup.');
        }

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling addMemberToGroup.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(user, "GroupMemberResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GroupMemberResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GroupMemberResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds multiple members to the group
     * @param uniqueName The group unique name
     * @param users The id and status for a list of users to add to the group
     */
    public addMembersToGroup (uniqueName: string, users: Array<GroupMemberResource>) : Promise<{ response: http.ClientResponse; body: Array<GroupMemberResource>;  }> {
        const localVarPath = this.basePath + '/users/groups/{unique_name}/members/batch-add'
            .replace('{' + 'unique_name' + '}', String(uniqueName));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'uniqueName' is not null or undefined
        if (uniqueName === null || uniqueName === undefined) {
            throw new Error('Required parameter uniqueName was null or undefined when calling addMembersToGroup.');
        }

        // verify required parameter 'users' is not null or undefined
        if (users === null || users === undefined) {
            throw new Error('Required parameter users was null or undefined when calling addMembersToGroup.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(users, "Array<GroupMemberResource>")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GroupMemberResource>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GroupMemberResource>");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a group
     * @param groupResource The new group
     */
    public createGroup (groupResource?: GroupResource) : Promise<{ response: http.ClientResponse; body: GroupResource;  }> {
        const localVarPath = this.basePath + '/users/groups';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(groupResource, "GroupResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GroupResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GroupResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Group Templates define a type of group and the properties they have
     * @summary Create a group template
     * @param groupTemplateResource The group template resource object
     */
    public createGroupTemplate (groupTemplateResource?: TemplateResource) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/users/groups/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(groupTemplateResource, "TemplateResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Removes a group from the system IF no resources are attached to it
     * @param uniqueName The group unique name
     */
    public deleteGroup (uniqueName: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/groups/{unique_name}'
            .replace('{' + 'unique_name' + '}', String(uniqueName));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'uniqueName' is not null or undefined
        if (uniqueName === null || uniqueName === undefined) {
            throw new Error('Required parameter uniqueName was null or undefined when calling deleteGroup.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete a group template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    public deleteGroupTemplate (id: string, cascade?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/groups/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteGroupTemplate.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = ObjectSerializer.serialize(cascade, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Loads a specific group's details
     * @param uniqueName The group unique name
     */
    public getGroup (uniqueName: string) : Promise<{ response: http.ClientResponse; body: GroupResource;  }> {
        const localVarPath = this.basePath + '/users/groups/{unique_name}'
            .replace('{' + 'unique_name' + '}', String(uniqueName));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'uniqueName' is not null or undefined
        if (uniqueName === null || uniqueName === undefined) {
            throw new Error('Required parameter uniqueName was null or undefined when calling getGroup.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GroupResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GroupResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a user from a group
     * @param uniqueName The group unique name
     * @param userId The id of the user
     */
    public getGroupMember (uniqueName: string, userId: number) : Promise<{ response: http.ClientResponse; body: GroupMemberResource;  }> {
        const localVarPath = this.basePath + '/users/groups/{unique_name}/members/{user_id}'
            .replace('{' + 'unique_name' + '}', String(uniqueName))
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'uniqueName' is not null or undefined
        if (uniqueName === null || uniqueName === undefined) {
            throw new Error('Required parameter uniqueName was null or undefined when calling getGroupMember.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getGroupMember.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GroupMemberResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GroupMemberResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Lists members of the group
     * @param uniqueName The group unique name
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getGroupMembers (uniqueName: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceGroupMemberResource;  }> {
        const localVarPath = this.basePath + '/users/groups/{unique_name}/members'
            .replace('{' + 'unique_name' + '}', String(uniqueName));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'uniqueName' is not null or undefined
        if (uniqueName === null || uniqueName === undefined) {
            throw new Error('Required parameter uniqueName was null or undefined when calling getGroupMembers.');
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceGroupMemberResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceGroupMemberResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single group template
     * @param id The id of the template
     */
    public getGroupTemplate (id: string) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/users/groups/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getGroupTemplate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List and search group templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order a comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getGroupTemplates (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }> {
        const localVarPath = this.basePath + '/users/groups/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List groups a user is in
     * @param userId The id of the user
     */
    public getGroupsForUser (userId: number) : Promise<{ response: http.ClientResponse; body: Array<string>;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/groups'
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getGroupsForUser.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<string>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<string>");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Removes a user from a group
     * @param uniqueName The group unique name
     * @param userId The id of the user to remove
     */
    public removeGroupMember (uniqueName: string, userId: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/groups/{unique_name}/members/{user_id}'
            .replace('{' + 'unique_name' + '}', String(uniqueName))
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'uniqueName' is not null or undefined
        if (uniqueName === null || uniqueName === undefined) {
            throw new Error('Required parameter uniqueName was null or undefined when calling removeGroupMember.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling removeGroupMember.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a group
     * @param uniqueName The group unique name
     * @param groupResource The updated group
     */
    public updateGroup (uniqueName: string, groupResource?: GroupResource) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/groups/{unique_name}'
            .replace('{' + 'unique_name' + '}', String(uniqueName));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'uniqueName' is not null or undefined
        if (uniqueName === null || uniqueName === undefined) {
            throw new Error('Required parameter uniqueName was null or undefined when calling updateGroup.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(groupResource, "GroupResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Change a user's status
     * @param uniqueName The group unique name
     * @param userId The user id of the member to modify
     * @param status The new status for the user
     */
    public updateGroupMemberStatus (uniqueName: string, userId: number, status: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/groups/{unique_name}/members/{user_id}/status'
            .replace('{' + 'unique_name' + '}', String(uniqueName))
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'uniqueName' is not null or undefined
        if (uniqueName === null || uniqueName === undefined) {
            throw new Error('Required parameter uniqueName was null or undefined when calling updateGroupMemberStatus.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling updateGroupMemberStatus.');
        }

        // verify required parameter 'status' is not null or undefined
        if (status === null || status === undefined) {
            throw new Error('Required parameter status was null or undefined when calling updateGroupMemberStatus.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(status, "string")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a group template
     * @param id The id of the template
     * @param groupTemplateResource The group template resource object
     */
    public updateGroupTemplate (id: string, groupTemplateResource?: TemplateResource) : Promise<{ response: http.ClientResponse; body: TemplateResource;  }> {
        const localVarPath = this.basePath + '/users/groups/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateGroupTemplate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(groupTemplateResource, "TemplateResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List and search groups
     * @param filterTemplate Filter for groups using a specific template, by id
     * @param filterMemberCount Filters groups by member count. Multiple values possible for range search. Format: filter_member_count&#x3D;OP,ts&amp;... where OP in (GT, LT, GOE, LOE, EQ). Ex: filter_member_count&#x3D;GT,14,LT,17
     * @param filterName Filter for groups with names starting with the given string
     * @param filterUniqueName Filter for groups whose unique_name starts with provided string
     * @param filterParent Filter for groups with a specific parent, by unique name
     * @param filterStatus Filter for groups with a certain status
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public updateGroups (filterTemplate?: string, filterMemberCount?: string, filterName?: string, filterUniqueName?: string, filterParent?: string, filterStatus?: string, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceGroupResource;  }> {
        const localVarPath = this.basePath + '/users/groups';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filterTemplate !== undefined) {
            queryParameters['filter_template'] = ObjectSerializer.serialize(filterTemplate, "string");
        }

        if (filterMemberCount !== undefined) {
            queryParameters['filter_member_count'] = ObjectSerializer.serialize(filterMemberCount, "string");
        }

        if (filterName !== undefined) {
            queryParameters['filter_name'] = ObjectSerializer.serialize(filterName, "string");
        }

        if (filterUniqueName !== undefined) {
            queryParameters['filter_unique_name'] = ObjectSerializer.serialize(filterUniqueName, "string");
        }

        if (filterParent !== undefined) {
            queryParameters['filter_parent'] = ObjectSerializer.serialize(filterParent, "string");
        }

        if (filterStatus !== undefined) {
            queryParameters['filter_status'] = ObjectSerializer.serialize(filterStatus, "string");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceGroupResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceGroupResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UsersInventoryApiApiKeys {
}

export class UsersInventoryApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UsersInventoryApiApiKeys, value: string) {
        this.authentications[UsersInventoryApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * The inventory is fulfilled asynchronously UNLESS the invoice is explicitely skipped. Depending on the use case, it might require the client to verify that the entitlement was added after the fact or configure a BRE rule to get a notification in real time
     * @summary Adds an item to the user inventory
     * @param id The id of the user
     * @param userInventoryAddRequest The user inventory add request object
     */
    public addItemToUserInventory (id: number, userInventoryAddRequest?: UserInventoryAddRequest) : Promise<{ response: http.ClientResponse; body: InvoiceResource;  }> {
        const localVarPath = this.basePath + '/users/{id}/inventory'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling addItemToUserInventory.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(userInventoryAddRequest, "UserInventoryAddRequest")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InvoiceResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InvoiceResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Useful for pre-check and accounts for all various buisness rules
     * @summary Check for access to an item without consuming
     * @param userId The id of the user to check for or &#39;me&#39; for logged in user
     * @param itemId The id of the item
     * @param sku The specific sku of an entitlement list addition to check entitlement for. This is of very limited and specific use and should generally be left out
     */
    public checkUserEntitlementItem (userId: string, itemId: number, sku?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/entitlements/{item_id}/check'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'item_id' + '}', String(itemId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling checkUserEntitlementItem.');
        }

        // verify required parameter 'itemId' is not null or undefined
        if (itemId === null || itemId === undefined) {
            throw new Error('Required parameter itemId was null or undefined when calling checkUserEntitlementItem.');
        }

        if (sku !== undefined) {
            queryParameters['sku'] = ObjectSerializer.serialize(sku, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create an entitlement item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param entitlementItem The entitlement item object
     */
    public createEntitlementItem (cascade?: boolean, entitlementItem?: EntitlementItem) : Promise<{ response: http.ClientResponse; body: EntitlementItem;  }> {
        const localVarPath = this.basePath + '/entitlements';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (cascade !== undefined) {
            queryParameters['cascade'] = ObjectSerializer.serialize(cascade, "boolean");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(entitlementItem, "EntitlementItem")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntitlementItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EntitlementItem");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Entitlement templates define a type of entitlement and the properties they have
     * @summary Create an entitlement template
     * @param template The entitlement template to be created
     */
    public createEntitlementTemplate (template?: ItemTemplateResource) : Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }> {
        const localVarPath = this.basePath + '/entitlements/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(template, "ItemTemplateResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ItemTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete an entitlement item
     * @param entitlementId The id of the entitlement
     */
    public deleteEntitlementItem (entitlementId: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/entitlements/{entitlement_id}'
            .replace('{' + 'entitlement_id' + '}', String(entitlementId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'entitlementId' is not null or undefined
        if (entitlementId === null || entitlementId === undefined) {
            throw new Error('Required parameter entitlementId was null or undefined when calling deleteEntitlementItem.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete an entitlement template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    public deleteEntitlementTemplate (id: string, cascade?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/entitlements/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteEntitlementTemplate.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = ObjectSerializer.serialize(cascade, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single entitlement item
     * @param entitlementId The id of the entitlement
     */
    public getEntitlementItem (entitlementId: number) : Promise<{ response: http.ClientResponse; body: EntitlementItem;  }> {
        const localVarPath = this.basePath + '/entitlements/{entitlement_id}'
            .replace('{' + 'entitlement_id' + '}', String(entitlementId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'entitlementId' is not null or undefined
        if (entitlementId === null || entitlementId === undefined) {
            throw new Error('Required parameter entitlementId was null or undefined when calling getEntitlementItem.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntitlementItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EntitlementItem");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List and search entitlement items
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getEntitlementItems (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceEntitlementItem;  }> {
        const localVarPath = this.basePath + '/entitlements';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceEntitlementItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceEntitlementItem");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single entitlement template
     * @param id The id of the template
     */
    public getEntitlementTemplate (id: string) : Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }> {
        const localVarPath = this.basePath + '/entitlements/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getEntitlementTemplate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ItemTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List and search entitlement templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getEntitlementTemplates (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceItemTemplateResource;  }> {
        const localVarPath = this.basePath + '/entitlements/templates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceItemTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceItemTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List the user inventory entries for a given user
     * @param id The id of the user
     * @param inactive If true, accepts inactive user inventories
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param filterItemName Filter by items whose name starts with a string
     * @param filterItemId Filter by item id
     * @param filterUsername Filter by entries owned by the user with the specified username
     * @param filterGroup Filter by entries owned by the users in a given group, by unique name
     * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE).
     */
    public getUserInventories (id: number, inactive?: boolean, size?: number, page?: number, filterItemName?: string, filterItemId?: number, filterUsername?: string, filterGroup?: string, filterDate?: string) : Promise<{ response: http.ClientResponse; body: PageResourceUserInventoryResource;  }> {
        const localVarPath = this.basePath + '/users/{id}/inventory'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getUserInventories.');
        }

        if (inactive !== undefined) {
            queryParameters['inactive'] = ObjectSerializer.serialize(inactive, "boolean");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (filterItemName !== undefined) {
            queryParameters['filter_item_name'] = ObjectSerializer.serialize(filterItemName, "string");
        }

        if (filterItemId !== undefined) {
            queryParameters['filter_item_id'] = ObjectSerializer.serialize(filterItemId, "number");
        }

        if (filterUsername !== undefined) {
            queryParameters['filter_username'] = ObjectSerializer.serialize(filterUsername, "string");
        }

        if (filterGroup !== undefined) {
            queryParameters['filter_group'] = ObjectSerializer.serialize(filterGroup, "string");
        }

        if (filterDate !== undefined) {
            queryParameters['filter_date'] = ObjectSerializer.serialize(filterDate, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceUserInventoryResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceUserInventoryResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get an inventory entry
     * @param userId The id of the inventory owner or &#39;me&#39; for the logged in user
     * @param id The id of the user inventory
     */
    public getUserInventory (userId: number, id: number) : Promise<{ response: http.ClientResponse; body: UserInventoryResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/inventory/{id}'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserInventory.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getUserInventory.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserInventoryResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserInventoryResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List the log entries for this inventory entry
     * @param userId The id of the inventory owner or &#39;me&#39; for the logged in user
     * @param id The id of the user inventory
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getUserInventoryLog (userId: string, id: number, size?: number, page?: number) : Promise<{ response: http.ClientResponse; body: PageResourceUserItemLogResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/inventory/{id}/log'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserInventoryLog.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getUserInventoryLog.');
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceUserItemLogResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceUserItemLogResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List the user inventory entries for all users
     * @param inactive If true, accepts inactive user inventories
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param filterItemName Filter by items whose name starts with a string
     * @param filterItemId Filter by item id
     * @param filterUsername Filter by entries owned by the user with the specified username
     * @param filterGroup Filter by entries owned by the users in a given group, by unique name
     * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE).
     */
    public getUsersInventory (inactive?: boolean, size?: number, page?: number, filterItemName?: string, filterItemId?: number, filterUsername?: string, filterGroup?: string, filterDate?: string) : Promise<{ response: http.ClientResponse; body: PageResourceUserInventoryResource;  }> {
        const localVarPath = this.basePath + '/inventories';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (inactive !== undefined) {
            queryParameters['inactive'] = ObjectSerializer.serialize(inactive, "boolean");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (filterItemName !== undefined) {
            queryParameters['filter_item_name'] = ObjectSerializer.serialize(filterItemName, "string");
        }

        if (filterItemId !== undefined) {
            queryParameters['filter_item_id'] = ObjectSerializer.serialize(filterItemId, "number");
        }

        if (filterUsername !== undefined) {
            queryParameters['filter_username'] = ObjectSerializer.serialize(filterUsername, "string");
        }

        if (filterGroup !== undefined) {
            queryParameters['filter_group'] = ObjectSerializer.serialize(filterGroup, "string");
        }

        if (filterDate !== undefined) {
            queryParameters['filter_date'] = ObjectSerializer.serialize(filterDate, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceUserInventoryResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceUserInventoryResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Grant an entitlement
     * @param userId The id of the user to grant the entitlement to
     * @param grantRequest grantRequest
     */
    public grantUserEntitlement (userId: number, grantRequest: EntitlementGrantRequest) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/entitlements'
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling grantUserEntitlement.');
        }

        // verify required parameter 'grantRequest' is not null or undefined
        if (grantRequest === null || grantRequest === undefined) {
            throw new Error('Required parameter grantRequest was null or undefined when calling grantUserEntitlement.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(grantRequest, "EntitlementGrantRequest")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update an entitlement item
     * @param entitlementId The id of the entitlement
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param entitlementItem The entitlement item object
     */
    public updateEntitlementItem (entitlementId: number, cascade?: boolean, entitlementItem?: EntitlementItem) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/entitlements/{entitlement_id}'
            .replace('{' + 'entitlement_id' + '}', String(entitlementId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'entitlementId' is not null or undefined
        if (entitlementId === null || entitlementId === undefined) {
            throw new Error('Required parameter entitlementId was null or undefined when calling updateEntitlementItem.');
        }

        if (cascade !== undefined) {
            queryParameters['cascade'] = ObjectSerializer.serialize(cascade, "boolean");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(entitlementItem, "EntitlementItem")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update an entitlement template
     * @param id The id of the template
     * @param template The updated template
     */
    public updateEntitlementTemplate (id: string, template?: ItemTemplateResource) : Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }> {
        const localVarPath = this.basePath + '/entitlements/templates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateEntitlementTemplate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(template, "ItemTemplateResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemTemplateResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ItemTemplateResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set the behavior data for an inventory entry
     * @param userId The id of the user
     * @param id The id of the user inventory
     * @param data The data map
     */
    public updateUserInventoryBehaviorData (userId: number, id: number, data?: any) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/inventory/{id}/behavior-data'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling updateUserInventoryBehaviorData.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateUserInventoryBehaviorData.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "any")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Will change the current grace period for a subscription but not the bill date (possibly even ending before having the chance to re-bill)
     * @summary Set the expiration date
     * @param userId user_id
     * @param id The id of the user inventory
     * @param timestamp The new expiration date as a unix timestamp in seconds. May be null (no body).
     */
    public updateUserInventoryExpires (userId: number, id: number, timestamp?: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/inventory/{id}/expires'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling updateUserInventoryExpires.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateUserInventoryExpires.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(timestamp, "number")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set the status for an inventory entry
     * @param userId The id of the user
     * @param id The id of the user inventory
     * @param inventoryStatus The inventory status object
     */
    public updateUserInventoryStatus (userId: number, id: number, inventoryStatus?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/inventory/{id}/status'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling updateUserInventoryStatus.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateUserInventoryStatus.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(inventoryStatus, "string")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Use an item
     * @param userId The id of the user to check for or &#39;me&#39; for logged in user
     * @param itemId The id of the item
     * @param sku The specific sku of an entitlement_list addition to check entitlement for. This is of very limited and specific use and should generally be left out
     * @param info Any additional info to add to the log about this use
     */
    public useUserEntitlementItem (userId: string, itemId: number, sku?: string, info?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/entitlements/{item_id}/use'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'item_id' + '}', String(itemId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling useUserEntitlementItem.');
        }

        // verify required parameter 'itemId' is not null or undefined
        if (itemId === null || itemId === undefined) {
            throw new Error('Required parameter itemId was null or undefined when calling useUserEntitlementItem.');
        }

        if (sku !== undefined) {
            queryParameters['sku'] = ObjectSerializer.serialize(sku, "string");
        }

        if (info !== undefined) {
            queryParameters['info'] = ObjectSerializer.serialize(info, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UsersRelationshipsApiApiKeys {
}

export class UsersRelationshipsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UsersRelationshipsApiApiKeys, value: string) {
        this.authentications[UsersRelationshipsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Create a user relationship
     * @param relationship The new relationship
     */
    public createUserRelationship (relationship?: UserRelationshipResource) : Promise<{ response: http.ClientResponse; body: UserRelationshipResource;  }> {
        const localVarPath = this.basePath + '/users/relationships';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(relationship, "UserRelationshipResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserRelationshipResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserRelationshipResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a user relationship
     * @param id The id of the relationship
     */
    public deleteUserRelationship (id: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/relationships/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteUserRelationship.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a user relationship
     * @param id The id of the relationship
     */
    public getUserRelationship (id: number) : Promise<{ response: http.ClientResponse; body: UserRelationshipResource;  }> {
        const localVarPath = this.basePath + '/users/relationships/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getUserRelationship.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserRelationshipResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserRelationshipResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a list of user relationships
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getUserRelationships (size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceUserRelationshipResource;  }> {
        const localVarPath = this.basePath + '/users/relationships';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceUserRelationshipResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceUserRelationshipResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a user relationship
     * @param id The id of the relationship
     * @param relationship The new relationship
     */
    public updateUserRelationship (id: number, relationship?: UserRelationshipResource) : Promise<{ response: http.ClientResponse; body: UserRelationshipResource;  }> {
        const localVarPath = this.basePath + '/users/relationships/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateUserRelationship.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(relationship, "UserRelationshipResource")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserRelationshipResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserRelationshipResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UsersSubscriptionsApiApiKeys {
}

export class UsersSubscriptionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UsersSubscriptionsApiApiKeys, value: string) {
        this.authentications[UsersSubscriptionsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Get details about a user's subscription
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     */
    public getUserSubscriptionDetails (userId: number, inventoryId: number) : Promise<{ response: http.ClientResponse; body: InventorySubscriptionResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/subscriptions/{inventory_id}'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'inventory_id' + '}', String(inventoryId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserSubscriptionDetails.');
        }

        // verify required parameter 'inventoryId' is not null or undefined
        if (inventoryId === null || inventoryId === undefined) {
            throw new Error('Required parameter inventoryId was null or undefined when calling getUserSubscriptionDetails.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InventorySubscriptionResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InventorySubscriptionResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get details about a user's subscriptions
     * @param userId The id of the user
     */
    public getUsersSubscriptionDetails (userId: number) : Promise<{ response: http.ClientResponse; body: Array<InventorySubscriptionResource>;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/subscriptions'
            .replace('{' + 'user_id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUsersSubscriptionDetails.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<InventorySubscriptionResource>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<InventorySubscriptionResource>");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Reactivate a subscription and charge fee
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param reactivateSubscriptionRequest The reactivate subscription request object inventory
     */
    public reactivateUserSubscription (userId: number, inventoryId: number, reactivateSubscriptionRequest?: ReactivateSubscriptionRequest) : Promise<{ response: http.ClientResponse; body: InvoiceResource;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/subscriptions/{inventory_id}/reactivate'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'inventory_id' + '}', String(inventoryId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling reactivateUserSubscription.');
        }

        // verify required parameter 'inventoryId' is not null or undefined
        if (inventoryId === null || inventoryId === undefined) {
            throw new Error('Required parameter inventoryId was null or undefined when calling reactivateUserSubscription.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(reactivateSubscriptionRequest, "ReactivateSubscriptionRequest")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InvoiceResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InvoiceResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set a new date to bill a subscription on
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param billDate The new bill date. Unix timestamp in seconds
     */
    public setSubscriptionBillDate (userId: number, inventoryId: number, billDate: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/subscriptions/{inventory_id}/bill-date'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'inventory_id' + '}', String(inventoryId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling setSubscriptionBillDate.');
        }

        // verify required parameter 'inventoryId' is not null or undefined
        if (inventoryId === null || inventoryId === undefined) {
            throw new Error('Required parameter inventoryId was null or undefined when calling setSubscriptionBillDate.');
        }

        // verify required parameter 'billDate' is not null or undefined
        if (billDate === null || billDate === undefined) {
            throw new Error('Required parameter billDate was null or undefined when calling setSubscriptionBillDate.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(billDate, "number")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * May send null to use floating default
     * @summary Set the payment method to use for a subscription
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param paymentMethodId The id of the payment method
     */
    public setSubscriptionPaymentMethod (userId: number, inventoryId: number, paymentMethodId?: IntWrapper) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/subscriptions/{inventory_id}/payment-method'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'inventory_id' + '}', String(inventoryId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling setSubscriptionPaymentMethod.');
        }

        // verify required parameter 'inventoryId' is not null or undefined
        if (inventoryId === null || inventoryId === undefined) {
            throw new Error('Required parameter inventoryId was null or undefined when calling setSubscriptionPaymentMethod.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(paymentMethodId, "IntWrapper")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Note that the new status may be blocked if the system is not configured to allow the current status to be changed to the new, to enforce proper flow. The default options for statuses are shown below but may be altered for special use cases
     * @summary Set the status of a subscription
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param status The new status for the subscription. Actual options may differ from the indicated set if the invoice status type data has been altered.  Allowable values: (&#39;current&#39;, &#39;canceled&#39;, &#39;stopped&#39;, &#39;payment_failed&#39;, &#39;suspended&#39;)
     */
    public setSubscriptionStatus (userId: number, inventoryId: number, status: StringWrapper) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/subscriptions/{inventory_id}/status'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'inventory_id' + '}', String(inventoryId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling setSubscriptionStatus.');
        }

        // verify required parameter 'inventoryId' is not null or undefined
        if (inventoryId === null || inventoryId === undefined) {
            throw new Error('Required parameter inventoryId was null or undefined when calling setSubscriptionStatus.');
        }

        // verify required parameter 'status' is not null or undefined
        if (status === null || status === undefined) {
            throw new Error('Required parameter status was null or undefined when calling setSubscriptionStatus.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(status, "StringWrapper")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set a new subscription plan for a user
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param planId The id of the new plan. Must be from the same subscription
     */
    public setUserSubscriptionPlan (userId: number, inventoryId: number, planId?: StringWrapper) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/subscriptions/{inventory_id}/plan'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'inventory_id' + '}', String(inventoryId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling setUserSubscriptionPlan.');
        }

        // verify required parameter 'inventoryId' is not null or undefined
        if (inventoryId === null || inventoryId === undefined) {
            throw new Error('Required parameter inventoryId was null or undefined when calling setUserSubscriptionPlan.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(planId, "StringWrapper")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This new price will be what the user is charged at the begining of each new period. This override is specific to the current subscription and will not carry over if they end and later re-subscribe. It will persist if the plan is changed using the setUserSubscriptionPlan endpoint.
     * @summary Set a new subscription price for a user
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param the override details override
     */
    public setUserSubscriptionPrice (userId: number, inventoryId: number, the override details?: SubscriptionPriceOverrideRequest) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_id}/subscriptions/{inventory_id}/price-override'
            .replace('{' + 'user_id' + '}', String(userId))
            .replace('{' + 'inventory_id' + '}', String(inventoryId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling setUserSubscriptionPrice.');
        }

        // verify required parameter 'inventoryId' is not null or undefined
        if (inventoryId === null || inventoryId === undefined) {
            throw new Error('Required parameter inventoryId was null or undefined when calling setUserSubscriptionPrice.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(the override details, "SubscriptionPriceOverrideRequest")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UtilBatchApiApiKeys {
}

export class UtilBatchApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UtilBatchApiApiKeys, value: string) {
        this.authentications[UtilBatchApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * Tokens expire in 24 hours
     * @summary Get batch result with token
     * @param token token
     */
    public getBatch (token: string) : Promise<{ response: http.ClientResponse; body: Array<BatchReturn>;  }> {
        const localVarPath = this.basePath + '/batch/{token}'
            .replace('{' + 'token' + '}', String(token));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'token' is not null or undefined
        if (token === null || token === undefined) {
            throw new Error('Required parameter token was null or undefined when calling getBatch.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<BatchReturn>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<BatchReturn>");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Should the request take longer than one of the alloted timeout parameters, a token will be returned instead, which can be used on the token endpoint in this service
     * @summary Request to run API call given the method, content type, path url, and body of request
     * @param batch The batch object
     */
    public sendBatch (batch?: Batch) : Promise<{ response: http.ClientResponse; body: Array<BatchReturn>;  }> {
        const localVarPath = this.basePath + '/batch';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(batch, "Batch")
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<BatchReturn>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<BatchReturn>");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UtilHealthApiApiKeys {
}

export class UtilHealthApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UtilHealthApiApiKeys, value: string) {
        this.authentications[UtilHealthApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Get health info
     */
    public getHealth () : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/health';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UtilMaintenanceApiApiKeys {
}

export class UtilMaintenanceApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UtilMaintenanceApiApiKeys, value: string) {
        this.authentications[UtilMaintenanceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Delete maintenance info
     */
    public deleteMaintenance () : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/maintenance';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get current maintenance info. 404 if no maintenance.
     * @summary Get current maintenance info
     */
    public getMaintenance () : Promise<{ response: http.ClientResponse; body: Maintenance;  }> {
        const localVarPath = this.basePath + '/maintenance';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Maintenance;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Maintenance");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set current maintenance info
     * @param maintenance The maintenance object
     */
    public setMaintenance (maintenance?: Maintenance) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/maintenance';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(maintenance, "Maintenance")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update current maintenance info
     * @param maintenance The maintenance object
     */
    public updateMaintenance (maintenance?: Maintenance) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/maintenance';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(maintenance, "Maintenance")
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UtilSecurityApiApiKeys {
}

export class UtilSecurityApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UtilSecurityApiApiKeys, value: string) {
        this.authentications[UtilSecurityApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * A log entry is recorded everytime a user requests a new token. Standard pagination available
     * @summary Returns the authentication log for a user
     * @param userId The user id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getUserLocationLog (userId?: number, size?: number, page?: number, order?: string) : Promise<{ response: http.ClientResponse; body: PageResourceLocationLogResource;  }> {
        const localVarPath = this.basePath + '/security/country-log';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (userId !== undefined) {
            queryParameters['user_id'] = ObjectSerializer.serialize(userId, "number");
        }

        if (size !== undefined) {
            queryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (page !== undefined) {
            queryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            queryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PageResourceLocationLogResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageResourceLocationLogResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns the authentication token details. Use /users endpoint for detailed user's info
     */
    public getUserTokenDetails () : Promise<{ response: http.ClientResponse; body: TokenDetailsResource;  }> {
        const localVarPath = this.basePath + '/me';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TokenDetailsResource;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TokenDetailsResource");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UtilVersionApiApiKeys {
}

export class UtilVersionApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UtilVersionApiApiKeys, value: string) {
        this.authentications[UtilVersionApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Get current version info
     */
    public getVersion () : Promise<{ response: http.ClientResponse; body: Version;  }> {
        const localVarPath = this.basePath + '/version';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Version;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Version");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
